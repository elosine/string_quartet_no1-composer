<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Quartet No.1 Composer</title>
    <style>
        :root {
            --clr-brightOrange: rgba(240,75,0,255);
            --clr-brightOrange2: #ea4607;
            --clr-brightBlue: rgba(56,126,211,255);
            --clr-mustard: rgba(244,182,0,255);
            --clr-brightRed: rgba(229,42,25,255);
            --clr-brightRed2: #dc3f3d;
            --clr-darkRed2: #9a0504;
            --clr-darkRed: #a60701;
            --clr-green: rgba(0,147,92,255);
            --clr-limeGreen: rgb(153,255,0);
            --clr-brightGreen: #31d196;
            --clr-navyBlue: rgba(28,72,121,255);
            --clr-plum: rgba(82,44,85,255);
            --clr-lavander: rgba(162,126,198,255);
            --clr-lightGrey: #adadb7;
            --clr-blueGrey: #708090;
            --clr-lightGreen: #85b068;
            --clr-yellow: rgba(254,213,0,255);
            --clr-neonMagenta: rgb(255, 21, 160);
            
            /* Cursor Colors */
            --cursor-staff1-color: var(--clr-limeGreen);
            --cursor-staff2-color: var(--clr-neonMagenta);
            --cursor-staff3-color: var(--clr-brightBlue);
            --cursor-staff4-color: var(--clr-brightOrange);
            
            /* Staff Dimensions - staves start below timeline area and divide remaining space into 4 equal parts */
            /* Timeline area: ~16px for seconds ticks/labels + beat ticks/labels */
            --timeline-height: 16px;
            
            /* ScoreTop Staff Y positions - start after timeline */
            --scoreTop-staff1-y: 0%;
            --scoreTop-staff2-y: 25%;
            --scoreTop-staff3-y: 50%;
            --scoreTop-staff4-y: 75%;
            
            /* ScoreBottom Staff Y positions - start after timeline */
            --scoreBottom-staff1-y: 0%;
            --scoreBottom-staff2-y: 25%;
            --scoreBottom-staff3-y: 50%;
            --scoreBottom-staff4-y: 75%;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: black;
            min-height: 100vh;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px;
        }
        #ScoreContainer {
            background: var(--clr-blueGrey);
            width: 100%;
            height: 100%;
            max-width: calc((100vh - 10px) * 4 / 3);
            max-height: calc((100vw - 10px) * 3 / 4);
            aspect-ratio: 4 / 3;
            display: flex;
            flex-direction: column;
        }
        .score-row {
            flex: 1;
            display: flex;
            flex-direction: row;
            align-items: stretch;
        }
        .static-motive-panel {
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            margin: 0;
            padding: 0;
            border: none;
            box-sizing: border-box;
        }
        .static-motive-box {
            background: white;
            margin: 0;
            padding: 0;
            border: 1px solid black;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .static-motive-slot {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border: 1px solid black;
            box-sizing: border-box;
        }
        .static-motive-slot img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        #ScoreTop {
            background: white;
            flex: 1;
            margin: 5px 5px 5px 0;
            border: none;
            position: relative;
        }
        #ScoreBottom {
            background: white;
            flex: 1;
            margin: 5px 5px 5px 0;
            border: none;
            position: relative;
        }
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #00d4ff, #7b2ff7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
        }
        p {
            color: #a0a0a0;
            font-size: 1.1rem;
        }
        
        /* Control Menu Styles */
        #controlMenu {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            width: 250px;
            background: rgba(30, 30, 40, 0.95);
            transform: translateX(-245px);
            transition: transform 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: row;
        }
        #controlMenu.open {
            transform: translateX(0);
        }
        #menuContent {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }
        #menuToggle {
            width: 25px;
            background: var(--clr-navyBlue);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 12px;
            color: white;
            user-select: none;
        }
        #menuToggle:hover {
            background: var(--clr-brightBlue);
        }
        .menu-section {
            margin-bottom: 20px;
        }
        .menu-section h3 {
            color: var(--clr-brightBlue);
            font-size: 14px;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--clr-blueGrey);
            padding-bottom: 5px;
        }
        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .control-row label {
            font-size: 12px;
            color: var(--clr-lightGrey);
            width: 80px;
            flex-shrink: 0;
        }
        .control-row input[type="range"] {
            flex: 1;
            margin-right: 10px;
            accent-color: var(--clr-brightBlue);
        }
        .control-row input[type="number"] {
            width: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--clr-blueGrey);
            color: white;
            padding: 3px 5px;
            font-size: 12px;
            border-radius: 3px;
        }
        .control-row input[type="number"]:focus {
            outline: none;
            border-color: var(--clr-brightBlue);
        }
        .frame-rate-display {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--clr-blueGrey);
            color: var(--clr-brightGreen);
            padding: 3px 8px;
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', monospace;
            border-radius: 3px;
            min-width: 60px;
            text-align: center;
        }
        
        /* Playback-MIDI Menu (Right Side) */
        #cursorMenu {
            position: fixed;
            right: 0;
            top: 0;
            height: 100vh;
            width: 280px;
            background: rgba(30, 30, 40, 0.95);
            transform: translateX(255px);
            transition: transform 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: row;
        }
        #cursorMenu.open {
            transform: translateX(0);
        }
        #cursorMenuToggle {
            width: 25px;
            background: var(--clr-navyBlue);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 11px;
            color: white;
            user-select: none;
        }
        #cursorMenuToggle:hover {
            background: var(--clr-brightBlue);
        }
        #cursorMenuContent {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }
        
        /* Track Radio Buttons (T1-T4) */
        .track-radio-group {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            gap: 4px;
        }
        .track-radio-group input[type="radio"] {
            display: none;
        }
        .track-radio-group label {
            flex: 1;
            text-align: center;
            padding: 6px 4px;
            background: rgba(40, 40, 50, 0.6);
            border: 1px solid #555;
            border-radius: 3px;
            color: #aaa;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .track-radio-group label:hover {
            background: rgba(60, 60, 80, 0.6);
            border-color: #777;
        }
        .track-radio-group input[type="radio"]:checked + label {
            background: var(--clr-brightBlue);
            border-color: var(--clr-brightBlue);
            color: #fff;
        }
        
        /* MIDI Select Dropdowns */
        .midi-select {
            flex: 1;
            background: #2a2a3a;
            border: 1px solid var(--clr-blueGrey);
            color: white;
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 3px;
            max-width: 140px;
        }
        .midi-select:focus {
            outline: none;
            border-color: var(--clr-brightBlue);
        }
        
        /* MIDI Filename Display */
        .midi-filename {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--clr-blueGrey);
            color: var(--clr-lightGrey);
            padding: 4px 8px;
            font-size: 10px;
            border-radius: 3px;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Small Timecode Display */
        .timecode-display-small {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--clr-blueGrey);
            color: var(--clr-brightGreen);
            padding: 4px 8px;
            font-size: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            border-radius: 3px;
            min-width: 70px;
            text-align: center;
        }
        
        /* Track Enable Toggles */
        .track-enable-group {
            margin-top: 10px;
        }
        .track-enable-label {
            font-size: 11px;
            color: var(--clr-lightGrey);
            display: block;
            margin-bottom: 6px;
        }
        .track-toggles {
            display: flex;
            gap: 4px;
        }
        .track-toggles input[type="checkbox"] {
            display: none;
        }
        .track-toggles label {
            flex: 1;
            text-align: center;
            padding: 6px 4px;
            background: rgba(40, 40, 50, 0.6);
            border: 1px solid #555;
            border-radius: 3px;
            color: #666;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .track-toggles label:hover {
            background: rgba(60, 60, 80, 0.6);
            border-color: #777;
        }
        .track-toggles input[type="checkbox"]:checked + label {
            background: var(--clr-brightGreen);
            border-color: var(--clr-brightGreen);
            color: #000;
        }
        
        /* Display Toggles */
        .display-toggles {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .display-toggles input[type="checkbox"] {
            display: none;
        }
        .display-toggles label {
            display: block;
            padding: 6px 10px;
            background: rgba(40, 40, 50, 0.6);
            border: 1px solid #555;
            border-radius: 3px;
            color: #666;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .display-toggles label:hover {
            background: rgba(60, 60, 80, 0.6);
            border-color: #777;
        }
        .display-toggles input[type="checkbox"]:checked + label {
            background: var(--clr-brightBlue);
            border-color: var(--clr-brightBlue);
            color: #fff;
        }
        .control-btn {
            width: 100%;
            padding: 8px 12px;
            background: var(--clr-navyBlue);
            border: 1px solid var(--clr-blueGrey);
            color: white;
            font-size: 12px;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .control-btn:hover {
            background: var(--clr-brightBlue);
        }
        .control-btn.active {
            background: var(--clr-brightRed);
        }
        
        /* Transport Controls */
        .transport-controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .transport-btn {
            width: 32px !important;
            height: 32px;
            padding: 0 !important;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .timecode-display {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--clr-blueGrey);
            color: var(--clr-brightGreen);
            padding: 6px 12px;
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', monospace;
            border-radius: 3px;
            min-width: 120px;
            text-align: center;
        }
        .file-input-hidden {
            display: none;
        }
        
        /* Composition Panel (Left Side) */
        #compositionPanel {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            width: 280px;
            background: rgba(30, 30, 40, 0.95);
            transform: translateX(-255px);
            transition: transform 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: row;
        }
        #compositionPanel.open {
            transform: translateX(0);
        }
        #compositionPanelToggle {
            width: 25px;
            background: var(--clr-plum);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 12px;
            color: white;
            user-select: none;
        }
        #compositionPanelToggle:hover {
            background: var(--clr-lavander);
        }
        #compositionPanelContent {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }
        .edit-cursor-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--clr-yellow);
            color: var(--clr-yellow);
            padding: 8px 12px;
            font-size: 16px;
            font-family: 'Consolas', 'Monaco', monospace;
            border-radius: 4px;
            text-align: center;
        }
        .edit-cursor-input:focus {
            outline: none;
            border-color: var(--clr-limeGreen);
        }
        
        /* G Track Radio Buttons */
        .gtrack-radio-group {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            gap: 4px;
            margin-top: 10px;
        }
        .gtrack-radio-group input[type="radio"] {
            display: none;
        }
        .gtrack-radio-group label {
            flex: 1;
            text-align: center;
            padding: 6px 4px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            border-radius: 4px;
            color: #aaa;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .gtrack-radio-group label:hover {
            background: rgba(60, 60, 80, 0.6);
            border-color: #777;
        }
        .gtrack-radio-group input[type="radio"]:checked + label {
            background: var(--clr-yellow);
            border-color: var(--clr-yellow);
            color: #000;
        }
        
        /* Curve Maker Styles */
        .curve-input-row {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            align-items: center;
        }
        .curve-input-row label {
            font-size: 10px;
            color: #aaa;
            min-width: 35px;
        }
        .curve-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #555;
            color: #fff;
            padding: 4px 6px;
            font-size: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            border-radius: 3px;
            text-align: center;
            width: 60px;
        }
        .curve-input:focus {
            outline: none;
            border-color: var(--clr-yellow);
        }
        .curve-draw-btn {
            background: var(--clr-plum);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            margin-top: 8px;
            width: 100%;
        }
        .curve-draw-btn:hover {
            background: var(--clr-lavander);
        }
        .curve-fill-toggle {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }
        .curve-fill-toggle input[type="radio"] {
            display: none;
        }
        .curve-fill-toggle label {
            flex: 1;
            text-align: center;
            padding: 4px 2px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            border-radius: 3px;
            color: #aaa;
            font-size: 9px;
            cursor: pointer;
        }
        .curve-fill-toggle input[type="radio"]:checked + label {
            background: var(--clr-lavander);
            border-color: var(--clr-lavander);
            color: #000;
        }
        .color-swatches {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
        }
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid transparent;
            cursor: pointer;
        }
        .color-swatch:hover {
            border-color: #fff;
        }
        .color-swatch.selected {
            border-color: #fff;
            box-shadow: 0 0 4px rgba(255,255,255,0.5);
        }
        .section-divider {
            border-top: 1px solid #444;
            margin: 12px 0 8px 0;
            padding-top: 8px;
        }
        .section-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }
        
        /* Curve Selection Bounding Box */
        .curve-bounding-box {
            fill-opacity: 0.1;
            stroke-width: 2;
            stroke-dasharray: 6,3;
            cursor: pointer;
        }
        
        /* Edit Cursor Styles */
        .edit-cursor-line {
            stroke: rgba(254, 254, 0, 0.8);
            stroke-width: 5;
            cursor: ew-resize;
        }
        .edit-cursor-handle {
            fill: rgba(254, 254, 0, 0.8);
            cursor: ew-resize;
        }
        
        /* SVG Element Manager Styles */
        .svg-element-wrapper {
            cursor: move;
        }
        .svg-element-wrapper.selected {
            outline: 2px dashed var(--clr-brightBlue);
            outline-offset: 2px;
        }
        .svg-resize-handle {
            fill: var(--clr-brightBlue);
            stroke: white;
            stroke-width: 1;
            cursor: nwse-resize;
        }
        .svg-resize-handle.corner-nw { cursor: nwse-resize; }
        .svg-resize-handle.corner-ne { cursor: nesw-resize; }
        .svg-resize-handle.corner-sw { cursor: nesw-resize; }
        .svg-resize-handle.corner-se { cursor: nwse-resize; }
        .svg-element-list {
            max-height: 100px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border: 1px solid #444;
            border-radius: 3px;
            margin-top: 5px;
        }
        .svg-element-item {
            padding: 4px 8px;
            font-size: 10px;
            color: #aaa;
            cursor: pointer;
            border-bottom: 1px solid #333;
        }
        .svg-element-item:hover {
            background: rgba(60,60,80,0.6);
        }
        .svg-element-item.selected {
            background: var(--clr-brightBlue);
            color: white;
        }
        
        /* Flowchart Connector Styles */
        .flowchart-connector {
            pointer-events: stroke;
        }
        .flowchart-connector-path {
            fill: none;
            stroke-width: 2;
            pointer-events: stroke;
            cursor: pointer;
        }
        .flowchart-connector.selected .flowchart-connector-path {
            stroke-width: 3;
            filter: drop-shadow(0 0 3px yellow);
        }
        .flowchart-connector-hitarea {
            fill: none;
            stroke: transparent;
            stroke-width: 12;
            pointer-events: stroke;
            cursor: pointer;
        }
        .flowchart-node {
            fill: var(--clr-brightBlue);
            stroke: white;
            stroke-width: 2;
            cursor: crosshair;
        }
        .flowchart-node:hover {
            fill: var(--clr-neonYellow);
        }
        .connector-list {
            max-height: 80px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border: 1px solid #444;
            border-radius: 3px;
            margin-top: 5px;
        }
        .connector-item {
            padding: 4px 8px;
            font-size: 10px;
            color: #aaa;
            cursor: pointer;
            border-bottom: 1px solid #333;
        }
        .connector-item:hover {
            background: rgba(60,60,80,0.6);
        }
        .connector-item.selected {
            background: var(--clr-plum);
            color: white;
        }
    </style>
</head>
<body>
    <!-- Composition Panel (Left) -->
    <div id="compositionPanel">
        <div id="compositionPanelContent">
            <div class="menu-section">
                <div class="control-row">
                    <input type="text" id="editCursorSecondsInput" class="edit-cursor-input" value="0.000">
                </div>
                <div class="section-divider"></div>
                <div class="section-label">Curve Segments</div>
                
                <div class="curve-input-row">
                    <button id="segmentX1Btn" class="control-btn" style="font-size: 10px; width: 30px;">X1</button>
                    <input type="number" id="segmentX1Input" class="curve-input" value="0.0" step="0.1" style="width: 60px;">
                    <span style="font-size: 10px; color: #888;">s</span>
                </div>
                <div class="curve-input-row">
                    <button id="segmentX2Btn" class="control-btn" style="font-size: 10px; width: 30px;">X2</button>
                    <input type="number" id="segmentX2Input" class="curve-input" value="0.0" step="0.1" style="width: 60px;">
                    <span style="font-size: 10px; color: #888;">s</span>
                </div>
                <div class="control-row" style="margin-top: 5px;">
                    <button id="segmentCreateBtn" class="control-btn" style="font-size: 10px;">Segment</button>
                    <button id="segmentClearBtn" class="control-btn" style="font-size: 10px;">Clear</button>
                </div>
                
                <div class="section-divider"></div>
                <div class="section-label">Curve Maker</div>
                
                <div class="curve-input-row">
                    <label>Name</label>
                    <input type="text" id="curveNameDisplay" class="curve-input" value="" readonly style="background: rgba(40,40,50,0.8); color: #aaa;">
                </div>
                <div class="curve-input-row">
                    <label>Start</label>
                    <input type="text" id="curveStartInput" class="curve-input" value="0.000">
                </div>
                <div class="curve-input-row">
                    <label>End</label>
                    <input type="text" id="curveEndInput" class="curve-input" value="1.000">
                </div>
                <div class="curve-input-row">
                    <label>Y1</label>
                    <input type="text" id="curveY1Input" class="curve-input" value="0.0">
                </div>
                <div class="curve-input-row">
                    <label>Y2</label>
                    <input type="text" id="curveY2Input" class="curve-input" value="10.0">
                </div>
                
                <button id="curveDrawBtn" class="curve-draw-btn">Draw</button>
                <button id="curveDeleteBtn" class="curve-draw-btn" style="margin-top: 5px;">Delete</button>
                <button id="curveSaveBtn" class="curve-draw-btn" style="margin-top: 5px;">Save</button>
                
                <div class="curve-input-row" style="margin-top: 8px;">
                    <label style="font-size: 10px;">Description</label>
                </div>
                <textarea id="curveDescriptionInput" class="curve-input" style="width: 100%; height: 40px; resize: vertical; font-size: 10px;" placeholder="Curve description..."></textarea>
                
                <div class="curve-input-row" style="margin-top: 8px;">
                    <label style="font-size: 10px;">Recall Curve</label>
                </div>
                <div id="curveRecallDropdown" class="custom-dropdown" style="width: 100%; position: relative;">
                    <div id="curveRecallSelected" class="custom-dropdown-selected" style="font-size: 10px; padding: 4px 6px; background: rgba(40,40,50,0.9); border: 1px solid #555; border-radius: 3px; cursor: pointer; min-height: 20px;">
                        -- Select Saved Curve --
                    </div>
                    <div id="curveRecallOptions" class="custom-dropdown-options" style="display: none; position: absolute; top: 100%; left: 0; right: 0; max-height: 200px; overflow-y: auto; background: rgba(30,30,40,0.98); border: 1px solid #555; border-top: none; border-radius: 0 0 3px 3px; z-index: 1000;">
                    </div>
                </div>
                <input type="hidden" id="curveRecallSelect" value="">
                <button id="curveInsertBtn" class="curve-draw-btn" style="margin-top: 5px;">Insert at Edit Line</button>
                
                <div class="curve-fill-toggle">
                    <input type="radio" id="curveFillLine" name="curveFill" value="line" checked>
                    <label for="curveFillLine">Line</label>
                    <input type="radio" id="curveFillBottom" name="curveFill" value="bottom">
                    <label for="curveFillBottom">Fill ↓</label>
                    <input type="radio" id="curveFillTop" name="curveFill" value="top">
                    <label for="curveFillTop">Fill ↑</label>
                </div>
                
                <div class="gtrack-radio-group">
                    <input type="radio" id="gtrackG1" name="gtrack" value="1">
                    <label for="gtrackG1">T1</label>
                    <input type="radio" id="gtrackG2" name="gtrack" value="2">
                    <label for="gtrackG2">T2</label>
                    <input type="radio" id="gtrackG3" name="gtrack" value="3">
                    <label for="gtrackG3">T3</label>
                    <input type="radio" id="gtrackG4" name="gtrack" value="4">
                    <label for="gtrackG4">T4</label>
                    <input type="radio" id="gtrackGA" name="gtrack" value="A" checked>
                    <label for="gtrackGA">TA</label>
                </div>
                
                <div class="section-label" style="margin-top: 10px;">Color</div>
                <div class="color-swatches" id="colorSwatches">
                    <div class="color-swatch selected" data-color="brightOrange" style="background: var(--clr-brightOrange);"></div>
                    <div class="color-swatch" data-color="brightBlue" style="background: var(--clr-brightBlue);"></div>
                    <div class="color-swatch" data-color="mustard" style="background: var(--clr-mustard);"></div>
                    <div class="color-swatch" data-color="brightRed" style="background: var(--clr-brightRed);"></div>
                    <div class="color-swatch" data-color="green" style="background: var(--clr-green);"></div>
                    <div class="color-swatch" data-color="limeGreen" style="background: var(--clr-limeGreen);"></div>
                    <div class="color-swatch" data-color="brightGreen" style="background: var(--clr-brightGreen);"></div>
                    <div class="color-swatch" data-color="navyBlue" style="background: var(--clr-navyBlue);"></div>
                    <div class="color-swatch" data-color="plum" style="background: var(--clr-plum);"></div>
                    <div class="color-swatch" data-color="lavander" style="background: var(--clr-lavander);"></div>
                    <div class="color-swatch" data-color="yellow" style="background: var(--clr-yellow);"></div>
                    <div class="color-swatch" data-color="neonMagenta" style="background: var(--clr-neonMagenta);"></div>
                </div>
                
                <div class="section-divider"></div>
                <div class="section-label">Motive Maker</div>
                
                <!-- DISABLED: Name field (code kept in MotiveMaker)
                <div class="curve-input-row">
                    <label>Name</label>
                    <input type="text" id="motiveNameDisplay" class="curve-input" value="" readonly style="background: rgba(40,40,50,0.8); color: #aaa;">
                </div>
                -->
                <div class="curve-input-row">
                    <label>Start</label>
                    <input type="text" id="motiveStartInput" class="curve-input" value="0.000">
                </div>
                <div class="curve-input-row">
                    <label>End</label>
                    <input type="text" id="motiveEndInput" class="curve-input" value="1.000">
                </div>
                
                <!-- DISABLED: Badge section (code kept in MotiveMaker)
                <div class="curve-input-row" style="margin-top: 8px;">
                    <label style="font-size: 10px;">Badge</label>
                    <button id="motiveBadgeUploadBtn" class="curve-draw-btn" style="font-size: 9px; padding: 2px 6px; margin-left: 5px; background: #2d5a4a; border-color: #3d6a5a;">Upload</button>
                    <button id="motiveBadgeClearBtn" class="curve-draw-btn" style="font-size: 9px; padding: 2px 6px; margin-left: 2px; background: #2d5a4a; border-color: #3d6a5a;">Clear</button>
                    <input type="file" id="motiveBadgeFileInput" class="file-input-hidden" accept=".svg,.png,.jpg,.jpeg" style="display: none;">
                </div>
                <div id="motiveBadgePreview" style="width: 100%; height: 30px; background: rgba(30,30,40,0.5); border: 1px solid #444; border-radius: 3px; margin-top: 4px; display: flex; align-items: center; justify-content: center; overflow: hidden;">
                    <span style="font-size: 9px; color: #666;">No badge</span>
                </div>
                -->
                
                <!-- DISABLED: Notation section (code kept in MotiveMaker)
                <div class="curve-input-row" style="margin-top: 8px;">
                    <label style="font-size: 10px;">Notation</label>
                    <button id="motiveNotationUploadBtn" class="curve-draw-btn" style="font-size: 9px; padding: 2px 6px; margin-left: 5px; background: #2d5a4a; border-color: #3d6a5a;">Upload</button>
                    <button id="motiveNotationClearBtn" class="curve-draw-btn" style="font-size: 9px; padding: 2px 6px; margin-left: 2px; background: #2d5a4a; border-color: #3d6a5a;">Clear</button>
                    <input type="file" id="motiveNotationFileInput" class="file-input-hidden" accept=".svg,.png,.jpg,.jpeg" style="display: none;">
                </div>
                <div id="motiveNotationPreview" style="width: 100%; height: 40px; background: #ffffff; border: 1px solid #444; border-radius: 3px; margin-top: 4px; display: flex; align-items: center; justify-content: center; overflow: hidden;">
                    <span style="font-size: 9px; color: #666;">No notation</span>
                </div>
                -->
                
                <button id="motiveDrawBtn" class="curve-draw-btn" style="background: #2d5a4a; border-color: #3d6a5a;">Draw</button>
                <button id="motiveDeleteBtn" class="curve-draw-btn" style="margin-top: 5px; background: #2d5a4a; border-color: #3d6a5a;">Delete</button>
                <!-- DISABLED: Save button (code kept in MotiveMaker)
                <button id="motiveSaveBtn" class="curve-draw-btn" style="margin-top: 5px; background: #2d5a4a; border-color: #3d6a5a;">Save</button>
                -->
                
                <!-- DISABLED: Description field (code kept in MotiveMaker)
                <div class="curve-input-row" style="margin-top: 8px;">
                    <label style="font-size: 10px;">Description</label>
                </div>
                <textarea id="motiveDescriptionInput" class="curve-input" style="width: 100%; height: 40px; resize: vertical; font-size: 10px;" placeholder="Motive description..."></textarea>
                -->
                
                <!-- DISABLED: Recall section and Insert button (code kept in MotiveMaker)
                <div class="curve-input-row" style="margin-top: 8px;">
                    <label style="font-size: 10px;">Recall Motive</label>
                </div>
                <div id="motiveRecallDropdown" class="custom-dropdown" style="width: 100%; position: relative;">
                    <div id="motiveRecallSelected" class="custom-dropdown-selected" style="font-size: 10px; padding: 4px 6px; background: rgba(40,40,50,0.9); border: 1px solid #555; border-radius: 3px; cursor: pointer; min-height: 20px;">
                        -- Select Saved Motive --
                    </div>
                    <div id="motiveRecallOptions" class="custom-dropdown-options" style="display: none; position: absolute; top: 100%; left: 0; right: 0; max-height: 200px; overflow-y: auto; background: rgba(30,30,40,0.98); border: 1px solid #555; border-top: none; border-radius: 0 0 3px 3px; z-index: 1000;">
                    </div>
                </div>
                <input type="hidden" id="motiveRecallSelect" value="">
                <button id="motiveInsertBtn" class="curve-draw-btn" style="margin-top: 5px; background: #2d5a4a; border-color: #3d6a5a;">Insert at Edit Line</button>
                -->
                
<!-- DISABLED: Motive Color swatches - now using curve color swatches
                <div class="section-label" style="margin-top: 10px;">Motive Color</div>
                <div class="color-swatches" id="motiveColorSwatches">
                    <div class="motive-color-swatch" data-color="brightOrange" style="background: var(--clr-brightOrange); width: 16px; height: 16px; border-radius: 2px; cursor: pointer; display: inline-block; margin: 2px;"></div>
                    <div class="motive-color-swatch" data-color="brightBlue" style="background: var(--clr-brightBlue); width: 16px; height: 16px; border-radius: 2px; cursor: pointer; display: inline-block; margin: 2px;"></div>
                    <div class="motive-color-swatch" data-color="mustard" style="background: var(--clr-mustard); width: 16px; height: 16px; border-radius: 2px; cursor: pointer; display: inline-block; margin: 2px;"></div>
                    <div class="motive-color-swatch" data-color="brightRed" style="background: var(--clr-brightRed); width: 16px; height: 16px; border-radius: 2px; cursor: pointer; display: inline-block; margin: 2px;"></div>
                    <div class="motive-color-swatch" data-color="green" style="background: var(--clr-green); width: 16px; height: 16px; border-radius: 2px; cursor: pointer; display: inline-block; margin: 2px;"></div>
                    <div class="motive-color-swatch" data-color="limeGreen" style="background: var(--clr-limeGreen); width: 16px; height: 16px; border-radius: 2px; cursor: pointer; display: inline-block; margin: 2px;"></div>
                    <div class="motive-color-swatch" data-color="brightGreen" style="background: var(--clr-brightGreen); width: 16px; height: 16px; border-radius: 2px; cursor: pointer; display: inline-block; margin: 2px;"></div>
                    <div class="motive-color-swatch" data-color="navyBlue" style="background: var(--clr-navyBlue); width: 16px; height: 16px; border-radius: 2px; cursor: pointer; display: inline-block; margin: 2px;"></div>
                    <div class="motive-color-swatch" data-color="plum" style="background: var(--clr-plum); width: 16px; height: 16px; border-radius: 2px; cursor: pointer; display: inline-block; margin: 2px;"></div>
                    <div class="motive-color-swatch" data-color="lavander" style="background: var(--clr-lavander); width: 16px; height: 16px; border-radius: 2px; cursor: pointer; display: inline-block; margin: 2px;"></div>
                    <div class="motive-color-swatch" data-color="yellow" style="background: var(--clr-yellow); width: 16px; height: 16px; border-radius: 2px; cursor: pointer; display: inline-block; margin: 2px;"></div>
                    <div class="motive-color-swatch selected" data-color="neonMagenta" style="background: var(--clr-neonMagenta); width: 16px; height: 16px; border-radius: 2px; cursor: pointer; display: inline-block; margin: 2px; outline: 2px solid white;"></div>
                </div>
                -->
                
                <div class="section-divider"></div>
                <div class="section-label">SVG Elements</div>
                
                <div class="control-row">
                    <button id="svgInsertBtn" class="control-btn" style="font-size: 10px;">Insert SVG</button>
                    <input type="file" id="svgFileInput" class="file-input-hidden" accept=".svg">
                </div>
                <div class="svg-element-list" id="svgElementList">
                    <!-- SVG elements will be listed here -->
                </div>
                <div class="curve-input-row">
                    <label>X</label>
                    <input type="number" id="svgPosX" class="curve-input" value="0" step="1">
                    <label>Y</label>
                    <input type="number" id="svgPosY" class="curve-input" value="0" step="1">
                </div>
                <div class="curve-input-row">
                    <label>Scale</label>
                    <input type="range" id="svgScaleSlider" min="0.1" max="5" step="0.05" value="1" style="width: 80px;">
                    <span id="svgScaleValue" style="font-size: 10px;">1.00</span>
                </div>
                <div class="curve-input-row">
                    <label>Track</label>
                    <select id="svgTrackSelect" style="font-size: 10px; padding: 2px;">
                        <option value="1">Track 1</option>
                        <option value="2">Track 2</option>
                        <option value="3">Track 3</option>
                        <option value="4">Track 4</option>
                    </select>
                </div>
                <div class="curve-input-row">
                    <label>Section</label>
                    <select id="svgSectionSelect" style="font-size: 10px; padding: 2px;">
                        <option value="top">Top</option>
                        <option value="bottom">Bottom</option>
                    </select>
                </div>
                <div class="control-row" style="margin-top: 5px;">
                    <button id="svgDeleteBtn" class="control-btn" style="font-size: 10px; background: var(--clr-darkRed);">Delete</button>
                </div>
                
            </div>
            
            <div class="menu-section">
                <div class="section-label">Connectors</div>
                <div class="control-row">
                    <button id="connectorModeBtn" class="control-btn" style="font-size: 10px;">Connect Mode: OFF</button>
                </div>
                <div class="connector-list" id="connectorList"></div>
                <div class="curve-input-row">
                    <label>Arrows</label>
                    <select id="connectorArrowSelect" style="font-size: 10px; padding: 2px;">
                        <option value="end">End →</option>
                        <option value="start">← Start</option>
                        <option value="both">← Both →</option>
                        <option value="none">None</option>
                    </select>
                </div>
                <div class="curve-input-row">
                    <label>Arrow Style</label>
                    <select id="connectorArrowStyleSelect" style="font-size: 10px; padding: 2px;">
                        <option value="triangle">Triangle</option>
                        <option value="stealth">Stealth</option>
                        <option value="diamond">Diamond</option>
                        <option value="circle">Circle</option>
                    </select>
                </div>
                <div class="curve-input-row">
                    <label>Arrow Size</label>
                    <input type="range" id="connectorArrowSizeSlider" min="3" max="12" value="6" style="width: 60px;">
                    <span id="connectorArrowSizeValue" style="font-size: 10px;">6</span>
                </div>
                <div class="curve-input-row">
                    <label>Line Color</label>
                    <select id="connectorLineColorSelect" style="font-size: 10px; padding: 2px;">
                        <option value="black">Black</option>
                        <option value="lightGrey">Grey</option>
                        <option value="white">White</option>
                        <option value="limeGreen">Lime</option>
                        <option value="neonMagenta">Magenta</option>
                        <option value="brightBlue">Blue</option>
                        <option value="brightOrange">Orange</option>
                        <option value="neonYellow">Yellow</option>
                    </select>
                </div>
                <div class="curve-input-row">
                    <label>Arrow Color</label>
                    <select id="connectorArrowColorSelect" style="font-size: 10px; padding: 2px;">
                        <option value="black">Black</option>
                        <option value="lightGrey">Grey</option>
                        <option value="white">White</option>
                        <option value="limeGreen">Lime</option>
                        <option value="neonMagenta">Magenta</option>
                        <option value="brightBlue">Blue</option>
                        <option value="brightOrange">Orange</option>
                        <option value="neonYellow">Yellow</option>
                    </select>
                </div>
                <div class="curve-input-row">
                    <label>Routing</label>
                    <select id="connectorRoutingSelect" style="font-size: 10px; padding: 2px;">
                        <option value="auto">Auto</option>
                        <option value="horizontal-first">Horizontal First</option>
                        <option value="vertical-first">Vertical First</option>
                        <option value="direct">Direct (diagonal)</option>
                    </select>
                </div>
                <div class="control-row" style="margin-top: 5px;">
                    <button id="connectorDeleteBtn" class="control-btn" style="font-size: 10px; background: var(--clr-darkRed);">Delete</button>
                </div>
            </div>
            
        </div>
        <div id="compositionPanelToggle">◀ Composition</div>
    </div>
    
    <!-- Playback-MIDI Menu (Right) -->
    <div id="cursorMenu">
        <div id="cursorMenuToggle">Playback-MIDI ▶</div>
        <div id="cursorMenuContent">
            <div class="menu-section">
                <h3>Playback</h3>
                <div class="control-row">
                    <span id="midiTimecode" class="timecode-display">00:00:00.000</span>
                </div>
                <div class="track-enable-group">
                    <label class="track-enable-label">Enable Tracks:</label>
                    <div class="track-toggles">
                        <input type="checkbox" id="midiEnableT1" checked>
                        <label for="midiEnableT1">T1</label>
                        <input type="checkbox" id="midiEnableT2" checked>
                        <label for="midiEnableT2">T2</label>
                        <input type="checkbox" id="midiEnableT3" checked>
                        <label for="midiEnableT3">T3</label>
                        <input type="checkbox" id="midiEnableT4" checked>
                        <label for="midiEnableT4">T4</label>
                    </div>
                </div>
                <div class="control-row">
                    <span id="midiEventCount" style="font-size: 11px; color: var(--clr-lightGrey);">Events: 0</span>
                </div>
                <div class="control-row" style="margin-top: 10px;">
                    <button id="goStopBtn" class="control-btn" onclick="if(window.CursorControls) CursorControls.toggleGoStop();">Play</button>
                </div>
            </div>
            <div class="menu-section">
                <h3 style="color: var(--clr-yellow);">Jump To</h3>
                <div class="control-row">
                    <label>Second</label>
                    <input type="number" id="gotoSecondInput" step="0.01" value="0">
                </div>
                <div class="control-row">
                    <button id="gotoBtn" class="control-btn" style="background: var(--clr-yellow); color: black;">Go</button>
                </div>
            </div>
            <div class="menu-section">
                <h3>Lead-In</h3>
                <div class="control-row">
                    <label>Seconds</label>
                    <input type="number" id="leadInSecondsInput" min="0" step="0.5" value="2">
                </div>
            </div>
            
            <div class="menu-section">
                <h3>MIDI Devices</h3>
                <div class="control-row">
                    <label>Input</label>
                    <select id="midiInputSelect" class="midi-select">
                        <option value="">-- Select Input --</option>
                    </select>
                </div>
                <div class="control-row">
                    <label>Output</label>
                    <select id="midiOutputSelect" class="midi-select">
                        <option value="">-- Select Output --</option>
                    </select>
                </div>
                <div class="control-row">
                    <button id="midiRefreshBtn" class="control-btn">Refresh Devices</button>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>MIDI File</h3>
                <div class="track-radio-group">
                    <input type="radio" id="midiTrackT1" name="midiTrack" value="1" checked>
                    <label for="midiTrackT1">T1</label>
                    <input type="radio" id="midiTrackT2" name="midiTrack" value="2">
                    <label for="midiTrackT2">T2</label>
                    <input type="radio" id="midiTrackT3" name="midiTrack" value="3">
                    <label for="midiTrackT3">T3</label>
                    <input type="radio" id="midiTrackT4" name="midiTrack" value="4">
                    <label for="midiTrackT4">T4</label>
                </div>
                <div class="control-row" style="margin-top: 10px;">
                    <button id="midiLoadBtn" class="control-btn">Load MIDI</button>
                    <input type="file" id="midiFileInput" class="file-input-hidden" accept=".mid,.midi">
                </div>
                <div class="control-row">
                    <span id="midiFileName" class="midi-filename">No file loaded</span>
                </div>
                <div class="control-row" style="margin-top: 10px;">
                    <button id="midiInsertBtn" class="control-btn">Insert</button>
                    <span id="midiInsertTime" class="timecode-display-small">0.000</span>
                </div>
                <div class="control-row" style="margin-top: 10px;">
                    <button id="midiDownloadBtn" class="control-btn">Download MIDI</button>
                </div>
                <div class="control-row">
                    <button id="midiExportCsvBtn" class="control-btn">Export CSV</button>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>Display</h3>
                <div class="control-row">
                    <label style="font-size: 11px;">Zoom:</label>
                    <input type="range" id="scoreZoomSlider" min="50" max="500" step="5" value="100" style="width: 80px;">
                    <span id="scoreZoomValue" style="font-size: 11px; min-width: 35px;">100%</span>
                    <button id="zoomResetBtn" style="font-size: 9px; padding: 2px 5px; margin-left: 5px;" title="Reset to 100% (Double-click slider or press 0)">100%</button>
                </div>
                <div class="display-toggles">
                    <input type="checkbox" id="showGraphicItems" checked>
                    <label for="showGraphicItems">Graphic Items</label>
                    <input type="checkbox" id="showMidiDisplay" checked>
                    <label for="showMidiDisplay">MIDI Display</label>
                </div>
                <div class="control-row" style="margin-top: 8px;">
                    <label for="ccDisplaySelect" style="font-size: 11px;">CC Display:</label>
                    <select id="ccDisplaySelect" style="font-size: 11px; padding: 2px 4px;">
                        <option value="0">CC0 - Bank Select</option>
                        <option value="1">CC1 - Modulation</option>
                        <option value="5">CC5 - Portamento Time</option>
                        <option value="7" selected>CC7 - Main Volume</option>
                        <option value="10">CC10 - Pan</option>
                        <option value="11">CC11 - Expression</option>
                        <option value="120">CC120 - All Sound Off</option>
                        <option value="123">CC123 - All Notes Off</option>
                    </select>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>Score File</h3>
                <div class="control-row">
                    <label style="font-size: 11px;">Name:</label>
                    <input type="text" id="scoreNameInput" value="untitled" style="width: 100px; font-size: 11px;">
                </div>
                <div class="control-row">
                    <button id="scoreSaveBtn" class="control-btn">Save</button>
                    <button id="scoreLoadBtn" class="control-btn">Load</button>
                </div>
                <div class="control-row">
                    <button id="scoreBroadcastLoadBtn" class="control-btn" style="font-size: 10px; background: var(--clr-plum);">Load & Sync All</button>
                </div>
                <div class="control-row">
                    <select id="scoreListSelect" style="font-size: 11px; width: 100%; padding: 2px;">
                        <option value="">-- Select Score --</option>
                    </select>
                </div>
                <div class="control-row">
                    <select id="versionListSelect" style="font-size: 11px; width: 100%; padding: 2px;">
                        <option value="">-- Versions --</option>
                    </select>
                </div>
                <div class="control-row">
                    <button id="loadVersionBtn" class="control-btn" style="font-size: 10px;">Load Version</button>
                </div>
                <div class="control-row">
                    <span id="scoreStatus" style="font-size: 10px; color: var(--clr-lightGrey);">Not saved</span>
                </div>
            </div>
        </div>
    </div>
    
    <div id="ScoreContainer">
        <div class="score-row">
            <!-- DISABLED: Static motive panels (code kept for future reference)
            <div class="static-motive-panel" data-section="top">
                <div class="static-motive-box" data-track="1">
                    <div class="static-motive-slot" data-slot="top"></div>
                    <div class="static-motive-slot" data-slot="bottom"></div>
                </div>
                <div class="static-motive-box" data-track="2">
                    <div class="static-motive-slot" data-slot="top"></div>
                    <div class="static-motive-slot" data-slot="bottom"></div>
                </div>
                <div class="static-motive-box" data-track="3">
                    <div class="static-motive-slot" data-slot="top"></div>
                    <div class="static-motive-slot" data-slot="bottom"></div>
                </div>
                <div class="static-motive-box" data-track="4">
                    <div class="static-motive-slot" data-slot="top"></div>
                    <div class="static-motive-slot" data-slot="bottom"></div>
                </div>
            </div>
            -->
            <svg id="ScoreTop"></svg>
        </div>
        <div class="score-row">
            <!-- DISABLED: Static motive panels (code kept for future reference)
            <div class="static-motive-panel" data-section="bottom">
                <div class="static-motive-box" data-track="1">
                    <div class="static-motive-slot" data-slot="top"></div>
                    <div class="static-motive-slot" data-slot="bottom"></div>
                </div>
                <div class="static-motive-box" data-track="2">
                    <div class="static-motive-slot" data-slot="top"></div>
                    <div class="static-motive-slot" data-slot="bottom"></div>
                </div>
                <div class="static-motive-box" data-track="3">
                    <div class="static-motive-slot" data-slot="top"></div>
                    <div class="static-motive-slot" data-slot="bottom"></div>
                </div>
                <div class="static-motive-box" data-track="4">
                    <div class="static-motive-slot" data-slot="top"></div>
                    <div class="static-motive-slot" data-slot="bottom"></div>
                </div>
            </div>
            -->
            <svg id="ScoreBottom"></svg>
        </div>
    </div>
    
    
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Clock Sync System
        const ClockSync = {
            socket: null,
            clockOffset: 0,           // Difference between server and client time
            roundTripTime: 0,         // Network latency (round trip)
            syncSamples: [],          // Store recent sync samples for averaging
            maxSamples: 10,           // Number of samples to average
            
            // Initialize the clock sync system
            init() {
                this.socket = io();
                
                this.socket.on('connect', () => {
                    console.log('Connected to server');
                    this.requestPing(); // Initial ping to calculate RTT
                });
                
                // Handle clock sync broadcasts from server
                this.socket.on('clockSync', (data) => {
                    const clientReceiveTime = Date.now();
                    this.updateOffset(data.serverTime, clientReceiveTime);
                });
                
                // Handle pong response for RTT calculation
                this.socket.on('pongResponse', (data) => {
                    const clientReceiveTime = Date.now();
                    this.calculateSync(data.serverTime, data.clientSendTime, clientReceiveTime);
                });
                
                // Periodically request ping for RTT updates
                setInterval(() => this.requestPing(), 5000);
            },
            
            // Request a ping to calculate round-trip time
            requestPing() {
                this.socket.emit('pingRequest', { clientSendTime: Date.now() });
            },
            
            // Calculate sync using ping/pong for accurate RTT
            calculateSync(serverTime, clientSendTime, clientReceiveTime) {
                this.roundTripTime = clientReceiveTime - clientSendTime;
                const oneWayLatency = this.roundTripTime / 2;
                
                // Server time when we received = serverTime + oneWayLatency
                const estimatedServerTimeNow = serverTime + oneWayLatency;
                const offset = estimatedServerTimeNow - clientReceiveTime;
                
                // Add to samples and keep only recent ones
                this.syncSamples.push(offset);
                if (this.syncSamples.length > this.maxSamples) {
                    this.syncSamples.shift();
                }
                
                // Average the samples for stability
                this.clockOffset = this.syncSamples.reduce((a, b) => a + b, 0) / this.syncSamples.length;
                
                console.log(`Clock sync - Offset: ${this.clockOffset.toFixed(2)}ms, RTT: ${this.roundTripTime}ms`);
            },
            
            // Simple offset update from broadcast (less accurate but frequent)
            updateOffset(serverTime, clientReceiveTime) {
                // Only use if we don't have RTT samples yet
                if (this.syncSamples.length === 0) {
                    this.clockOffset = serverTime - clientReceiveTime;
                }
            },
            
            // Get the current synchronized time (server time)
            now() {
                return Date.now() + this.clockOffset;
            },
            
            // Get the clock offset
            getOffset() {
                return this.clockOffset;
            },
            
            // Get the round-trip time
            getRTT() {
                return this.roundTripTime;
            }
        };
        
        // Initialize clock sync when page loads
        ClockSync.init();
        
        // Expose globally for use in other scripts
        window.ClockSync = ClockSync;
        
        // Score Time System - tracks score time relative to clock sync
        // Score time is independent of clock time - can be stopped/started
        const ScoreTime = {
            isPlaying: false,           // Whether score is currently playing
            currentScoreTimeMs: 0,      // Frozen score time when stopped (in ms)
            scoreTimeOffset: 0,         // When playing: scoreTime = clockTime - scoreTimeOffset
            
            // Get current score time in ms
            now() {
                if (this.isPlaying) {
                    return ClockSync.now() - this.scoreTimeOffset;
                } else {
                    return this.currentScoreTimeMs;
                }
            },
            
            // Get current score time in seconds
            nowSeconds() {
                return this.now() / 1000;
            }
        };
        window.ScoreTime = ScoreTime;
        
        // Tempo history - uses score time, not clock time
        let serverTempoHistory = [{ scoreTimeMs: 0, bpm: 60, beatsPerPage: 8 }];
        
        // Animation Engine - Frame rate engine synced to ClockSync timecode
        const AnimationEngine = {
            FRAMERATE: 60,
            MS_PER_FRAME: 1000 / 60,
            
            running: false,
            startTime: 0,              // Synchronized start time (server time)
            currentFrame: 0,           // Current frame number based on sync time
            lastProcessedFrame: -1,    // Last frame that was processed
            
            // Callbacks
            onUpdate: null,            // Called each frame with (frameNumber, deltaTime)
            onDraw: null,              // Called each frame for rendering
            
            // Start the animation engine at a specific server time
            start(serverStartTime = null) {
                this.startTime = serverStartTime || ClockSync.now();
                this.running = true;
                this.lastProcessedFrame = -1;
                console.log(`Animation started at server time: ${this.startTime}`);
                requestAnimationFrame((timestamp) => this.loop(timestamp));
            },
            
            // Stop the animation engine
            stop() {
                this.running = false;
                console.log('Animation stopped');
            },
            
            // Main animation loop
            loop(timestamp) {
                if (!this.running) return;
                
                // Calculate current frame based on synchronized time
                const syncedTime = ClockSync.now();
                const elapsedMs = syncedTime - this.startTime;
                
                // Calculate which frame we should be on based on elapsed synced time
                this.currentFrame = Math.floor(elapsedMs / this.MS_PER_FRAME);
                
                // Only process if we're on a new frame
                if (this.currentFrame > this.lastProcessedFrame) {
                    // Handle frame skip - process missed frames if needed
                    const framesToProcess = this.currentFrame - this.lastProcessedFrame;
                    
                    if (framesToProcess > 1) {
                        console.log(`Skipped ${framesToProcess - 1} frames`);
                    }
                    
                    // Calculate delta time
                    const deltaTime = this.MS_PER_FRAME;
                    
                    // Call update callback
                    if (this.onUpdate) {
                        this.onUpdate(this.currentFrame, deltaTime, elapsedMs);
                    }
                    
                    // Call draw callback
                    if (this.onDraw) {
                        this.onDraw(this.currentFrame, elapsedMs);
                    }
                    
                    this.lastProcessedFrame = this.currentFrame;
                }
                
                // Continue the loop
                requestAnimationFrame((timestamp) => this.loop(timestamp));
            },
            
            // Get current frame number
            getFrame() {
                return this.currentFrame;
            },
            
            // Get elapsed time in ms since start
            getElapsedTime() {
                return ClockSync.now() - this.startTime;
            },
            
            // Get elapsed time in seconds
            getElapsedSeconds() {
                return this.getElapsedTime() / 1000;
            },
            
            // Set the start time (for syncing multiple clients to same timeline)
            setStartTime(serverStartTime) {
                this.startTime = serverStartTime;
            },
            
            // Set frame rate
            setFrameRate(fps) {
                this.FRAMERATE = fps;
                this.MS_PER_FRAME = 1000 / fps;
            }
        };
        
        // Expose globally
        window.AnimationEngine = AnimationEngine;
        
        // Tempo variables - fixed at 16 beats per page and 60 BPM
        let beatsPerPage = 8;
        let beatsPerMinute = 60;
        
        // Lead-in time - negative time before score starts at 0
        let leadInSeconds = 2;
        
        // Cursor Control Menu functionality (Right side)
        const CursorControls = {
            menuEl: null,
            toggleEl: null,
            goStopBtn: null,
            gotoSecondInput: null,
            gotoBtn: null,
            leadInSecondsInput: null,
            isOpen: false,
            
            init() {
                this.menuEl = document.getElementById('cursorMenu');
                this.toggleEl = document.getElementById('cursorMenuToggle');
                this.goStopBtn = document.getElementById('goStopBtn');
                this.gotoSecondInput = document.getElementById('gotoSecondInput');
                this.gotoBtn = document.getElementById('gotoBtn');
                this.leadInSecondsInput = document.getElementById('leadInSecondsInput');
                
                // Toggle menu open/close
                this.toggleEl.addEventListener('click', () => this.toggle());
                
                // Lead-in seconds input
                this.leadInSecondsInput.addEventListener('change', (e) => {
                    leadInSeconds = parseFloat(e.target.value) || 0;
                    // Update min values for jump inputs to allow negative lead-in time
                    this.updateJumpInputLimits();
                    // Re-render graphic timeline with new lead-in
                    if (window.GraphicTimeline) GraphicTimeline.renderTicks();
                    // Update staff headers position
                    if (window.StaffCursors) StaffCursors.updateStaffHeaders();
                    // Recalculate curve positions with new lead-in
                    if (window.CurveMaker) CurveMaker.reloadFromDatabase();
                    // Recalculate motive positions with new lead-in
                    if (window.MotiveMaker) MotiveMaker.reloadFromDatabase();
                    // Recalculate notation positions with new lead-in
                    if (window.NotationManager) NotationManager.reloadPlacedNotations();
                    // Re-render MIDI display with new lead-in
                    if (window.MidiController) MidiController.renderAllMidiDisplays();
                    // Recalculate SVG element positions with new lead-in (time-based positioning)
                    if (window.SVGElementManager) SVGElementManager.reRenderAllElements();
                    // Update connectors AFTER all objects have moved
                    if (window.FlowchartConnector) FlowchartConnector.updateAllConnectors();
                });
                
                // Set initial min values based on default lead-in
                this.updateJumpInputLimits();
                
                // Go/Stop toggle button
                this.goStopBtn.addEventListener('click', () => this.toggleGoStop());
                
                // Go to button - stops, jumps, stays stopped
                this.gotoBtn.addEventListener('click', () => this.gotoPosition());
                
                // Enter key on second input triggers goto
                this.gotoSecondInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.gotoPosition();
                });
                
                // Listen for score control events from server
                ClockSync.socket.on('scoreGo', (data) => {
                    this.onScoreGo(data);
                });
                
                ClockSync.socket.on('scoreStop', (data) => {
                    this.onScoreStop(data);
                });
                
                ClockSync.socket.on('scoreGoto', (data) => {
                    this.onScoreGoto(data);
                });
            },
            
            // Convert seconds to beats using current BPM
            secondsToBeats(seconds) {
                return seconds * (beatsPerMinute / 60);
            },
            
            // Convert beats to seconds using current BPM
            beatsToSeconds(beats) {
                return beats * (60 / beatsPerMinute);
            },
            
            // Update min value for jump input based on lead-in time
            updateJumpInputLimits() {
                const minSeconds = -leadInSeconds;
                this.gotoSecondInput.setAttribute('min', minSeconds);
            },
            
            toggle() {
                this.isOpen = !this.isOpen;
                this.menuEl.classList.toggle('open', this.isOpen);
                this.toggleEl.textContent = this.isOpen ? '◀ Playback-MIDI' : 'Playback-MIDI ▶';
            },
            
            toggleGoStop() {
                if (ScoreTime.isPlaying) {
                    ClockSync.socket.emit('scoreStop');
                } else {
                    ClockSync.socket.emit('scoreGo');
                }
            },
            
            gotoPosition() {
                // Use the seconds value (which is kept in sync with beats)
                // Add leadInSeconds offset so input 0 jumps to tick mark 0
                const displaySeconds = parseFloat(this.gotoSecondInput.value) || 0;
                const actualSeconds = displaySeconds + leadInSeconds;
                ClockSync.socket.emit('scoreGoto', { seconds: actualSeconds });
            },
            
            onScoreGo(data) {
                ScoreTime.isPlaying = true;
                ScoreTime.scoreTimeOffset = data.scoreTimeOffset;
                ScoreTime.currentScoreTimeMs = data.currentScoreTimeMs;
                this.goStopBtn.textContent = 'Stop';
                this.goStopBtn.classList.add('active');
                console.log(`Score GO - playing from ${data.currentScoreTimeMs}ms`);
                
                // Debug: Check curve state
                if (window.CurveMaker) {
                    console.log(`[onScoreGo] CurveMaker.curves.length=${CurveMaker.curves.length}`);
                    CurveMaker.curves.forEach((c, i) => {
                        console.log(`[onScoreGo] Curve ${i}: ${c.name}, group in DOM: ${c.elements?.group?.parentNode ? 'yes' : 'no'}, display: ${c.elements?.group?.style?.display}`);
                    });
                }
            },
            
            onScoreStop(data) {
                ScoreTime.isPlaying = false;
                ScoreTime.currentScoreTimeMs = data.currentScoreTimeMs;
                this.goStopBtn.textContent = 'Play';
                this.goStopBtn.classList.remove('active');
                console.log(`Score STOP - frozen at ${data.currentScoreTimeMs}ms`);
            },
            
            onScoreGoto(data) {
                ScoreTime.isPlaying = false;
                ScoreTime.currentScoreTimeMs = data.currentScoreTimeMs;
                serverTempoHistory = data.tempoHistory;
                this.goStopBtn.textContent = 'Play';
                this.goStopBtn.classList.remove('active');
                // Update input to reflect the new position (convert from actual to display time)
                const displaySeconds = data.targetSeconds - leadInSeconds;
                this.gotoSecondInput.value = displaySeconds.toFixed(2);
                // Update graphic timeline for new position
                if (window.GraphicTimeline) {
                    GraphicTimeline.onGoto(data.targetSeconds);
                }
                // Update track system for new position
                if (window.TrackSystem) {
                    TrackSystem.onGoto(data.targetSeconds);
                }
                // Reset MIDI playback indices to match new position
                if (window.MidiController) {
                    MidiController.resetPlaybackToTime(displaySeconds * 1000);
                }
                console.log(`Score GOTO ${data.targetSeconds}s (display: ${displaySeconds}s) - frozen at ${data.currentScoreTimeMs}ms`);
            }
        };
        
        // Initialize cursor controls after DOM is ready
        CursorControls.init();
        window.CursorControls = CursorControls;
        
        // SVG Element Manager - Insert, resize, move SVG elements on the score
        const SVGElementManager = {
            elements: [],      // Array of inserted SVG elements
            selectedElement: null,
            nextId: 1,
            isDragging: false,
            isResizing: false,
            resizeCorner: null,
            dragStartX: 0,
            dragStartY: 0,
            elementStartX: 0,
            elementStartY: 0,
            elementStartScale: 1,
            resizeHandles: [],
            
            init() {
                // UI elements
                this.insertBtn = document.getElementById('svgInsertBtn');
                this.fileInput = document.getElementById('svgFileInput');
                this.elementList = document.getElementById('svgElementList');
                this.posXInput = document.getElementById('svgPosX');
                this.posYInput = document.getElementById('svgPosY');
                this.scaleSlider = document.getElementById('svgScaleSlider');
                this.scaleValue = document.getElementById('svgScaleValue');
                this.trackSelect = document.getElementById('svgTrackSelect');
                this.sectionSelect = document.getElementById('svgSectionSelect');
                this.deleteBtn = document.getElementById('svgDeleteBtn');
                
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Create container groups for SVG elements (one for each score section)
                this.containerTop = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.containerTop.setAttribute('id', 'svg-elements-container-top');
                this.scoreTopEl.appendChild(this.containerTop);
                
                this.containerBottom = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.containerBottom.setAttribute('id', 'svg-elements-container-bottom');
                this.scoreBottomEl.appendChild(this.containerBottom);
                
                // Event listeners
                this.insertBtn.addEventListener('click', () => this.fileInput.click());
                this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                this.deleteBtn.addEventListener('click', () => this.deleteSelected());
                
                this.posXInput.addEventListener('change', () => this.updateSelectedPosition());
                this.posYInput.addEventListener('change', () => this.updateSelectedPosition());
                this.scaleSlider.addEventListener('input', () => this.updateSelectedScale());
                this.trackSelect.addEventListener('change', () => this.updateSelectedTrack());
                this.sectionSelect.addEventListener('change', () => this.updateSelectedSection());
                
                // Click on score to deselect
                this.scoreTopEl.addEventListener('click', (e) => {
                    if (e.target === this.scoreTopEl || e.target.tagName === 'svg') {
                        this.deselectAll();
                    }
                });
                this.scoreBottomEl.addEventListener('click', (e) => {
                    if (e.target === this.scoreBottomEl || e.target.tagName === 'svg') {
                        this.deselectAll();
                    }
                });
                
                // Global mouse events for drag/resize
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                // Re-render SVG elements on window resize (debounced)
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.reRenderAllElements();
                    }, 100);
                });
                
                console.log('SVGElementManager initialized');
            },
            
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    this.insertSVG(event.target.result, file.name);
                };
                reader.readAsText(file);
                e.target.value = ''; // Reset input
            },
            
            insertSVG(svgContent, filename) {
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
                const svgEl = svgDoc.documentElement;
                
                // Get original dimensions
                let width = parseFloat(svgEl.getAttribute('width')) || 100;
                let height = parseFloat(svgEl.getAttribute('height')) || 100;
                
                // Handle mm units
                const widthStr = svgEl.getAttribute('width') || '';
                const heightStr = svgEl.getAttribute('height') || '';
                if (widthStr.includes('mm')) width = parseFloat(widthStr) * 3.78;
                if (heightStr.includes('mm')) height = parseFloat(heightStr) * 3.78;
                
                // Get viewBox if present
                const viewBox = svgEl.getAttribute('viewBox');
                
                // Create wrapper group
                const wrapper = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                const id = this.nextId++;
                wrapper.setAttribute('id', `svg-element-${id}`);
                wrapper.setAttribute('class', 'svg-element-wrapper');
                
                // Create the image element
                const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                
                // Convert SVG to data URL, replacing currentColor with black
                let svgString = new XMLSerializer().serializeToString(svgEl);
                svgString = svgString.replace(/currentColor/g, '#000000');
                const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString)));
                
                image.setAttribute('href', dataUrl);
                image.setAttribute('width', width);
                image.setAttribute('height', height);
                
                wrapper.appendChild(image);
                
                // Calculate initial position (center of current track)
                const track = parseInt(this.trackSelect.value) || 1;
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                const timelineHeight = 16;
                const availableHeight = scoreHeight - timelineHeight;
                const staffHeight = availableHeight / 4;
                const trackY = timelineHeight + ((track - 1) * staffHeight) + (staffHeight / 2) - (height / 2);
                const trackX = scoreWidth * 0.2; // Start at 20% from left
                
                // Get section from selector and determine page
                const section = this.sectionSelect?.value || 'top';
                const currentPage = window.GraphicTimeline 
                    ? (section === 'top' ? GraphicTimeline.currentTopPage : GraphicTimeline.currentBottomPage)
                    : (section === 'top' ? 0 : 1);
                
                // Calculate time-based position (startSeconds)
                const secondsPerPage = window.GraphicTimeline ? GraphicTimeline.getSecondsPerPage() : 8;
                const xPercent = (trackX / scoreWidth) * 100;
                // Convert page + xPercent to startSeconds (display time, where 0 = first beat)
                const startSeconds = (currentPage * secondsPerPage) + (xPercent / 100 * secondsPerPage) - leadInSeconds;
                
                // Calculate Y as percentage of track height (0 = top of track, 100 = bottom)
                const yPercent = (trackY / scoreHeight) * 100;
                
                // Store element data
                const elementData = {
                    id: id,
                    name: filename.replace('.svg', ''),
                    wrapper: wrapper,
                    image: image,
                    x: trackX,
                    y: trackY,
                    startSeconds: startSeconds,  // Time-based X position
                    yPercent: yPercent,          // Y as percentage of score height
                    xPercent: xPercent,          // Keep for backward compatibility
                    width: width,
                    height: height,
                    scale: 1,
                    baseScale: 1,
                    baseScoreWidth: scoreWidth,
                    track: track,
                    page: currentPage,
                    section: section
                };
                
                this.elements.push(elementData);
                
                // Apply initial transform
                this.updateElementTransform(elementData);
                
                // Add to correct container based on section
                const targetContainer = section === 'top' ? this.containerTop : this.containerBottom;
                targetContainer.appendChild(wrapper);
                
                // Add drag handlers
                wrapper.addEventListener('mousedown', (e) => this.handleElementMouseDown(e, elementData));
                
                // Update list and select
                this.updateElementList();
                this.selectElement(elementData);
            },
            
            updateElementTransform(el) {
                const scaledWidth = el.width * el.scale;
                const scaledHeight = el.height * el.scale;
                el.wrapper.setAttribute('transform', `translate(${el.x}, ${el.y}) scale(${el.scale})`);
                el.image.setAttribute('width', el.width);
                el.image.setAttribute('height', el.height);
                
                // Update resize handles if this is the selected element
                if (el === this.selectedElement) {
                    this.updateResizeHandles();
                }
            },
            
            createResizeHandles() {
                // Remove existing handles
                this.removeResizeHandles();
                
                if (!this.selectedElement) return;
                
                const handleSize = 8;
                const corners = ['se']; // Just SE corner for proportional resize
                
                // Use correct container based on element's section
                const targetContainer = this.selectedElement.section === 'bottom' 
                    ? this.containerBottom 
                    : this.containerTop;
                
                corners.forEach(corner => {
                    const handle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    handle.setAttribute('width', handleSize);
                    handle.setAttribute('height', handleSize);
                    handle.setAttribute('class', `svg-resize-handle corner-${corner}`);
                    handle.setAttribute('data-corner', corner);
                    handle.style.cursor = 'nwse-resize';
                    
                    handle.addEventListener('mousedown', (e) => this.handleResizeMouseDown(e, corner));
                    
                    targetContainer.appendChild(handle);
                    this.resizeHandles.push(handle);
                });
                
                this.updateResizeHandles();
            },
            
            updateResizeHandles() {
                if (!this.selectedElement || this.resizeHandles.length === 0) return;
                
                const el = this.selectedElement;
                const scaledWidth = el.width * el.scale;
                const scaledHeight = el.height * el.scale;
                const handleSize = 8;
                
                this.resizeHandles.forEach(handle => {
                    const corner = handle.getAttribute('data-corner');
                    let hx, hy;
                    
                    if (corner === 'se') {
                        hx = el.x + scaledWidth - handleSize / 2;
                        hy = el.y + scaledHeight - handleSize / 2;
                    }
                    
                    handle.setAttribute('x', hx);
                    handle.setAttribute('y', hy);
                });
            },
            
            removeResizeHandles() {
                this.resizeHandles.forEach(handle => handle.remove());
                this.resizeHandles = [];
            },
            
            handleResizeMouseDown(e, corner) {
                e.stopPropagation();
                e.preventDefault();
                
                this.isResizing = true;
                this.resizeCorner = corner;
                this.dragStartX = e.clientX;
                this.dragStartY = e.clientY;
                this.elementStartScale = this.selectedElement.scale;
                this.elementStartX = this.selectedElement.x;
                this.elementStartY = this.selectedElement.y;
            },
            
            handleElementMouseDown(e, elementData) {
                // Don't start dragging if clicking on a flowchart node
                if (e.target.classList.contains('flowchart-node')) {
                    return;
                }
                
                e.stopPropagation();
                this.selectElement(elementData);
                
                // Start dragging
                this.isDragging = true;
                this.dragStartX = e.clientX;
                this.dragStartY = e.clientY;
                this.elementStartX = elementData.x;
                this.elementStartY = elementData.y;
            },
            
            handleMouseMove(e) {
                // Get zoom scale factor
                const zoomScale = window.ScoreZoom ? ScoreZoom.getZoom() : 1;
                
                if (this.isResizing && this.selectedElement) {
                    const dx = (e.clientX - this.dragStartX) / zoomScale;
                    const dy = (e.clientY - this.dragStartY) / zoomScale;
                    
                    // Use diagonal distance for proportional scaling
                    const diagonal = (dx + dy) / 2;
                    const baseSize = this.selectedElement.width * this.elementStartScale;
                    const scaleFactor = (baseSize + diagonal) / baseSize;
                    
                    const newScale = Math.max(0.1, Math.min(5, this.elementStartScale * scaleFactor));
                    this.selectedElement.scale = newScale;
                    
                    // Update baseScale and baseScoreWidth for resize handling
                    const scoreWidth = this.scoreTopEl?.clientWidth || 1;
                    this.selectedElement.baseScale = newScale;
                    this.selectedElement.baseScoreWidth = scoreWidth;
                    
                    this.updateElementTransform(this.selectedElement);
                    this.updateUIFromSelected();
                    // Update connectors when element is resized
                    if (window.FlowchartConnector) FlowchartConnector.updateAllConnectors();
                    return;
                }
                
                if (!this.isDragging || !this.selectedElement) return;
                
                const dx = (e.clientX - this.dragStartX) / zoomScale;
                const dy = (e.clientY - this.dragStartY) / zoomScale;
                
                this.selectedElement.x = this.elementStartX + dx;
                this.selectedElement.y = this.elementStartY + dy;
                
                // Update percentage positions for resize handling
                const scoreWidth = this.scoreTopEl?.clientWidth || 1;
                const scoreHeight = this.scoreTopEl?.clientHeight || 1;
                this.selectedElement.xPercent = (this.selectedElement.x / scoreWidth) * 100;
                this.selectedElement.yPercent = (this.selectedElement.y / scoreHeight) * 100;
                
                // Update time-based startSeconds from new X position
                const secondsPerPage = window.GraphicTimeline ? GraphicTimeline.getSecondsPerPage() : 8;
                const currentPage = this.selectedElement.page || 0;
                this.selectedElement.startSeconds = (currentPage * secondsPerPage) + (this.selectedElement.xPercent / 100 * secondsPerPage) - leadInSeconds;
                
                this.updateElementTransform(this.selectedElement);
                this.updateUIFromSelected();
                // Update connectors when element is moved
                if (window.FlowchartConnector) FlowchartConnector.updateAllConnectors();
            },
            
            handleMouseUp(e) {
                this.isDragging = false;
                this.isResizing = false;
                this.resizeCorner = null;
            },
            
            selectElement(elementData) {
                this.deselectAll();
                this.selectedElement = elementData;
                elementData.wrapper.classList.add('selected');
                
                // Create resize handles
                this.createResizeHandles();
                
                // Update UI
                this.updateUIFromSelected();
                this.updateElementList();
            },
            
            deselectAll() {
                if (this.selectedElement) {
                    this.selectedElement.wrapper.classList.remove('selected');
                }
                this.selectedElement = null;
                this.removeResizeHandles();
                this.updateElementList();
            },
            
            updateUIFromSelected() {
                if (!this.selectedElement) return;
                this.posXInput.value = Math.round(this.selectedElement.x);
                this.posYInput.value = Math.round(this.selectedElement.y);
                this.scaleSlider.value = this.selectedElement.scale;
                this.scaleValue.textContent = this.selectedElement.scale.toFixed(2);
                this.trackSelect.value = this.selectedElement.track;
                this.sectionSelect.value = this.selectedElement.section || 'top';
            },
            
            updateSelectedPosition() {
                if (!this.selectedElement) return;
                this.selectedElement.x = parseFloat(this.posXInput.value) || 0;
                this.selectedElement.y = parseFloat(this.posYInput.value) || 0;
                this.updateElementTransform(this.selectedElement);
            },
            
            updateSelectedScale() {
                if (!this.selectedElement) return;
                this.selectedElement.scale = parseFloat(this.scaleSlider.value) || 1;
                this.scaleValue.textContent = this.selectedElement.scale.toFixed(2);
                this.updateElementTransform(this.selectedElement);
            },
            
            updateSelectedTrack() {
                if (!this.selectedElement) return;
                const track = parseInt(this.trackSelect.value) || 1;
                this.selectedElement.track = track;
                
                // Reposition Y to center in new track
                const scoreHeight = this.scoreTopEl.clientHeight;
                const timelineHeight = 16;
                const availableHeight = scoreHeight - timelineHeight;
                const staffHeight = availableHeight / 4;
                const scaledHeight = this.selectedElement.height * this.selectedElement.scale;
                this.selectedElement.y = timelineHeight + ((track - 1) * staffHeight) + (staffHeight / 2) - (scaledHeight / 2);
                
                this.updateElementTransform(this.selectedElement);
                this.updateUIFromSelected();
            },
            
            updateSelectedSection() {
                if (!this.selectedElement) return;
                const section = this.sectionSelect.value;
                this.selectedElement.section = section;
                
                // Update page to match the current page of the new section
                if (window.GraphicTimeline) {
                    this.selectedElement.page = section === 'top' 
                        ? GraphicTimeline.currentTopPage 
                        : GraphicTimeline.currentBottomPage;
                }
                
                // Move to correct container
                const targetContainer = section === 'top' ? this.containerTop : this.containerBottom;
                targetContainer.appendChild(this.selectedElement.wrapper);
                
                this.updateVisibility();
            },
            
            deleteSelected() {
                if (!this.selectedElement) return;
                
                // Remove from DOM
                this.selectedElement.wrapper.remove();
                
                // Remove from array
                const idx = this.elements.indexOf(this.selectedElement);
                if (idx > -1) this.elements.splice(idx, 1);
                
                this.selectedElement = null;
                this.updateElementList();
            },
            
            updateElementList() {
                this.elementList.innerHTML = '';
                this.elements.forEach(el => {
                    const item = document.createElement('div');
                    item.className = 'svg-element-item' + (el === this.selectedElement ? ' selected' : '');
                    item.textContent = el.name;
                    item.addEventListener('click', () => this.selectElement(el));
                    this.elementList.appendChild(item);
                });
            },
            
            // Determine track based on Y position
            getTrackFromY(y) {
                const scoreHeight = this.scoreTopEl.clientHeight;
                const timelineHeight = 16;
                const availableHeight = scoreHeight - timelineHeight;
                const staffHeight = availableHeight / 4;
                
                const relativeY = y - timelineHeight;
                const track = Math.floor(relativeY / staffHeight) + 1;
                return Math.max(1, Math.min(4, track));
            },
            
            // Bring SVG containers to front (call after other elements are initialized)
            bringToFront() {
                if (this.containerTop && this.scoreTopEl) {
                    this.scoreTopEl.appendChild(this.containerTop);
                }
                if (this.containerBottom && this.scoreBottomEl) {
                    this.scoreBottomEl.appendChild(this.containerBottom);
                }
            },
            
            // Show/hide elements based on current page and move to correct container
            updateVisibility() {
                if (!window.GraphicTimeline) return;
                
                const topPage = GraphicTimeline.currentTopPage;
                const bottomPage = GraphicTimeline.currentBottomPage;
                
                this.elements.forEach(el => {
                    let visible = false;
                    let targetContainer = null;
                    
                    if (el.section === 'top') {
                        visible = el.page === topPage;
                        targetContainer = this.containerTop;
                    } else {
                        visible = el.page === bottomPage;
                        targetContainer = this.containerBottom;
                    }
                    
                    // Move to correct container if needed
                    if (el.wrapper.parentNode !== targetContainer) {
                        targetContainer.appendChild(el.wrapper);
                    }
                    
                    el.wrapper.style.display = visible ? '' : 'none';
                });
            },
            
            // Export data for saving
            exportData() {
                const scoreWidth = this.scoreTopEl?.clientWidth || 1;
                const scoreHeight = this.scoreTopEl?.clientHeight || 1;
                
                return this.elements.map(el => ({
                    id: el.id,
                    name: el.name,
                    x: el.x,
                    y: el.y,
                    startSeconds: el.startSeconds,  // Time-based X position
                    xPercent: el.xPercent || (el.x / scoreWidth) * 100,
                    yPercent: el.yPercent || (el.y / scoreHeight) * 100,
                    width: el.width,
                    height: el.height,
                    scale: el.scale,
                    baseScale: el.baseScale || el.scale,
                    baseScoreWidth: el.baseScoreWidth || scoreWidth,
                    track: this.getTrackFromY(el.y),
                    page: el.page || 0,
                    section: el.section || 'top',
                    svgDataUrl: el.image.getAttribute('href')
                }));
            },
            
            // Import data from saved score
            importData(data) {
                if (!data || !Array.isArray(data)) return;
                
                // Clear existing elements
                this.elements.forEach(el => el.wrapper.remove());
                this.elements = [];
                this.removeResizeHandles();
                this.selectedElement = null;
                
                const scoreWidth = this.scoreTopEl?.clientWidth || 1;
                const scoreHeight = this.scoreTopEl?.clientHeight || 1;
                const secondsPerPage = window.GraphicTimeline ? GraphicTimeline.getSecondsPerPage() : 8;
                
                // Recreate elements
                data.forEach(elData => {
                    const wrapper = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    wrapper.setAttribute('id', `svg-element-${elData.id}`);
                    wrapper.setAttribute('class', 'svg-element-wrapper');
                    
                    const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    image.setAttribute('href', elData.svgDataUrl);
                    image.setAttribute('width', elData.width);
                    image.setAttribute('height', elData.height);
                    
                    wrapper.appendChild(image);
                    
                    // Determine startSeconds - use saved value or convert from old format
                    let startSeconds;
                    if (elData.startSeconds !== undefined) {
                        // New format: use saved startSeconds
                        startSeconds = elData.startSeconds;
                    } else {
                        // Old format: convert from page + xPercent to startSeconds
                        const oldPage = elData.page || 0;
                        const oldXPercent = elData.xPercent || 0;
                        startSeconds = (oldPage * secondsPerPage) + (oldXPercent / 100 * secondsPerPage) - leadInSeconds;
                        console.debug(`SVGElementManager: Converted old format element ${elData.id} to startSeconds=${startSeconds}`);
                    }
                    
                    // Calculate page and section from startSeconds
                    const startActual = startSeconds + leadInSeconds;
                    const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                    const section = startPage % 2 === 0 ? 'top' : 'bottom';
                    
                    // Calculate X position from startSeconds
                    const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                    const x = (startXPercent / 100) * scoreWidth;
                    
                    // Calculate Y position from yPercent
                    const y = elData.yPercent !== undefined ? (elData.yPercent / 100) * scoreHeight : elData.y;
                    
                    const elementData = {
                        id: elData.id,
                        name: elData.name,
                        wrapper: wrapper,
                        image: image,
                        x: x,
                        y: y,
                        startSeconds: startSeconds,  // Time-based X position
                        xPercent: startXPercent,     // Calculated from startSeconds
                        yPercent: elData.yPercent || (elData.y / scoreHeight) * 100,
                        width: elData.width,
                        height: elData.height,
                        scale: elData.scale,
                        baseScale: elData.baseScale || elData.scale,
                        baseScoreWidth: elData.baseScoreWidth || scoreWidth,
                        track: elData.track,
                        page: startPage,
                        section: section
                    };
                    
                    this.elements.push(elementData);
                    this.updateElementTransform(elementData);
                    
                    // Add to correct container based on section
                    const targetContainer = section === 'top' ? this.containerTop : this.containerBottom;
                    targetContainer.appendChild(wrapper);
                    
                    // Add drag handlers
                    wrapper.addEventListener('mousedown', (e) => this.handleElementMouseDown(e, elementData));
                    
                    // Update nextId
                    if (elData.id >= this.nextId) {
                        this.nextId = elData.id + 1;
                    }
                });
                
                this.updateElementList();
                this.updateVisibility();
                console.debug(`SVGElementManager: Imported ${this.elements.length} elements`);
            },
            
            // Re-render all elements on window resize or lead-in change
            reRenderAllElements() {
                const scoreWidth = this.scoreTopEl?.clientWidth || 1;
                const scoreHeight = this.scoreTopEl?.clientHeight || 1;
                const secondsPerPage = window.GraphicTimeline ? GraphicTimeline.getSecondsPerPage() : 8;
                
                this.elements.forEach(el => {
                    // Recalculate positions from time-based startSeconds
                    if (el.startSeconds !== undefined) {
                        // Calculate page and section from startSeconds
                        const startActual = el.startSeconds + leadInSeconds;
                        const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                        const section = startPage % 2 === 0 ? 'top' : 'bottom';
                        
                        // Calculate X position from startSeconds
                        const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                        el.x = (startXPercent / 100) * scoreWidth;
                        el.xPercent = startXPercent;
                        el.page = startPage;
                        el.section = section;
                        
                        // Move to correct container if section changed
                        const targetContainer = section === 'top' ? this.containerTop : this.containerBottom;
                        if (el.wrapper.parentNode !== targetContainer) {
                            targetContainer.appendChild(el.wrapper);
                        }
                    } else if (el.xPercent !== undefined) {
                        // Fallback for old percentage-based elements
                        el.x = (el.xPercent / 100) * scoreWidth;
                    }
                    
                    // Y position from yPercent
                    if (el.yPercent !== undefined) {
                        el.y = (el.yPercent / 100) * scoreHeight;
                    }
                    
                    // Scale proportionally based on original score width
                    if (el.baseScoreWidth) {
                        const sizeRatio = scoreWidth / el.baseScoreWidth;
                        el.scale = el.baseScale * sizeRatio;
                    }
                    
                    this.updateElementTransform(el);
                });
                
                // Update visibility based on current page
                this.updateVisibility();
                
                // Update resize handles if element is selected
                if (this.selectedElement) {
                    this.updateResizeHandles();
                }
            }
        };
        
        // Flowchart Connector System - Right-angle connectors between objects
        const FlowchartConnector = {
            connectors: [],
            selectedConnector: null,
            nextId: 1,
            connectMode: false,
            isDrawing: false,
            drawStartPoint: null,
            drawStartElement: null,
            drawStartObjectType: null,
            tempLine: null,
            
            colorMap: {
                black: '#000',
                lightGrey: '#aaa',
                white: '#fff',
                limeGreen: 'rgb(153,255,0)',
                neonMagenta: 'rgb(255,21,160)',
                brightBlue: 'rgba(56,126,211,255)',
                brightOrange: 'rgba(240,75,0,255)',
                neonYellow: 'rgb(255,255,0)'
            },
            
            arrowShapes: {
                triangle: { end: 'M 0 0 L 10 5 L 0 10 z', start: 'M 10 0 L 0 5 L 10 10 z' },
                stealth: { end: 'M 0 0 L 10 5 L 0 10 L 3 5 z', start: 'M 10 0 L 0 5 L 10 10 L 7 5 z' },
                diamond: { end: 'M 0 5 L 5 0 L 10 5 L 5 10 z', start: 'M 0 5 L 5 0 L 10 5 L 5 10 z' },
                circle: { end: 'M 5 0 A 5 5 0 1 1 5 10 A 5 5 0 1 1 5 0', start: 'M 5 0 A 5 5 0 1 1 5 10 A 5 5 0 1 1 5 0' }
            },
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                this.modeBtn = document.getElementById('connectorModeBtn');
                this.connectorList = document.getElementById('connectorList');
                this.arrowSelect = document.getElementById('connectorArrowSelect');
                this.arrowStyleSelect = document.getElementById('connectorArrowStyleSelect');
                this.arrowSizeSlider = document.getElementById('connectorArrowSizeSlider');
                this.arrowSizeValue = document.getElementById('connectorArrowSizeValue');
                this.lineColorSelect = document.getElementById('connectorLineColorSelect');
                this.arrowColorSelect = document.getElementById('connectorArrowColorSelect');
                this.routingSelect = document.getElementById('connectorRoutingSelect');
                this.deleteBtn = document.getElementById('connectorDeleteBtn');
                
                // Create connector groups in SVG
                this.topConnectorGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.topConnectorGroup.setAttribute('id', 'topConnectorGroup');
                this.scoreTopEl.appendChild(this.topConnectorGroup);
                
                this.bottomConnectorGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.bottomConnectorGroup.setAttribute('id', 'bottomConnectorGroup');
                this.scoreBottomEl.appendChild(this.bottomConnectorGroup);
                
                // Create arrow markers
                this.createArrowMarkers();
                
                // Event listeners
                if (this.modeBtn) {
                    this.modeBtn.addEventListener('click', () => this.toggleConnectMode());
                }
                if (this.deleteBtn) {
                    this.deleteBtn.addEventListener('click', () => this.deleteSelected());
                }
                if (this.arrowSelect) {
                    this.arrowSelect.addEventListener('change', () => this.updateSelectedProperty('arrowType', this.arrowSelect.value));
                }
                if (this.arrowStyleSelect) {
                    this.arrowStyleSelect.addEventListener('change', () => this.updateSelectedProperty('arrowStyle', this.arrowStyleSelect.value));
                }
                if (this.arrowSizeSlider) {
                    this.arrowSizeSlider.addEventListener('input', () => {
                        this.arrowSizeValue.textContent = this.arrowSizeSlider.value;
                        this.updateSelectedProperty('arrowSize', parseInt(this.arrowSizeSlider.value));
                    });
                }
                if (this.lineColorSelect) {
                    this.lineColorSelect.addEventListener('change', () => this.updateSelectedProperty('lineColor', this.lineColorSelect.value));
                }
                if (this.arrowColorSelect) {
                    this.arrowColorSelect.addEventListener('change', () => this.updateSelectedProperty('arrowColor', this.arrowColorSelect.value));
                }
                if (this.routingSelect) {
                    this.routingSelect.addEventListener('change', () => this.updateSelectedProperty('routing', this.routingSelect.value));
                }
                
                // Mouse events for drawing
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                // Click on SVG background to deselect connectors
                this.scoreTopEl.addEventListener('click', (e) => {
                    if (e.target === this.scoreTopEl || e.target.tagName === 'svg') {
                        this.deselectAll();
                    }
                });
                this.scoreBottomEl.addEventListener('click', (e) => {
                    if (e.target === this.scoreBottomEl || e.target.tagName === 'svg') {
                        this.deselectAll();
                    }
                });
                
                // Re-render connectors on window resize (debounced, after other elements update)
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.updateAllConnectors();
                    }, 150);  // Slightly longer delay to ensure connected objects update first
                });
                
                console.log('FlowchartConnector initialized');
            },
            
            createArrowMarkers() {
                [this.scoreTopEl, this.scoreBottomEl].forEach(svg => {
                    let defs = svg.querySelector('defs');
                    if (!defs) {
                        defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        svg.insertBefore(defs, svg.firstChild);
                    }
                    
                    // Create markers for each color, style, and size combination
                    Object.entries(this.colorMap).forEach(([colorName, colorValue]) => {
                        Object.entries(this.arrowShapes).forEach(([styleName, paths]) => {
                            for (let size = 3; size <= 12; size++) {
                                // End marker
                                const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                                endMarker.setAttribute('id', `arrow-end-${colorName}-${styleName}-${size}`);
                                endMarker.setAttribute('viewBox', '0 0 10 10');
                                endMarker.setAttribute('refX', styleName === 'circle' ? '5' : '9');
                                endMarker.setAttribute('refY', '5');
                                endMarker.setAttribute('markerWidth', size);
                                endMarker.setAttribute('markerHeight', size);
                                endMarker.setAttribute('orient', 'auto-start-reverse');
                                const endPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                endPath.setAttribute('d', paths.end);
                                endPath.setAttribute('fill', colorValue);
                                endMarker.appendChild(endPath);
                                defs.appendChild(endMarker);
                                
                                // Start marker
                                const startMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                                startMarker.setAttribute('id', `arrow-start-${colorName}-${styleName}-${size}`);
                                startMarker.setAttribute('viewBox', '0 0 10 10');
                                startMarker.setAttribute('refX', styleName === 'circle' ? '5' : '1');
                                startMarker.setAttribute('refY', '5');
                                startMarker.setAttribute('markerWidth', size);
                                startMarker.setAttribute('markerHeight', size);
                                startMarker.setAttribute('orient', 'auto-start-reverse');
                                const startPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                startPath.setAttribute('d', paths.start);
                                startPath.setAttribute('fill', colorValue);
                                startMarker.appendChild(startPath);
                                defs.appendChild(startMarker);
                            }
                        });
                    });
                });
            },
            
            toggleConnectMode() {
                this.connectMode = !this.connectMode;
                this.modeBtn.textContent = `Connect Mode: ${this.connectMode ? 'ON' : 'OFF'}`;
                this.modeBtn.style.background = this.connectMode ? 'var(--clr-limeGreen)' : '';
                this.modeBtn.style.color = this.connectMode ? '#000' : '';
                
                // Show/hide connection nodes
                this.updateConnectionNodes();
            },
            
            updateConnectionNodes() {
                // Add/remove connection nodes on SVG elements
                if (window.SVGElementManager) {
                    SVGElementManager.elements.forEach(el => {
                        this.addNodesTo(el, 'svg');
                    });
                }
                
                // Add/remove connection nodes on curves
                if (window.CurveMaker && CurveMaker.curves) {
                    CurveMaker.curves.forEach(curve => {
                        this.addNodesToCurve(curve);
                    });
                }
            },
            
            addNodesTo(el, objectType) {
                const existingNodes = el.wrapper.querySelectorAll('.flowchart-node');
                existingNodes.forEach(n => n.remove());
                
                if (this.connectMode) {
                    // Use unscaled width/height since wrapper transform already applies scale
                    const w = el.width;
                    const h = el.height;
                    // 8 nodes: 4 sides + 4 corners
                    const nodePositions = [
                        { x: w/2, y: 0, side: 'top' },
                        { x: w, y: 0, side: 'top-right' },
                        { x: w, y: h/2, side: 'right' },
                        { x: w, y: h, side: 'bottom-right' },
                        { x: w/2, y: h, side: 'bottom' },
                        { x: 0, y: h, side: 'bottom-left' },
                        { x: 0, y: h/2, side: 'left' },
                        { x: 0, y: 0, side: 'top-left' }
                    ];
                    
                    nodePositions.forEach(pos => {
                        const node = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        node.setAttribute('cx', pos.x);
                        node.setAttribute('cy', pos.y);
                        node.setAttribute('r', '6');
                        node.setAttribute('class', 'flowchart-node');
                        node.setAttribute('data-side', pos.side);
                        node.setAttribute('data-element-id', el.id);
                        node.setAttribute('data-object-type', objectType);
                        node.style.pointerEvents = 'all';
                        
                        node.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.startDrawing(el, pos.side, objectType, e);
                        });
                        
                        el.wrapper.appendChild(node);
                    });
                }
            },
            
            addNodesToCurve(curve) {
                if (!curve.elements || !curve.elements.group) return;
                
                const existingNodes = curve.elements.group.querySelectorAll('.flowchart-node');
                existingNodes.forEach(n => n.remove());
                
                if (this.connectMode) {
                    // Calculate bounding box of curve
                    const minX = Math.min(curve.x1, curve.x2);
                    const maxX = Math.max(curve.x1, curve.x2);
                    const minY = Math.min(curve.y1Pixel, curve.y2Pixel);
                    const maxY = Math.max(curve.y1Pixel, curve.y2Pixel);
                    const midX = (minX + maxX) / 2;
                    const midY = (minY + maxY) / 2;
                    
                    // 8 nodes: 4 sides + 4 corners (same as SVG elements)
                    const nodePositions = [
                        { x: midX, y: minY, side: 'top' },
                        { x: maxX, y: minY, side: 'top-right' },
                        { x: maxX, y: midY, side: 'right' },
                        { x: maxX, y: maxY, side: 'bottom-right' },
                        { x: midX, y: maxY, side: 'bottom' },
                        { x: minX, y: maxY, side: 'bottom-left' },
                        { x: minX, y: midY, side: 'left' },
                        { x: minX, y: minY, side: 'top-left' }
                    ];
                    
                    nodePositions.forEach(pos => {
                        const node = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        node.setAttribute('cx', pos.x);
                        node.setAttribute('cy', pos.y);
                        node.setAttribute('r', '6');
                        node.setAttribute('class', 'flowchart-node');
                        node.setAttribute('data-side', pos.side);
                        node.setAttribute('data-curve-id', curve.id);
                        node.setAttribute('data-object-type', 'curve');
                        node.style.pointerEvents = 'all';
                        
                        node.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.startDrawingFromCurve(curve, pos.side, e);
                        });
                        
                        curve.elements.group.appendChild(node);
                    });
                }
            },
            
            startDrawing(element, side, objectType, e) {
                const section = this.scoreTopEl.contains(element.wrapper) ? 'top' : 'bottom';
                
                this.isDrawing = true;
                this.drawStartElement = element;
                this.drawStartSide = side;
                this.drawStartObjectType = objectType;
                this.drawSection = section;
                this.drawStartPoint = this.getNodePosition(element, side, objectType);
                
                this.createTempLine(section);
            },
            
            startDrawingFromCurve(curve, side, e) {
                const section = curve.section || 'top';
                
                this.isDrawing = true;
                this.drawStartElement = curve;
                this.drawStartSide = side;
                this.drawStartObjectType = 'curve';
                this.drawSection = section;
                this.drawStartPoint = this.getCurveNodePosition(curve, side);
                
                this.createTempLine(section);
            },
            
            createTempLine(section) {
                const group = section === 'top' ? this.topConnectorGroup : this.bottomConnectorGroup;
                this.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.tempLine.setAttribute('stroke', '#888');
                this.tempLine.setAttribute('stroke-width', '2');
                this.tempLine.setAttribute('stroke-dasharray', '5,5');
                this.tempLine.setAttribute('fill', 'none');
                this.tempLine.style.pointerEvents = 'none';
                group.appendChild(this.tempLine);
            },
            
            handleMouseMove(e) {
                if (!this.isDrawing || !this.tempLine) return;
                
                const svg = this.drawSection === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const rect = svg.getBoundingClientRect();
                // Account for zoom scale
                const zoomScale = window.ScoreZoom ? ScoreZoom.getZoom() : 1;
                const x = (e.clientX - rect.left) / zoomScale;
                const y = (e.clientY - rect.top) / zoomScale;
                
                const routing = this.routingSelect?.value || 'auto';
                const path = this.calculatePath(
                    this.drawStartPoint.x, this.drawStartPoint.y,
                    x, y,
                    this.drawStartSide, null, routing
                );
                this.tempLine.setAttribute('d', path);
            },
            
            handleMouseUp(e) {
                if (!this.isDrawing) return;
                
                const node = e.target.closest('.flowchart-node');
                if (node) {
                    const objectType = node.getAttribute('data-object-type');
                    
                    if (objectType === 'curve') {
                        const curveId = parseInt(node.getAttribute('data-curve-id'));
                        if (curveId !== this.drawStartElement.id || this.drawStartObjectType !== 'curve') {
                            const endCurve = CurveMaker.curves.find(c => c.id === curveId);
                            const endSide = node.getAttribute('data-side');
                            if (endCurve) {
                                this.createConnectorGeneric(
                                    this.drawStartElement, this.drawStartSide, this.drawStartObjectType,
                                    endCurve, endSide, 'curve',
                                    this.drawSection
                                );
                            }
                        }
                    } else {
                        const elementId = parseInt(node.getAttribute('data-element-id'));
                        if (elementId !== this.drawStartElement.id || this.drawStartObjectType !== 'svg') {
                            const endElement = SVGElementManager.elements.find(el => el.id === elementId);
                            const endSide = node.getAttribute('data-side');
                            if (endElement) {
                                this.createConnectorGeneric(
                                    this.drawStartElement, this.drawStartSide, this.drawStartObjectType,
                                    endElement, endSide, 'svg',
                                    this.drawSection
                                );
                            }
                        }
                    }
                }
                
                // Clean up
                if (this.tempLine) {
                    this.tempLine.remove();
                    this.tempLine = null;
                }
                this.isDrawing = false;
                this.drawStartElement = null;
                this.drawStartPoint = null;
                this.drawStartObjectType = null;
            },
            
            getNodePosition(element, side, objectType) {
                if (objectType === 'curve') {
                    return this.getCurveNodePosition(element, side);
                }
                
                const w = element.width * element.scale;
                const h = element.height * element.scale;
                let x = element.x;
                let y = element.y;
                
                switch (side) {
                    case 'top': x += w/2; break;
                    case 'top-right': x += w; break;
                    case 'right': x += w; y += h/2; break;
                    case 'bottom-right': x += w; y += h; break;
                    case 'bottom': x += w/2; y += h; break;
                    case 'bottom-left': y += h; break;
                    case 'left': y += h/2; break;
                    case 'top-left': break;
                }
                return { x, y };
            },
            
            getCurveNodePosition(curve, side) {
                // Calculate bounding box of curve
                const minX = Math.min(curve.x1, curve.x2);
                const maxX = Math.max(curve.x1, curve.x2);
                const minY = Math.min(curve.y1Pixel, curve.y2Pixel);
                const maxY = Math.max(curve.y1Pixel, curve.y2Pixel);
                const midX = (minX + maxX) / 2;
                const midY = (minY + maxY) / 2;
                
                switch (side) {
                    case 'top': return { x: midX, y: minY };
                    case 'top-right': return { x: maxX, y: minY };
                    case 'right': return { x: maxX, y: midY };
                    case 'bottom-right': return { x: maxX, y: maxY };
                    case 'bottom': return { x: midX, y: maxY };
                    case 'bottom-left': return { x: minX, y: maxY };
                    case 'left': return { x: minX, y: midY };
                    case 'top-left': return { x: minX, y: minY };
                    // Legacy support for old 'start'/'end' sides
                    case 'start': return { x: curve.x1, y: curve.y1Pixel };
                    case 'end': return { x: curve.x2, y: curve.y2Pixel };
                    default: return { x: midX, y: midY };
                }
            },
            
            calculatePath(x1, y1, x2, y2, startSide, endSide, routing) {
                if (routing === 'direct') {
                    return `M ${x1} ${y1} L ${x2} ${y2}`;
                }
                
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                
                let path;
                
                if (routing === 'horizontal-first') {
                    path = `M ${x1} ${y1} H ${x2} V ${y2}`;
                } else if (routing === 'vertical-first') {
                    path = `M ${x1} ${y1} V ${y2} H ${x2}`;
                } else {
                    // Auto routing based on start side
                    const isHorizontalStart = startSide === 'left' || startSide === 'right' || 
                                              startSide === 'top-left' || startSide === 'top-right' ||
                                              startSide === 'bottom-left' || startSide === 'bottom-right';
                    
                    if (isHorizontalStart) {
                        path = `M ${x1} ${y1} H ${midX} V ${y2} H ${x2}`;
                    } else {
                        path = `M ${x1} ${y1} V ${midY} H ${x2} V ${y2}`;
                    }
                }
                
                return path;
            },
            
            createConnectorGeneric(startObj, startSide, startType, endObj, endSide, endType, section) {
                const id = this.nextId++;
                const lineColor = this.lineColorSelect?.value || 'lightGrey';
                const arrowColor = this.arrowColorSelect?.value || 'lightGrey';
                const arrowType = this.arrowSelect?.value || 'end';
                const arrowStyle = this.arrowStyleSelect?.value || 'triangle';
                const arrowSize = parseInt(this.arrowSizeSlider?.value) || 6;
                const routing = this.routingSelect?.value || 'auto';
                
                const connector = {
                    id,
                    startId: startObj.id,
                    startSide,
                    startType,
                    endId: endObj.id,
                    endSide,
                    endType,
                    section,
                    lineColor,
                    arrowColor,
                    arrowType,
                    arrowStyle,
                    arrowSize,
                    routing,
                    elements: {}
                };
                
                // Create SVG elements
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'flowchart-connector');
                group.setAttribute('data-connector-id', id);
                
                const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                hitArea.setAttribute('class', 'flowchart-connector-hitarea');
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'flowchart-connector-path');
                
                group.appendChild(hitArea);
                group.appendChild(path);
                
                const containerGroup = section === 'top' ? this.topConnectorGroup : this.bottomConnectorGroup;
                containerGroup.appendChild(group);
                
                connector.elements = { group, path, hitArea };
                this.connectors.push(connector);
                
                // Update rendering
                this.updateConnectorRendering(connector);
                
                // Add click handler
                hitArea.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    this.selectConnector(connector);
                });
                path.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    this.selectConnector(connector);
                });
                
                this.updateConnectorList();
                
                if (window.ScoreManager) ScoreManager.markDirty();
                
                console.log(`Connector created: ${id}`);
                return connector;
            },
            
            getObjectById(id, type) {
                if (type === 'svg') {
                    return SVGElementManager.elements.find(el => el.id === id);
                } else if (type === 'curve') {
                    return CurveMaker.curves.find(c => c.id === id);
                }
                return null;
            },
            
            updateConnectorRendering(connector) {
                const startObj = this.getObjectById(connector.startId, connector.startType);
                const endObj = this.getObjectById(connector.endId, connector.endType);
                
                if (!startObj || !endObj) return;
                
                const startPoint = this.getNodePosition(startObj, connector.startSide, connector.startType);
                const endPoint = this.getNodePosition(endObj, connector.endSide, connector.endType);
                
                const pathD = this.calculatePath(
                    startPoint.x, startPoint.y,
                    endPoint.x, endPoint.y,
                    connector.startSide, connector.endSide, connector.routing
                );
                
                connector.elements.path.setAttribute('d', pathD);
                connector.elements.hitArea.setAttribute('d', pathD);
                
                // Apply line color
                connector.elements.path.setAttribute('stroke', this.colorMap[connector.lineColor] || '#aaa');
                
                // Apply arrow markers
                this.applyArrowMarkers(connector);
            },
            
            applyArrowMarkers(connector) {
                const path = connector.elements.path;
                const { arrowColor, arrowStyle, arrowSize, arrowType } = connector;
                
                path.removeAttribute('marker-start');
                path.removeAttribute('marker-end');
                
                const markerBase = `arrow-${arrowColor}-${arrowStyle}-${arrowSize}`;
                
                switch (arrowType) {
                    case 'end':
                        path.setAttribute('marker-end', `url(#arrow-end-${arrowColor}-${arrowStyle}-${arrowSize})`);
                        break;
                    case 'start':
                        path.setAttribute('marker-start', `url(#arrow-start-${arrowColor}-${arrowStyle}-${arrowSize})`);
                        break;
                    case 'both':
                        path.setAttribute('marker-start', `url(#arrow-start-${arrowColor}-${arrowStyle}-${arrowSize})`);
                        path.setAttribute('marker-end', `url(#arrow-end-${arrowColor}-${arrowStyle}-${arrowSize})`);
                        break;
                    case 'none':
                        break;
                }
            },
            
            selectConnector(connector) {
                this.deselectAll();
                this.selectedConnector = connector;
                connector.elements.group.classList.add('selected');
                
                // Update UI
                if (this.arrowSelect) this.arrowSelect.value = connector.arrowType;
                if (this.arrowStyleSelect) this.arrowStyleSelect.value = connector.arrowStyle;
                if (this.arrowSizeSlider) {
                    this.arrowSizeSlider.value = connector.arrowSize;
                    this.arrowSizeValue.textContent = connector.arrowSize;
                }
                if (this.lineColorSelect) this.lineColorSelect.value = connector.lineColor;
                if (this.arrowColorSelect) this.arrowColorSelect.value = connector.arrowColor;
                if (this.routingSelect) this.routingSelect.value = connector.routing;
                
                this.updateConnectorList();
            },
            
            deselectAll() {
                if (this.selectedConnector) {
                    this.selectedConnector.elements.group.classList.remove('selected');
                }
                this.selectedConnector = null;
                this.updateConnectorList();
            },
            
            updateSelectedProperty(prop, value) {
                if (!this.selectedConnector) return;
                this.selectedConnector[prop] = value;
                this.updateConnectorRendering(this.selectedConnector);
                if (window.ScoreManager) ScoreManager.markDirty();
            },
            
            deleteSelected() {
                if (!this.selectedConnector) return;
                
                this.selectedConnector.elements.group.remove();
                const idx = this.connectors.indexOf(this.selectedConnector);
                if (idx > -1) this.connectors.splice(idx, 1);
                
                this.selectedConnector = null;
                this.updateConnectorList();
                if (window.ScoreManager) ScoreManager.markDirty();
            },
            
            updateConnectorList() {
                if (!this.connectorList) return;
                this.connectorList.innerHTML = '';
                
                this.connectors.forEach(conn => {
                    const item = document.createElement('div');
                    item.className = 'connector-item' + (conn === this.selectedConnector ? ' selected' : '');
                    item.textContent = `Connector ${conn.id}`;
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectConnector(conn);
                    });
                    this.connectorList.appendChild(item);
                });
            },
            
            updateAllConnectors() {
                this.connectors.forEach(conn => {
                    // Update connector's section based on start object's current section
                    const startObj = this.getObjectById(conn.startId, conn.startType);
                    if (startObj && startObj.section) {
                        const newSection = startObj.section;
                        if (conn.section !== newSection) {
                            conn.section = newSection;
                            // Move to correct container
                            const targetContainer = newSection === 'top' ? this.topConnectorGroup : this.bottomConnectorGroup;
                            if (conn.elements && conn.elements.group && conn.elements.group.parentNode !== targetContainer) {
                                targetContainer.appendChild(conn.elements.group);
                            }
                        }
                    }
                    this.updateConnectorRendering(conn);
                });
                // Also refresh connection nodes if in connect mode
                if (this.connectMode) {
                    this.updateConnectionNodes();
                }
            },
            
            // Re-render all connectors on window resize
            reRenderAllConnectors() {
                // Connectors are based on connected objects, so just update all
                this.updateAllConnectors();
            },
            
            // Show/hide connectors based on current page
            updateVisibility() {
                if (!window.GraphicTimeline) return;
                
                const topPage = GraphicTimeline.currentTopPage;
                const bottomPage = GraphicTimeline.currentBottomPage;
                
                this.connectors.forEach(conn => {
                    if (!conn.elements || !conn.elements.group) return;
                    
                    // Get the page of the connector's start object
                    const startObj = this.getObjectById(conn.startId, conn.startType);
                    if (!startObj) {
                        conn.elements.group.style.display = 'none';
                        return;
                    }
                    
                    const objPage = startObj.page || 0;
                    const objSection = startObj.section || conn.section || 'top';
                    
                    // Check if connector's page matches current visible pages
                    const visible = (objSection === 'top' && objPage === topPage) ||
                                   (objSection === 'bottom' && objPage === bottomPage);
                    conn.elements.group.style.display = visible ? '' : 'none';
                });
            },
            
            exportData() {
                return this.connectors.map(conn => ({
                    id: conn.id,
                    startId: conn.startId,
                    startSide: conn.startSide,
                    startType: conn.startType,
                    endId: conn.endId,
                    endSide: conn.endSide,
                    endType: conn.endType,
                    section: conn.section,
                    lineColor: conn.lineColor,
                    arrowColor: conn.arrowColor,
                    arrowType: conn.arrowType,
                    arrowStyle: conn.arrowStyle,
                    arrowSize: conn.arrowSize,
                    routing: conn.routing
                }));
            },
            
            importData(data) {
                if (!data || !Array.isArray(data)) return;
                
                // Clear existing
                this.connectors.forEach(conn => conn.elements.group.remove());
                this.connectors = [];
                this.selectedConnector = null;
                
                // Recreate connectors
                data.forEach(connData => {
                    // Handle legacy data format
                    const startType = connData.startType || 'svg';
                    const endType = connData.endType || 'svg';
                    const startId = connData.startId !== undefined ? connData.startId : connData.startElementId;
                    const endId = connData.endId !== undefined ? connData.endId : connData.endElementId;
                    
                    const startObj = this.getObjectById(startId, startType);
                    const endObj = this.getObjectById(endId, endType);
                    
                    if (!startObj || !endObj) return;
                    
                    const connector = {
                        id: connData.id,
                        startId: startId,
                        startSide: connData.startSide,
                        startType: startType,
                        endId: endId,
                        endSide: connData.endSide,
                        endType: endType,
                        section: connData.section,
                        lineColor: connData.lineColor || connData.color || 'lightGrey',
                        arrowColor: connData.arrowColor || connData.color || 'lightGrey',
                        arrowType: connData.arrowType || 'end',
                        arrowStyle: connData.arrowStyle || 'triangle',
                        arrowSize: connData.arrowSize || 6,
                        routing: connData.routing || 'auto',
                        elements: {}
                    };
                    
                    // Create SVG elements
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.setAttribute('class', 'flowchart-connector');
                    group.setAttribute('data-connector-id', connector.id);
                    
                    const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    hitArea.setAttribute('class', 'flowchart-connector-hitarea');
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('class', 'flowchart-connector-path');
                    
                    group.appendChild(hitArea);
                    group.appendChild(path);
                    
                    const containerGroup = connector.section === 'top' ? this.topConnectorGroup : this.bottomConnectorGroup;
                    containerGroup.appendChild(group);
                    
                    connector.elements = { group, path, hitArea };
                    this.connectors.push(connector);
                    
                    // Update rendering
                    this.updateConnectorRendering(connector);
                    
                    // Add click handler
                    hitArea.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        this.selectConnector(connector);
                    });
                    path.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        this.selectConnector(connector);
                    });
                    
                    if (connData.id >= this.nextId) {
                        this.nextId = connData.id + 1;
                    }
                });
                
                this.updateConnectorList();
                console.log(`FlowchartConnector: Imported ${this.connectors.length} connectors`);
            }
        };
        
        // Staff Cursors System - Animated vertical lines for each staff
        // Uses server-synced animation timeline for exact pixel sync across all clients
        const StaffCursors = {
            cursors: [],           // Array of cursor objects for each staff
            staffDividers: [],     // Array of horizontal staff divider line objects
            staffHeaders: [],      // Array of staff header SVG elements
            staffLabels: [],       // Array of staff label text elements
            staffConnector: null,  // Vertical line connecting all staff headers
            staffHeaderGroup: null, // Group containing all staff header elements
            scoreTopEl: null,
            scoreBottomEl: null,
            initialized: false,
            
            // Cursor colors matching the CSS variables
            colors: [
                'rgb(153,255,0)',      // Staff 1: Lime Green
                'rgb(255, 21, 160)',   // Staff 2: Neon Magenta
                'rgba(56,126,211,255)', // Staff 3: Bright Blue
                'rgba(240,75,0,255)'   // Staff 4: Bright Orange
            ],
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Create horizontal staff dividers (3 lines dividing into 4 sections)
                this.createStaffDividers();
                
                // Create cursors for each of the 4 staves
                for (let i = 0; i < 4; i++) {
                    const cursor = this.createCursor(i);
                    this.cursors.push(cursor);
                }
                
                // Create staff headers (clefs, labels, connector line)
                this.createStaffHeaders();
                
                // Listen for score state from server
                ClockSync.socket.on('scoreState', (data) => {
                    this.onScoreState(data);
                });
                
                // Hook into AnimationEngine
                const originalOnDraw = AnimationEngine.onDraw;
                AnimationEngine.onDraw = (frameNumber, elapsedMs) => {
                    if (originalOnDraw) originalOnDraw(frameNumber, elapsedMs);
                    this.update();
                };
                
                // Update cursor dimensions on window resize
                window.addEventListener('resize', () => {
                    this.updateCursorDimensions();
                    this.updateStaffHeaders();
                    // DISABLED: this.updateMotiveContainerWidths();
                });
                
                // DISABLED: Initial motive container sizing
                // this.updateMotiveContainerWidths();
                
                // Log initial dimensions
                this.updateCursorDimensions();
                
                this.initialized = true;
            },
            
            // Called when we receive score state from server
            onScoreState(data) {
                ScoreTime.isPlaying = data.isPlaying;
                ScoreTime.currentScoreTimeMs = data.currentScoreTimeMs;
                ScoreTime.scoreTimeOffset = data.scoreTimeOffset;
                serverTempoHistory = data.tempoHistory;
                
                // Update local tempo variables to match server
                if (serverTempoHistory.length > 0) {
                    const latestTempo = serverTempoHistory[serverTempoHistory.length - 1];
                    beatsPerMinute = latestTempo.bpm;
                    beatsPerPage = latestTempo.beatsPerPage;
                }
                
                // Redraw graphic timeline when tempo/beatsPerPage changes
                if (window.GraphicTimeline) {
                    GraphicTimeline.renderTicks();
                }
                
                // Update UI button state
                if (window.CursorControls && CursorControls.goStopBtn) {
                    CursorControls.goStopBtn.textContent = ScoreTime.isPlaying ? 'Stop' : 'Play';
                    CursorControls.goStopBtn.classList.toggle('active', ScoreTime.isPlaying);
                }
                
                // Start animation engine if not running (always runs for rendering)
                if (!AnimationEngine.running) {
                    AnimationEngine.start(ClockSync.now());
                }
                
                console.log(`Score state received - Playing: ${data.isPlaying}, ScoreTime: ${data.currentScoreTimeMs}ms`);
            },
            
            // Called when tempo changes - adds to local tempo history copy
            onTempoChange(newBpm, newBeatsPerPage, scoreTimeMs) {
                // Add to local tempo history with score time
                serverTempoHistory.push({
                    scoreTimeMs: scoreTimeMs,
                    bpm: newBpm,
                    beatsPerPage: newBeatsPerPage
                });
            },
            
            // Calculate total pages traveled from tempo history using score time
            // Returns a value where 1.0 = one full page width (100%)
            calculateTotalPages(scoreTimeMs) {
                if (serverTempoHistory.length === 0) {
                    return 0;
                }
                
                let totalPages = 0;
                
                for (let i = 0; i < serverTempoHistory.length; i++) {
                    const segment = serverTempoHistory[i];
                    const segmentStart = segment.scoreTimeMs;
                    
                    // Determine segment end time
                    let segmentEnd;
                    if (i < serverTempoHistory.length - 1) {
                        segmentEnd = serverTempoHistory[i + 1].scoreTimeMs;
                    } else {
                        segmentEnd = scoreTimeMs;
                    }
                    
                    // Calculate duration of this segment
                    const segmentDuration = segmentEnd - segmentStart;
                    
                    if (segmentDuration > 0) {
                        // Calculate pages per ms for this segment
                        // pagesPerMs = beatsPerMs / beatsPerPage = bpm / (60000 * beatsPerPage)
                        const pagesPerMs = segment.bpm / (60000 * segment.beatsPerPage);
                        
                        // Add pages traveled in this segment
                        totalPages += segmentDuration * pagesPerMs;
                    }
                }
                
                return totalPages;
            },
            
            // Timeline height in pixels - staves start below this
            timelineHeight: 8,
            
            // Create 3 horizontal staff dividers to divide page into 4 vertical sections
            createStaffDividers() {
                const scoreHeight = this.scoreTopEl.clientHeight;
                const availableHeight = scoreHeight - this.timelineHeight;
                const sectionHeight = availableHeight / 4;
                
                // Create 3 staff dividers (at bottom of sections 1, 2, and 3)
                for (let i = 1; i <= 3; i++) {
                    const yPosition = this.timelineHeight + (i * sectionHeight);
                    
                    // Create line for ScoreTop
                    const lineTop = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    lineTop.setAttribute('x1', '0');
                    lineTop.setAttribute('y1', yPosition);
                    lineTop.setAttribute('x2', '100%');
                    lineTop.setAttribute('y2', yPosition);
                    lineTop.setAttribute('stroke', '#999');
                    lineTop.setAttribute('stroke-width', '1');
                    
                    // Create line for ScoreBottom
                    const lineBottom = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    lineBottom.setAttribute('x1', '0');
                    lineBottom.setAttribute('y1', yPosition);
                    lineBottom.setAttribute('x2', '100%');
                    lineBottom.setAttribute('y2', yPosition);
                    lineBottom.setAttribute('stroke', '#999');
                    lineBottom.setAttribute('stroke-width', '1');
                    
                    // Add to SVG elements
                    this.scoreTopEl.appendChild(lineTop);
                    this.scoreBottomEl.appendChild(lineBottom);
                    
                    this.staffDividers.push({
                        sectionIndex: i,
                        topEl: lineTop,
                        bottomEl: lineBottom
                    });
                }
            },
            
            // Update staff divider positions on resize
            updateStaffDividers() {
                const scoreHeight = this.scoreTopEl.clientHeight;
                const availableHeight = scoreHeight - this.timelineHeight;
                const sectionHeight = availableHeight / 4;
                
                this.staffDividers.forEach((line) => {
                    const yPosition = this.timelineHeight + (line.sectionIndex * sectionHeight);
                    [line.topEl, line.bottomEl].forEach(el => {
                        el.setAttribute('y1', yPosition);
                        el.setAttribute('y2', yPosition);
                    });
                });
            },
            
            createCursor(staffIndex) {
                // Create SVG rect elements for both ScoreTop and ScoreBottom
                const cursorTop = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const cursorBottom = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                
                // Get the score height to calculate cursor dimensions
                // Each cursor is on its own horizontal stripe (1/4 of available height)
                const scoreHeight = this.scoreTopEl.clientHeight;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                const yPosition = this.timelineHeight + (staffIndex * staffHeight);
                
                // Configure cursor appearance - 3 pixels wide, full staff height
                [cursorTop, cursorBottom].forEach(cursor => {
                    cursor.setAttribute('width', '3');
                    cursor.setAttribute('y', yPosition);
                    cursor.setAttribute('height', staffHeight);
                    cursor.setAttribute('fill', this.colors[staffIndex]);
                    cursor.setAttribute('x', '0');
                });
                
                // Create meter outline rectangles (empty outline that appears when curve is encountered)
                const meterOutlineTop = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const meterOutlineBottom = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                
                [meterOutlineTop, meterOutlineBottom].forEach(outline => {
                    outline.setAttribute('width', '8');
                    outline.setAttribute('y', yPosition);
                    outline.setAttribute('height', staffHeight);
                    outline.setAttribute('fill', 'none');
                    outline.setAttribute('stroke', this.colors[staffIndex]);
                    outline.setAttribute('stroke-width', '1.5');
                    outline.setAttribute('opacity', '0.8');
                    outline.setAttribute('x', '-11');
                    outline.style.display = 'none';
                });
                
                // Create curve-following rectangles (fill inside the meter)
                const curveFollowerTop = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const curveFollowerBottom = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                
                [curveFollowerTop, curveFollowerBottom].forEach(follower => {
                    follower.setAttribute('width', '8');
                    follower.setAttribute('y', yPosition);
                    follower.setAttribute('height', staffHeight);
                    follower.setAttribute('fill', this.colors[staffIndex]);
                    follower.setAttribute('stroke', 'none');
                    follower.setAttribute('opacity', '0.3');
                    follower.setAttribute('x', '-11'); // 8px width + 3px gap left of cursor
                    follower.style.display = 'none';
                });
                
                // Create motive pie dial (1/8 staff height square with pie animation and wand)
                // Positioned left of curve meter, flush with top
                const createMotivePie = () => {
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.style.display = 'none';
                    
                    // Square border (black)
                    const border = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    border.setAttribute('fill', 'none');
                    border.setAttribute('stroke', 'black');
                    border.setAttribute('stroke-width', '1');
                    group.appendChild(border);
                    
                    // Pie arc (decreasing fill) - color set dynamically
                    const arc = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    arc.setAttribute('fill', this.colors[staffIndex]);
                    arc.setAttribute('opacity', '0.3');
                    group.appendChild(arc);
                    
                    // Clock hand/wand (1px black line)
                    const hand = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    hand.setAttribute('stroke', 'black');
                    hand.setAttribute('stroke-width', '1');
                    hand.setAttribute('stroke-linecap', 'round');
                    group.appendChild(hand);
                    
                    return { group, border, arc, hand };
                };
                
                const motivePieTop = createMotivePie();
                const motivePieBottom = createMotivePie();
                
                // Add to SVG elements
                this.scoreTopEl.appendChild(meterOutlineTop);
                this.scoreBottomEl.appendChild(meterOutlineBottom);
                this.scoreTopEl.appendChild(cursorTop);
                this.scoreBottomEl.appendChild(cursorBottom);
                this.scoreTopEl.appendChild(motivePieTop.group);
                this.scoreBottomEl.appendChild(motivePieBottom.group);
                this.scoreTopEl.appendChild(curveFollowerTop);
                this.scoreBottomEl.appendChild(curveFollowerBottom);
                
                return {
                    staffIndex: staffIndex,
                    topEl: cursorTop,
                    bottomEl: cursorBottom,
                    curveFollowerTop: curveFollowerTop,
                    curveFollowerBottom: curveFollowerBottom,
                    meterOutlineTop: meterOutlineTop,
                    meterOutlineBottom: meterOutlineBottom,
                    motivePieTop: motivePieTop,
                    motivePieBottom: motivePieBottom,
                    currentSection: 'top',  // 'top' or 'bottom'
                    xPosition: 0,           // Current x position in pixels
                    currentCurveValue: null, // Current normalized Y value from curve
                    currentMotiveProgress: null // Current normalized progress through motive
                };
            },
            
            // Update cursor dimensions on resize
            updateCursorDimensions() {
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                
                // console.log(`ScoreTop dimensions: ${scoreWidth}px x ${scoreHeight}px, Staff cursor height: ${staffHeight.toFixed(1)}px`);
                
                this.cursors.forEach((cursor, staffIndex) => {
                    const yPosition = this.timelineHeight + (staffIndex * staffHeight);
                    [cursor.topEl, cursor.bottomEl].forEach(el => {
                        el.setAttribute('y', yPosition);
                        el.setAttribute('height', staffHeight);
                    });
                    // Update curve followers and meter outlines too
                    [cursor.curveFollowerTop, cursor.curveFollowerBottom].forEach(el => {
                        el.setAttribute('y', yPosition);
                        el.setAttribute('height', staffHeight);
                    });
                    [cursor.meterOutlineTop, cursor.meterOutlineBottom].forEach(el => {
                        el.setAttribute('y', yPosition);
                        el.setAttribute('height', staffHeight);
                    });
                    // Motive dials don't need resize - they use fixed size and are positioned dynamically
                });
                
                // Also update staff dividers on resize
                this.updateStaffDividers();
            },
            
            // Staff header SVG paths
            staffHeaderPaths: [
                '/lilypond_code/violin1_staff_label.cropped.svg',
                '/lilypond_code/violin2_staff_header.cropped.svg',
                '/lilypond_code/viola_staff_header.cropped.svg',
                '/lilypond_code/cello_staff_header.cropped.svg'
            ],
            staffLabelTexts: ['violin I', 'violin II', 'viola', 'cello'],
            
            // Create staff headers with clefs, labels, and connector line
            createStaffHeaders() {
                // Create a group to hold all staff header elements
                this.staffHeaderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.staffHeaderGroup.setAttribute('id', 'staff-headers-group');
                this.scoreTopEl.appendChild(this.staffHeaderGroup);
                
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                
                // Calculate X position: lead-in percentage of page width
                // Timeline 0 is at leadInPixels from left edge
                const secondsPerPage = (60 / beatsPerMinute) * beatsPerPage;
                const leadInFraction = leadInSeconds / secondsPerPage;
                const leadInPixels = leadInFraction * scoreWidth;
                
                // SVG header dimensions (1/3 of staff height)
                const headerHeight = staffHeight / 3;
                // SVG viewBox: width=5.8450, height=7.2360 => aspect ratio ~0.808
                // Staff lines in SVG: x1=0.0250, viewBox starts at x=-0.7500
                // So staff line start is at 0.0250 - (-0.7500) = 0.775 from SVG left edge
                // As fraction of viewBox width: 0.775 / 5.8450 = 0.1326
                const svgAspectRatio = 5.8450 / 7.2360;
                const headerWidth = headerHeight * svgAspectRatio;
                const staffLineStartFraction = 0.775 / 5.8450; // ~0.1326
                
                // Right edge of SVGs should be 3px before timeline 0
                const svgRightEdge = leadInPixels - 3;
                const svgLeftEdge = svgRightEdge - headerWidth;
                
                // Connector line X: at the staff line start X coordinate
                const connectorX = svgLeftEdge + (staffLineStartFraction * headerWidth);
                
                // Labels: right-justified, 8px left of connector line (3 + 5 extra)
                const labelRightEdge = connectorX - 8;
                
                // Font size scales with staff height (base 11px at ~100px staff height)
                const fontSize = Math.max(8, staffHeight * 0.11);
                
                console.log(`Staff headers: leadInPixels=${leadInPixels.toFixed(1)}, svgRightEdge=${svgRightEdge.toFixed(1)}, headerHeight=${headerHeight.toFixed(1)}, connectorX=${connectorX.toFixed(1)}`);
                
                // Calculate Y positions for connector line
                // SVG viewBox: y starts at -1.5930, top staff line at y=0.0250, bottom at y=4.0250
                // Top staff line offset from viewBox top: 0.0250 - (-1.5930) = 1.618
                // Bottom staff line offset: 4.0250 - (-1.5930) = 5.618
                // As fractions of viewBox height (7.2360):
                const topStaffLineFraction = 1.618 / 7.2360;    // ~0.2236
                const bottomStaffLineFraction = 5.618 / 7.2360; // ~0.7766
                
                const headerYOffset = (staffHeight - headerHeight) / 2;
                
                // V1 top staff line Y position
                const v1HeaderY = this.timelineHeight + headerYOffset;
                const v1TopStaffLine = v1HeaderY + (topStaffLineFraction * headerHeight);
                
                // Cello bottom staff line Y position
                const celloHeaderY = this.timelineHeight + (3 * staffHeight) + headerYOffset;
                const celloBottomStaffLine = celloHeaderY + (bottomStaffLineFraction * headerHeight);
                
                // Create vertical connector line (1px width)
                this.staffConnector = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                this.staffConnector.setAttribute('x1', connectorX);
                this.staffConnector.setAttribute('x2', connectorX);
                this.staffConnector.setAttribute('y1', v1TopStaffLine);
                this.staffConnector.setAttribute('y2', celloBottomStaffLine);
                this.staffConnector.setAttribute('stroke', '#000');
                this.staffConnector.setAttribute('stroke-width', '1');
                this.staffHeaderGroup.appendChild(this.staffConnector);
                
                // Create staff headers and labels for each track
                for (let i = 0; i < 4; i++) {
                    const yPosition = this.timelineHeight + (i * staffHeight);
                    
                    // Create label text (right-justified, 8px left of connector)
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', labelRightEdge);
                    label.setAttribute('y', yPosition + staffHeight / 2);
                    label.setAttribute('dominant-baseline', 'middle');
                    label.setAttribute('text-anchor', 'end');
                    label.setAttribute('font-family', 'Futura, sans-serif');
                    label.setAttribute('font-size', `${fontSize}px`);
                    label.setAttribute('fill', '#000');
                    label.textContent = this.staffLabelTexts[i];
                    this.staffHeaderGroup.appendChild(label);
                    this.staffLabels.push(label);
                    
                    // Create image element for the clef SVG (right edge at svgRightEdge)
                    const header = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    header.setAttribute('href', this.staffHeaderPaths[i]);
                    header.setAttribute('x', svgLeftEdge);
                    header.setAttribute('y', yPosition + headerYOffset);
                    header.setAttribute('height', headerHeight);
                    header.setAttribute('preserveAspectRatio', 'xMaxYMid meet');
                    this.staffHeaderGroup.appendChild(header);
                    this.staffHeaders.push(header);
                }
            },
            
            // Update staff headers on resize
            updateStaffHeaders() {
                if (!this.staffHeaderGroup) return;
                
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                
                // Recalculate positions based on lead-in
                const secondsPerPage = (60 / beatsPerMinute) * beatsPerPage;
                const leadInFraction = leadInSeconds / secondsPerPage;
                const leadInPixels = leadInFraction * scoreWidth;
                
                // SVG header dimensions (1/3 of staff height)
                const headerHeight = staffHeight / 3;
                const svgAspectRatio = 5.8450 / 7.2360;
                const headerWidth = headerHeight * svgAspectRatio;
                const staffLineStartFraction = 0.775 / 5.8450;
                
                // Right edge of SVGs should be 3px before timeline 0
                const svgRightEdge = leadInPixels - 3;
                const svgLeftEdge = svgRightEdge - headerWidth;
                
                // Connector line X: at the staff line start X coordinate
                const connectorX = svgLeftEdge + (staffLineStartFraction * headerWidth);
                
                // Labels: right-justified, 8px left of connector line
                const labelRightEdge = connectorX - 8;
                
                // Font size scales with staff height
                const fontSize = Math.max(8, staffHeight * 0.11);
                
                // Y positions for connector line (using SVG staff line fractions)
                const topStaffLineFraction = 1.618 / 7.2360;
                const bottomStaffLineFraction = 5.618 / 7.2360;
                const headerYOffset = (staffHeight - headerHeight) / 2;
                
                const v1HeaderY = this.timelineHeight + headerYOffset;
                const v1TopStaffLine = v1HeaderY + (topStaffLineFraction * headerHeight);
                
                const celloHeaderY = this.timelineHeight + (3 * staffHeight) + headerYOffset;
                const celloBottomStaffLine = celloHeaderY + (bottomStaffLineFraction * headerHeight);
                
                // Update connector line
                if (this.staffConnector) {
                    this.staffConnector.setAttribute('x1', connectorX);
                    this.staffConnector.setAttribute('x2', connectorX);
                    this.staffConnector.setAttribute('y1', v1TopStaffLine);
                    this.staffConnector.setAttribute('y2', celloBottomStaffLine);
                }
                
                // Update each header
                this.staffHeaders.forEach((header, i) => {
                    const yPosition = this.timelineHeight + (i * staffHeight);
                    header.setAttribute('x', svgLeftEdge);
                    header.setAttribute('y', yPosition + headerYOffset);
                    header.setAttribute('height', headerHeight);
                });
                
                // Update each label
                this.staffLabels.forEach((label, i) => {
                    const yPosition = this.timelineHeight + (i * staffHeight);
                    label.setAttribute('x', labelRightEdge);
                    label.setAttribute('font-size', `${fontSize}px`);
                    label.setAttribute('y', yPosition + staffHeight / 2);
                });
            },
            
            /* DISABLED: Static motive windows (code kept for future reference)
            // Update static motive panel and box dimensions to match scrolling windows
            updateMotiveContainerWidths() {
                const scoreHeight = this.scoreTopEl?.clientHeight || 0;
                if (!scoreHeight) return;
                
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                const halfHeight = staffHeight / 2; // Same as scrolling motive window height
                
                // Update all static motive panels - width matches halfHeight, use relative positioning
                // Account for ScoreTop/Bottom margin (5px top, 5px bottom)
                const panels = document.querySelectorAll('.static-motive-panel');
                panels.forEach(panel => {
                    panel.style.width = `${halfHeight}px`;
                    panel.style.height = `${scoreHeight}px`;
                    panel.style.position = 'relative';
                    panel.style.marginTop = '5px'; // Match ScoreTop/Bottom top margin
                    panel.style.marginBottom = '5px'; // Match ScoreTop/Bottom bottom margin
                });
                
                // Position 4th box (track 4) so its BOTTOM aligns with panel bottom (which = ScoreTop bottom)
                // For track 4: bottom of box should be at scoreHeight
                // So top of box = scoreHeight - staffHeight
                const boxes = document.querySelectorAll('.static-motive-box');
                boxes.forEach(box => {
                    const track = parseInt(box.dataset.track);
                    // Calculate from bottom: track 4 bottom = scoreHeight, track 4 top = scoreHeight - staffHeight
                    const yPosition = scoreHeight - ((5 - track) * staffHeight);
                    
                    box.style.position = 'absolute';
                    box.style.top = `${yPosition}px`;
                    box.style.left = '0';
                    box.style.height = `${staffHeight}px`;
                    box.style.width = `${halfHeight}px`;
                });
            },
            */
            
            // Update static motive windows with upcoming motive notation
            // Each section (top/bottom) looks ahead from its own page start time
            updateStaticMotiveWindows(currentScoreTimeMs, totalPagesTraveled) {
                // DISABLED: Static motive windows removed from UI
                return;
                /*
                if (!window.MotiveMaker) return;
                
                // Get page numbers from GraphicTimeline if available
                let topPageNumber = 0;
                let bottomPageNumber = 1;
                
                if (window.GraphicTimeline) {
                    topPageNumber = GraphicTimeline.currentTopPage || 0;
                    bottomPageNumber = GraphicTimeline.currentBottomPage || 1;
                } else {
                    // Fallback calculation
                    topPageNumber = Math.floor(totalPagesTraveled / 2) * 2;
                    bottomPageNumber = topPageNumber + 1;
                }
                
                // Calculate page start times using GraphicTimeline's method or fallback
                const secondsPerPage = window.GraphicTimeline ? 
                    GraphicTimeline.getSecondsPerPage() : 
                    (60 / beatsPerMinute) * beatsPerPage;
                
                // Page start time = page number * secondsPerPage, minus lead-in for timeline position
                const topPageStartTime = (topPageNumber * secondsPerPage) - leadInSeconds;
                const bottomPageStartTime = (bottomPageNumber * secondsPerPage) - leadInSeconds;
                
                // Update each track's static windows
                for (let track = 1; track <= 4; track++) {
                    const gTrack = String(track);
                    
                    // Update top section windows (look ahead from top page start)
                    const topPanel = document.querySelector(`.static-motive-panel[data-section="top"]`);
                    const topBox = topPanel?.querySelector(`.static-motive-box[data-track="${track}"]`);
                    if (topBox) {
                        const topMotives = MotiveMaker.getNextTwoMotives(gTrack, topPageStartTime);
                        this.updateStaticWindowContent(topBox, topMotives);
                    }
                    
                    // Update bottom section windows (look ahead from bottom page start)
                    const bottomPanel = document.querySelector(`.static-motive-panel[data-section="bottom"]`);
                    const bottomBox = bottomPanel?.querySelector(`.static-motive-box[data-track="${track}"]`);
                    if (bottomBox) {
                        const bottomMotives = MotiveMaker.getNextTwoMotives(gTrack, bottomPageStartTime);
                        this.updateStaticWindowContent(bottomBox, bottomMotives);
                    }
                }
                */
            },
            
            // Update the content of static motive slots in a box
            // Top slot: current/active motive, Bottom slot: upcoming motive
            updateStaticWindowContent(box, motives) {
                // DISABLED: Static motive windows removed from UI
                return;
                /*
                const topSlot = box.querySelector('.static-motive-slot[data-slot="top"]');
                const bottomSlot = box.querySelector('.static-motive-slot[data-slot="bottom"]');
                
                if (!topSlot || !bottomSlot) return;
                
                // Top slot: current/next motive (window2Motive)
                if (motives.window2Motive && motives.window2Motive.notationSrc) {
                    let img = topSlot.querySelector('img');
                    if (!img) {
                        img = document.createElement('img');
                        topSlot.appendChild(img);
                    }
                    if (img.src !== motives.window2Motive.notationSrc) {
                        img.src = motives.window2Motive.notationSrc;
                    }
                } else {
                    const img = topSlot.querySelector('img');
                    if (img) img.remove();
                }
                
                // Bottom slot: next-after-that motive (window1Motive)
                if (motives.window1Motive && motives.window1Motive.notationSrc) {
                    let img = bottomSlot.querySelector('img');
                    if (!img) {
                        img = document.createElement('img');
                        bottomSlot.appendChild(img);
                    }
                    if (img.src !== motives.window1Motive.notationSrc) {
                        img.src = motives.window1Motive.notationSrc;
                    }
                } else {
                    const img = bottomSlot.querySelector('img');
                    if (img) img.remove();
                }
                */
            },
            
            update() {
                // Get current score time (not clock time)
                const currentScoreTimeMs = ScoreTime.now();
                
                // Calculate total pages traveled using tempo history and score time
                // 1 page = 100% of one ScoreTop or ScoreBottom width
                const totalPagesTraveled = this.calculateTotalPages(currentScoreTimeMs);
                
                // Update static motive windows (they look ahead from each page's start time)
                this.updateStaticMotiveWindows(currentScoreTimeMs, totalPagesTraveled);
                
                // Total cycle is 2 pages (top + bottom)
                // Position within cycle: 0-1 = top, 1-2 = bottom
                const positionInCycle = totalPagesTraveled % 2;
                
                // Convert to percentage (0-100%)
                let xPercent, inTop, inBottom;
                
                if (positionInCycle < 1) {
                    // In ScoreTop section
                    xPercent = positionInCycle * 100;
                    inTop = true;
                    inBottom = false;
                } else {
                    // In ScoreBottom section
                    xPercent = (positionInCycle - 1) * 100;
                    inTop = false;
                    inBottom = true;
                }
                
                // Get score width for pixel calculations
                const scoreWidth = this.scoreTopEl.clientWidth;
                const xPixel = (xPercent / 100) * scoreWidth;
                const currentSection = inTop ? 'top' : 'bottom';
                // Convert score time to display time (subtract lead-in)
                // ScoreTime starts at 0 when playback begins (during lead-in)
                // Display time 0 = first beat (after lead-in)
                const currentDisplayTimeSec = (currentScoreTimeMs / 1000) - leadInSeconds;
                
                // Update each cursor using percentage positioning
                this.cursors.forEach((cursor, staffIndex) => {
                    // Set x position as percentage
                    cursor.topEl.setAttribute('x', `${xPercent}%`);
                    cursor.bottomEl.setAttribute('x', `${xPercent}%`);
                    
                    // Show/hide based on which section is active
                    cursor.topEl.style.display = inTop ? 'block' : 'none';
                    cursor.bottomEl.style.display = inBottom ? 'block' : 'none';
                    
                    // Update curve follower for this track
                    this.updateCurveFollower(cursor, staffIndex, xPixel, xPercent, currentSection, currentDisplayTimeSec);
                    
                    // Update motive pie for this track
                    this.updateMotivePie(cursor, staffIndex, xPixel, currentSection, currentDisplayTimeSec);
                });
            },
            
            // Update motive pie dial - shows when cursor is within a motive, empties as motive progresses
            updateMotivePie(cursor, staffIndex, xPixel, section, currentTimeSec) {
                const pie = section === 'top' ? cursor.motivePieTop : cursor.motivePieBottom;
                const otherPie = section === 'top' ? cursor.motivePieBottom : cursor.motivePieTop;
                
                if (!pie || !pie.group) return;
                
                // Hide on inactive section
                if (otherPie && otherPie.group) otherPie.group.style.display = 'none';
                
                // Get gTrack for this staff
                const gTrack = String(staffIndex + 1);
                
                // Check if we're within a motive
                if (!window.MotiveMaker) {
                    pie.group.style.display = 'none';
                    return;
                }
                
                // Find active motive at current time for this track
                const motives = MotiveMaker.motives.filter(m => 
                    m.gTrack === gTrack && 
                    currentTimeSec >= m.startSeconds && 
                    currentTimeSec <= m.endSeconds
                );
                
                if (motives.length === 0) {
                    pie.group.style.display = 'none';
                    return;
                }
                
                const motive = motives[0];
                const progress = (currentTimeSec - motive.startSeconds) / (motive.endSeconds - motive.startSeconds);
                
                // Get track dimensions
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreHeight = scoreEl.clientHeight;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                const yPosition = this.timelineHeight + (staffIndex * staffHeight);
                
                // Pie size is 1/4 the staff height
                const pieSize = staffHeight / 4;
                
                // Position: left of curve meter (which is at xPixel - 11), flush with top of track
                // Curve meter is 8px wide at x = xPixel - 11
                const pieX = xPixel - 11 - pieSize - 2; // 2px gap from curve meter
                const pieY = yPosition;
                
                // Update border
                pie.border.setAttribute('x', pieX);
                pie.border.setAttribute('y', pieY);
                pie.border.setAttribute('width', pieSize);
                pie.border.setAttribute('height', pieSize);
                
                // Set pie color to motive color
                const color = ColorMap[motive.color] || motive.color;
                pie.arc.setAttribute('fill', color);
                
                // Calculate pie arc (starts full, empties clockwise)
                const centerX = pieX + pieSize / 2;
                const centerY = pieY + pieSize / 2;
                const radius = pieSize / 2 - 1;
                
                // Remaining portion (1 - progress)
                const remaining = 1 - progress;
                
                if (remaining <= 0) {
                    pie.arc.setAttribute('d', '');
                } else if (remaining >= 1) {
                    // Full circle
                    pie.arc.setAttribute('d', `M ${centerX} ${centerY} m -${radius} 0 a ${radius} ${radius} 0 1 0 ${radius * 2} 0 a ${radius} ${radius} 0 1 0 -${radius * 2} 0`);
                } else {
                    // Partial pie - empties clockwise from 12 o'clock
                    // Start edge moves clockwise as progress increases
                    const startAngle = -Math.PI / 2 + (progress * 2 * Math.PI);
                    const endAngle = -Math.PI / 2 + (2 * Math.PI); // Always ends at 12 o'clock
                    
                    const x1 = centerX + radius * Math.cos(startAngle);
                    const y1 = centerY + radius * Math.sin(startAngle);
                    const x2 = centerX + radius * Math.cos(endAngle);
                    const y2 = centerY + radius * Math.sin(endAngle);
                    
                    const largeArc = remaining > 0.5 ? 1 : 0;
                    
                    pie.arc.setAttribute('d', `M ${centerX} ${centerY} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z`);
                }
                
                // Update clock hand/wand - spins clockwise from 12 o'clock
                const handAngle = -Math.PI / 2 + (progress * 2 * Math.PI);
                const handX = centerX + radius * Math.cos(handAngle);
                const handY = centerY + radius * Math.sin(handAngle);
                pie.hand.setAttribute('x1', centerX);
                pie.hand.setAttribute('y1', centerY);
                pie.hand.setAttribute('x2', handX);
                pie.hand.setAttribute('y2', handY);
                
                pie.group.style.display = '';
            },
            
            /* DISABLED: updateMotiveFollower - motive system disabled (code kept for future reference)
            // Update motive dials based on motive intersection
            // Main dial: shows progress through the motive (empties as motive progresses)
            // Countdown dial: appears 3 seconds before motive, empties as countdown progresses
            updateMotiveFollower(cursor, staffIndex, xPixel, xPercent, section, currentTimeSec) {
                const mainDial = section === 'top' ? cursor.motiveDialTop : cursor.motiveDialBottom;
                const otherMainDial = section === 'top' ? cursor.motiveDialBottom : cursor.motiveDialTop;
                const countdownDial = section === 'top' ? cursor.countdownDialTop : cursor.countdownDialBottom;
                const otherCountdownDial = section === 'top' ? cursor.countdownDialBottom : cursor.countdownDialTop;
                
                if (!mainDial || !mainDial.group) return;
                if (!countdownDial || !countdownDial.group) return;
                
                // Hide on inactive section
                if (otherMainDial && otherMainDial.group) otherMainDial.group.style.display = 'none';
                if (otherCountdownDial && otherCountdownDial.group) otherCountdownDial.group.style.display = 'none';
                
                // Get gTrack for this staff
                const gTrack = String(staffIndex + 1);
                
                // Get track dimensions for positioning
                const scoreHeight = this.scoreTopEl.clientHeight;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                const yPosition = this.timelineHeight + (staffIndex * staffHeight);
                
                // Dial is half height (stacked vertically)
                const dialSize = staffHeight; // Full staff height for width calculations
                const halfHeight = staffHeight / 2; // Half height for each dial
                const dialRadius = (halfHeight / 2) - 1; // Radius based on half height
                const cx = halfHeight / 2; // Center X within half-height square
                const cy = halfHeight / 2; // Center Y within half-height square
                
                // Check if MotiveMaker exists
                if (!window.MotiveMaker) {
                    mainDial.group.style.display = 'none';
                    countdownDial.group.style.display = 'none';
                    cursor.currentMotiveProgress = null;
                    return;
                }
                
                // Check for active motive (cursor is within motive time range)
                const motiveInfo = MotiveMaker.getMotiveProgressAtTime(gTrack, currentTimeSec);
                
                // Check for upcoming motive (within 3 seconds) - for countdown dial animation
                const upcomingInfo = MotiveMaker.getUpcomingMotiveAtTime(gTrack, currentTimeSec, 3);
                
                // Get next upcoming motive (regardless of time) - for Scroll Window 1 notation
                const nextMotiveInfo = MotiveMaker.getNextUpcomingMotive(gTrack, currentTimeSec);
                
                // === COUNTDOWN DIAL (yellow, 3 seconds before motive) - BOTTOM of stack ===
                if (upcomingInfo && !motiveInfo) {
                    // Show countdown dial
                    countdownDial.group.style.display = 'block';
                    
                    // Update border size (half height square)
                    countdownDial.border.setAttribute('width', halfHeight);
                    countdownDial.border.setAttribute('height', halfHeight);
                    
                    // Position countdown dial at bottom of stack, overlaying notation window
                    const cursorX = (xPercent / 100) * this.scoreTopEl.clientWidth;
                    const idealCountdownX = cursorX - dialSize - 4; // Same X as notation windows
                    const countdownX = Math.max(0, idealCountdownX) + (dialSize - halfHeight) / 2; // Center within window width
                    const countdownY = yPosition + halfHeight; // Bottom half of track
                    countdownDial.group.setAttribute('transform', `translate(${countdownX}, ${countdownY})`);
                    
                    // Calculate countdown progress (0 = 3 seconds before, 1 = motive starts)
                    const countdownProgress = upcomingInfo.countdownProgress;
                    
                    // Countdown empties as it progresses (starts full, ends empty)
                    const remainingAngle = (1 - countdownProgress) * 360;
                    const angleDegrees = countdownProgress * 360;
                    const angleRadians = (angleDegrees - 90) * (Math.PI / 180);
                    const startAngle = angleDegrees - 90;
                    const endAngle = 360 - 90;
                    
                    // Create arc path for remaining pie slice
                    if (remainingAngle > 0 && remainingAngle < 360) {
                        const startRad = startAngle * (Math.PI / 180);
                        const endRad = endAngle * (Math.PI / 180);
                        const x1 = cx + dialRadius * Math.cos(startRad);
                        const y1 = cy + dialRadius * Math.sin(startRad);
                        const x2 = cx + dialRadius * Math.cos(endRad);
                        const y2 = cy + dialRadius * Math.sin(endRad);
                        const largeArc = remainingAngle > 180 ? 1 : 0;
                        countdownDial.arc.setAttribute('d', `M ${cx} ${cy} L ${x1} ${y1} A ${dialRadius} ${dialRadius} 0 ${largeArc} 1 ${x2} ${y2} Z`);
                    } else if (remainingAngle >= 360) {
                        countdownDial.arc.setAttribute('d', `M ${cx} ${cy} m -${dialRadius} 0 a ${dialRadius} ${dialRadius} 0 1 0 ${dialRadius * 2} 0 a ${dialRadius} ${dialRadius} 0 1 0 -${dialRadius * 2} 0`);
                    } else {
                        countdownDial.arc.setAttribute('d', '');
                    }
                    
                    // Update clock hand
                    const handEndX = cx + dialRadius * Math.cos(angleRadians);
                    const handEndY = cy + dialRadius * Math.sin(angleRadians);
                    countdownDial.hand.setAttribute('x1', cx);
                    countdownDial.hand.setAttribute('y1', cy);
                    countdownDial.hand.setAttribute('x2', handEndX);
                    countdownDial.hand.setAttribute('y2', handEndY);
                } else {
                    countdownDial.group.style.display = 'none';
                }
                
                // === MAIN DIAL (motive color, during motive) - TOP of stack ===
                if (motiveInfo) {
                    mainDial.group.style.display = 'block';
                    
                    // Update border size (half height square)
                    mainDial.border.setAttribute('width', halfHeight);
                    mainDial.border.setAttribute('height', halfHeight);
                    
                    // Position main dial at top of stack, overlaying notation window
                    const cursorX = (xPercent / 100) * this.scoreTopEl.clientWidth;
                    const idealDialX = cursorX - dialSize - 4; // Same X as notation windows
                    const dialX = Math.max(0, idealDialX) + (dialSize - halfHeight) / 2; // Center within window width
                    const dialY = yPosition; // Top of track
                    mainDial.group.setAttribute('transform', `translate(${dialX}, ${dialY})`);
                    
                    // Get motive color
                    const motiveColor = motiveInfo.color ? (ColorMap[motiveInfo.color] || motiveInfo.color) : this.colors[staffIndex];
                    
                    // Calculate progress (0 = start, 1 = end)
                    const progress = motiveInfo.progress;
                    const angleDegrees = progress * 360;
                    const angleRadians = (angleDegrees - 90) * (Math.PI / 180);
                    const remainingAngle = (1 - progress) * 360;
                    const startAngle = angleDegrees - 90;
                    const endAngle = 360 - 90;
                    
                    // Create arc path for remaining pie slice
                    if (remainingAngle > 0 && remainingAngle < 360) {
                        const startRad = startAngle * (Math.PI / 180);
                        const endRad = endAngle * (Math.PI / 180);
                        const x1 = cx + dialRadius * Math.cos(startRad);
                        const y1 = cy + dialRadius * Math.sin(startRad);
                        const x2 = cx + dialRadius * Math.cos(endRad);
                        const y2 = cy + dialRadius * Math.sin(endRad);
                        const largeArc = remainingAngle > 180 ? 1 : 0;
                        mainDial.arc.setAttribute('d', `M ${cx} ${cy} L ${x1} ${y1} A ${dialRadius} ${dialRadius} 0 ${largeArc} 1 ${x2} ${y2} Z`);
                        mainDial.arc.setAttribute('fill', motiveColor);
                    } else if (remainingAngle >= 360) {
                        mainDial.arc.setAttribute('d', `M ${cx} ${cy} m -${dialRadius} 0 a ${dialRadius} ${dialRadius} 0 1 0 ${dialRadius * 2} 0 a ${dialRadius} ${dialRadius} 0 1 0 -${dialRadius * 2} 0`);
                        mainDial.arc.setAttribute('fill', motiveColor);
                    } else {
                        mainDial.arc.setAttribute('d', '');
                    }
                    
                    // Update clock hand
                    const handEndX = cx + dialRadius * Math.cos(angleRadians);
                    const handEndY = cy + dialRadius * Math.sin(angleRadians);
                    mainDial.hand.setAttribute('x1', cx);
                    mainDial.hand.setAttribute('y1', cy);
                    mainDial.hand.setAttribute('x2', handEndX);
                    mainDial.hand.setAttribute('y2', handEndY);
                    
                    cursor.currentMotiveProgress = progress;
                } else {
                    mainDial.group.style.display = 'none';
                    cursor.currentMotiveProgress = null;
                }
                
                // === SCROLL WINDOWS: Stacked vertically, half height each, just left of cursor ===
                const upcomingNotation = section === 'top' ? cursor.upcomingNotationTop : cursor.upcomingNotationBottom;
                const otherUpcomingNotation = section === 'top' ? cursor.upcomingNotationBottom : cursor.upcomingNotationTop;
                const activeNotation = section === 'top' ? cursor.activeNotationTop : cursor.activeNotationBottom;
                const otherActiveNotation = section === 'top' ? cursor.activeNotationBottom : cursor.activeNotationTop;
                
                // Hide on inactive section
                if (otherUpcomingNotation && otherUpcomingNotation.group) {
                    otherUpcomingNotation.group.style.display = 'none';
                }
                if (otherActiveNotation && otherActiveNotation.group) {
                    otherActiveNotation.group.style.display = 'none';
                }
                
                // Calculate stacked window dimensions (reuse halfHeight and dialSize from above)
                const cursorX = (xPercent / 100) * this.scoreTopEl.clientWidth;
                const windowWidth = dialSize; // Same width as staff height (square when stacked)
                const idealWindowX = cursorX - windowWidth - 4; // Just left of cursor with small gap
                const windowX = Math.max(0, idealWindowX);
                
                // SCROLL WINDOW 2: Active/current notation (TOP of stack)
                if (activeNotation && activeNotation.group) {
                    if (motiveInfo && motiveInfo.notationSrc) {
                        activeNotation.group.style.display = 'block';
                        const windowY = yPosition; // Top of track
                        
                        activeNotation.group.setAttribute('transform', `translate(${windowX}, ${windowY})`);
                        activeNotation.image.setAttribute('href', motiveInfo.notationSrc);
                        activeNotation.image.setAttribute('width', windowWidth);
                        activeNotation.image.setAttribute('height', halfHeight);
                    } else {
                        activeNotation.group.style.display = 'none';
                    }
                }
                
                // SCROLL WINDOW 1: Upcoming notation (BOTTOM of stack)
                if (upcomingNotation && upcomingNotation.group) {
                    if (nextMotiveInfo && !motiveInfo && nextMotiveInfo.notationSrc) {
                        upcomingNotation.group.style.display = 'block';
                        const windowY = yPosition + halfHeight; // Bottom half of track
                        
                        upcomingNotation.group.setAttribute('transform', `translate(${windowX}, ${windowY})`);
                        upcomingNotation.image.setAttribute('href', nextMotiveInfo.notationSrc);
                        upcomingNotation.image.setAttribute('width', windowWidth);
                        upcomingNotation.image.setAttribute('height', halfHeight);
                    } else {
                        upcomingNotation.group.style.display = 'none';
                    }
                }
            },
            /* END OF DISABLED updateMotiveFollower */
            
            // Update curve follower rectangle based on curve intersection
            // TIMECODE-BASED SYSTEM: O(1) lookup using time-indexed samples
            updateCurveFollower(cursor, staffIndex, xPixel, xPercent, section, currentTimeSec) {
                const follower = section === 'top' ? cursor.curveFollowerTop : cursor.curveFollowerBottom;
                const otherFollower = section === 'top' ? cursor.curveFollowerBottom : cursor.curveFollowerTop;
                const meterOutline = section === 'top' ? cursor.meterOutlineTop : cursor.meterOutlineBottom;
                const otherMeterOutline = section === 'top' ? cursor.meterOutlineBottom : cursor.meterOutlineTop;
                
                // Hide the follower and meter on the inactive section
                otherFollower.style.display = 'none';
                otherMeterOutline.style.display = 'none';
                
                // Check if there's a curve at this position for this track
                const gTrack = window.GTrackSystem ? GTrackSystem.getGTrack(staffIndex) : null;
                if (!gTrack) {
                    follower.style.display = 'none';
                    meterOutline.style.display = 'none';
                    cursor.currentCurveValue = null;
                    return;
                }
                
                // Find curve that contains current time and get O(1) sample lookup
                let foundCurve = null;
                let normalizedY = null;
                
                for (const item of gTrack.graphicItems) {
                    if (item.type !== 'curve' || !item.curveData) continue;
                    
                    const { startTime, endTime, sampleInterval, samples } = item.curveData;
                    
                    // Check if current time is within curve's time range
                    if (currentTimeSec >= startTime && currentTimeSec <= endTime) {
                        // O(1) lookup: calculate array index from time
                        const timeOffset = currentTimeSec - startTime;
                        const sampleIndex = Math.floor(timeOffset / sampleInterval);
                        
                        if (sampleIndex >= 0 && sampleIndex < samples.length) {
                            foundCurve = item;
                            normalizedY = samples[sampleIndex];
                            break;
                        }
                    }
                }
                
                if (!foundCurve || normalizedY === null) {
                    follower.style.display = 'none';
                    meterOutline.style.display = 'none';
                    cursor.currentCurveValue = null;
                    return;
                }
                
                // Show and position the meter outline (full height empty rectangle)
                meterOutline.style.display = 'block';
                meterOutline.setAttribute('x', `calc(${xPercent}% - 11px)`);
                
                // Show and position the curve follower (fill inside meter)
                follower.style.display = 'block';
                follower.setAttribute('x', `calc(${xPercent}% - 11px)`);
                
                // Get track dimensions for fill calculation
                const scoreHeight = this.scoreTopEl.clientHeight;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                const yPosition = this.timelineHeight + (staffIndex * staffHeight);
                
                // Calculate fill based on normalized Y value and fill mode
                // normalizedY: 0 = bottom, 1 = top
                const curveColor = foundCurve.color ? (ColorMap[foundCurve.color] || foundCurve.color) : this.colors[staffIndex];
                const fillMode = foundCurve.fillMode || 'line';
                
                let fillY, fillHeight;
                if (fillMode === 'top') {
                    // Fill from top down to curve value (inverse of bottom fill)
                    // When normalizedY = 1, fill is 0 (curve at top, no fill above)
                    // When normalizedY = 0, fill is full height (curve at bottom, fill entire top)
                    fillHeight = (1 - normalizedY) * staffHeight;
                    fillY = yPosition; // Start from top
                } else {
                    // Fill from bottom up to curve value (default behavior)
                    fillHeight = normalizedY * staffHeight;
                    fillY = yPosition + staffHeight - fillHeight;
                }
                
                // Update follower to show fill
                follower.setAttribute('y', fillY);
                follower.setAttribute('height', fillHeight);
                follower.setAttribute('fill', curveColor);
                
                // Update meter outline to match curve color
                meterOutline.setAttribute('stroke', curveColor);
                
                // Store current curve value for external use
                cursor.currentCurveValue = normalizedY;
            },
            
            // Get current position info for a specific staff (returns percentage)
            getPosition(staffIndex) {
                if (staffIndex >= 0 && staffIndex < this.cursors.length) {
                    const cursor = this.cursors[staffIndex];
                    const xAttr = cursor.topEl.getAttribute('x');
                    // Parse percentage value
                    const xPercent = parseFloat(xAttr.replace('%', ''));
                    return {
                        xPercent: xPercent,
                        section: cursor.topEl.style.display !== 'none' ? 'top' : 'bottom'
                    };
                }
                return null;
            }
        };
        
        // Initialize staff cursors after DOM is ready
        StaffCursors.init();
        window.StaffCursors = StaffCursors;
        
        // Initialize SVG Element Manager
        SVGElementManager.init();
        window.SVGElementManager = SVGElementManager;
        
        // Initialize Flowchart Connector
        FlowchartConnector.init();
        window.FlowchartConnector = FlowchartConnector;
        
        // Score Zoom System with Pan
        const ScoreZoom = {
            zoomLevel: 100,
            minZoom: 50,
            maxZoom: 500,
            zoomStep: 10,
            panX: 0,
            panY: 0,
            isPanning: false,
            panStartX: 0,
            panStartY: 0,
            panStartPanX: 0,
            panStartPanY: 0,
            
            init() {
                this.slider = document.getElementById('scoreZoomSlider');
                this.valueDisplay = document.getElementById('scoreZoomValue');
                this.scoreContainer = document.getElementById('ScoreContainer');
                this.resetBtn = document.getElementById('zoomResetBtn');
                
                // Slider event
                this.slider.addEventListener('input', () => {
                    this.setZoom(parseInt(this.slider.value));
                });
                
                // Double-click slider to reset to 100%
                this.slider.addEventListener('dblclick', () => {
                    this.resetZoom();
                });
                
                // Reset button
                if (this.resetBtn) {
                    this.resetBtn.addEventListener('click', () => this.resetZoom());
                }
                
                // Keyboard shortcut: press 0 to reset zoom (when not in input field)
                document.addEventListener('keydown', (e) => {
                    if (e.key === '0' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                        const activeEl = document.activeElement;
                        const isInput = activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable;
                        if (!isInput) {
                            e.preventDefault();
                            this.resetZoom();
                        }
                    }
                });
                
                // Ctrl + Alt + scroll wheel zoom (avoid browser zoom conflict)
                this.scoreContainer.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
                
                // Middle mouse button or Alt+left click to pan
                this.scoreContainer.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                // Double-click to reset pan
                this.scoreContainer.addEventListener('dblclick', (e) => {
                    if (e.altKey) {
                        this.resetPan();
                    }
                });
                
                console.log('ScoreZoom initialized (Ctrl+Alt+scroll to zoom, Alt+drag or middle-click drag to pan, Alt+double-click to reset pan, 0 key or double-click slider to reset zoom)');
            },
            
            handleWheel(e) {
                // Require both Ctrl and Alt to avoid browser zoom conflict
                if (!e.ctrlKey || !e.altKey) return;
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? -this.zoomStep : this.zoomStep;
                const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoomLevel + delta));
                this.setZoom(newZoom);
            },
            
            handleMouseDown(e) {
                // Alt + left click OR middle mouse button to pan
                if ((e.altKey && e.button === 0) || e.button === 1) {
                    e.preventDefault();
                    this.isPanning = true;
                    this.panStartX = e.clientX;
                    this.panStartY = e.clientY;
                    this.panStartPanX = this.panX;
                    this.panStartPanY = this.panY;
                    this.scoreContainer.style.cursor = 'grabbing';
                }
            },
            
            handleMouseMove(e) {
                if (!this.isPanning) return;
                
                const dx = e.clientX - this.panStartX;
                const dy = e.clientY - this.panStartY;
                
                this.panX = this.panStartPanX + dx;
                this.panY = this.panStartPanY + dy;
                
                this.applyTransform();
            },
            
            handleMouseUp(e) {
                if (this.isPanning) {
                    this.isPanning = false;
                    this.scoreContainer.style.cursor = '';
                }
            },
            
            resetPan() {
                this.panX = 0;
                this.panY = 0;
                this.applyTransform();
            },
            
            resetZoom() {
                this.setZoom(100);
            },
            
            setZoom(level) {
                this.zoomLevel = level;
                this.slider.value = level;
                this.valueDisplay.textContent = level + '%';
                this.applyTransform();
            },
            
            applyTransform() {
                const scale = this.zoomLevel / 100;
                this.scoreContainer.style.transformOrigin = 'center center';
                this.scoreContainer.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${scale})`;
            },
            
            getZoom() {
                return this.zoomLevel / 100;
            }
        };
        
        ScoreZoom.init();
        window.ScoreZoom = ScoreZoom;
        
        // Track System - Four tracks with SVG containers, MIDI files, and graphic data
        // Each track syncs to score time code but has independent MIDI and graphic content
        const TrackSystem = {
            tracks: [],            // Array of 4 track objects
            scoreTopEl: null,
            scoreBottomEl: null,
            timelineHeight: 24,    // Same as StaffCursors
            initialized: false,
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Create 4 tracks
                for (let i = 0; i < 4; i++) {
                    const track = this.createTrack(i);
                    this.tracks.push(track);
                }
                
                // Hook into animation for updates
                const originalOnDraw = AnimationEngine.onDraw;
                AnimationEngine.onDraw = (frameNumber, elapsedMs) => {
                    if (originalOnDraw) originalOnDraw(frameNumber, elapsedMs);
                    this.update();
                };
                
                // Update track dimensions on resize
                window.addEventListener('resize', () => {
                    this.updateTrackDimensions();
                });
                
                this.initialized = true;
                console.log('TrackSystem initialized with 4 tracks');
            },
            
            createTrack(trackIndex) {
                // Calculate track dimensions (same as cursor/staff dimensions)
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                const availableHeight = scoreHeight - this.timelineHeight;
                const trackHeight = availableHeight / 4;
                const yPosition = this.timelineHeight + (trackIndex * trackHeight);
                
                // Create SVG group containers for ScoreTop and ScoreBottom
                const topContainer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                const bottomContainer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                // Set container attributes
                topContainer.setAttribute('id', `track${trackIndex + 1}-top`);
                topContainer.setAttribute('class', 'track-container');
                bottomContainer.setAttribute('id', `track${trackIndex + 1}-bottom`);
                bottomContainer.setAttribute('class', 'track-container');
                
                // Create clipping rectangles to constrain content to track area
                const clipIdTop = `track${trackIndex + 1}-clip-top`;
                const clipIdBottom = `track${trackIndex + 1}-clip-bottom`;
                
                // Create clip paths
                const clipPathTop = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                clipPathTop.setAttribute('id', clipIdTop);
                const clipRectTop = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                clipRectTop.setAttribute('x', '0');
                clipRectTop.setAttribute('y', yPosition);
                clipRectTop.setAttribute('width', '100%');
                clipRectTop.setAttribute('height', trackHeight);
                clipPathTop.appendChild(clipRectTop);
                
                const clipPathBottom = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                clipPathBottom.setAttribute('id', clipIdBottom);
                const clipRectBottom = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                clipRectBottom.setAttribute('x', '0');
                clipRectBottom.setAttribute('y', yPosition);
                clipRectBottom.setAttribute('width', '100%');
                clipRectBottom.setAttribute('height', trackHeight);
                clipPathBottom.appendChild(clipRectBottom);
                
                // Add defs for clip paths if not exists
                let defsTop = this.scoreTopEl.querySelector('defs');
                if (!defsTop) {
                    defsTop = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    this.scoreTopEl.insertBefore(defsTop, this.scoreTopEl.firstChild);
                }
                defsTop.appendChild(clipPathTop);
                
                let defsBottom = this.scoreBottomEl.querySelector('defs');
                if (!defsBottom) {
                    defsBottom = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    this.scoreBottomEl.insertBefore(defsBottom, this.scoreBottomEl.firstChild);
                }
                defsBottom.appendChild(clipPathBottom);
                
                // Apply clip paths to containers
                topContainer.setAttribute('clip-path', `url(#${clipIdTop})`);
                bottomContainer.setAttribute('clip-path', `url(#${clipIdBottom})`);
                
                // Add containers to SVG elements (insert before cursors so cursors render on top)
                this.scoreTopEl.insertBefore(topContainer, this.scoreTopEl.firstChild.nextSibling);
                this.scoreBottomEl.insertBefore(bottomContainer, this.scoreBottomEl.firstChild.nextSibling);
                
                // Create track object with MIDI and graphic data structures
                return {
                    index: trackIndex,
                    name: `Track ${trackIndex + 1}`,
                    
                    // SVG containers
                    topContainer: topContainer,
                    bottomContainer: bottomContainer,
                    clipRectTop: clipRectTop,
                    clipRectBottom: clipRectBottom,
                    
                    // Dimensions
                    yPosition: yPosition,
                    height: trackHeight,
                    width: scoreWidth,
                    
                    // MIDI data - array of MIDI events
                    // Each event: { scoreTimeMs, type, note, velocity, duration, channel }
                    midiEvents: [],
                    
                    // Graphic items - array of graphic elements to render
                    // Each item: { scoreTimeMs, duration, type, x, y, width, height, color, data }
                    graphicItems: [],
                    
                    // Currently rendered graphic elements (for cleanup)
                    renderedElements: {
                        top: [],
                        bottom: []
                    },
                    
                    // Current page tracking for this track
                    currentTopPage: 0,
                    currentBottomPage: 1
                };
            },
            
            // Update track dimensions on resize
            updateTrackDimensions() {
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                const availableHeight = scoreHeight - this.timelineHeight;
                const trackHeight = availableHeight / 4;
                
                this.tracks.forEach((track, trackIndex) => {
                    const yPosition = this.timelineHeight + (trackIndex * trackHeight);
                    
                    track.yPosition = yPosition;
                    track.height = trackHeight;
                    track.width = scoreWidth;
                    
                    // Update clip rectangles
                    track.clipRectTop.setAttribute('y', yPosition);
                    track.clipRectTop.setAttribute('height', trackHeight);
                    track.clipRectBottom.setAttribute('y', yPosition);
                    track.clipRectBottom.setAttribute('height', trackHeight);
                });
                
                // Re-render all tracks
                this.renderAllTracks();
            },
            
            // Load MIDI events for a track
            loadMidiEvents(trackIndex, midiEvents) {
                if (trackIndex >= 0 && trackIndex < this.tracks.length) {
                    this.tracks[trackIndex].midiEvents = midiEvents;
                    console.log(`Track ${trackIndex + 1}: Loaded ${midiEvents.length} MIDI events`);
                }
            },
            
            // Load graphic items for a track
            loadGraphicItems(trackIndex, graphicItems) {
                if (trackIndex >= 0 && trackIndex < this.tracks.length) {
                    this.tracks[trackIndex].graphicItems = graphicItems;
                    console.log(`Track ${trackIndex + 1}: Loaded ${graphicItems.length} graphic items`);
                    this.renderTrack(trackIndex);
                }
            },
            
            // Get MIDI events at a specific score time for a track
            getMidiEventsAtTime(trackIndex, scoreTimeMs, windowMs = 0) {
                if (trackIndex < 0 || trackIndex >= this.tracks.length) return [];
                
                const track = this.tracks[trackIndex];
                return track.midiEvents.filter(event => {
                    if (windowMs === 0) {
                        return event.scoreTimeMs === scoreTimeMs;
                    }
                    return event.scoreTimeMs >= scoreTimeMs - windowMs && 
                           event.scoreTimeMs <= scoreTimeMs + windowMs;
                });
            },
            
            // Get graphic items visible in current page for a track
            getVisibleGraphicItems(trackIndex, section) {
                if (trackIndex < 0 || trackIndex >= this.tracks.length) return [];
                
                const track = this.tracks[trackIndex];
                const pageNumber = section === 'top' ? track.currentTopPage : track.currentBottomPage;
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const pageStartMs = pageNumber * secondsPerPage * 1000;
                const pageEndMs = (pageNumber + 1) * secondsPerPage * 1000;
                
                return track.graphicItems.filter(item => {
                    const itemEndMs = item.scoreTimeMs + (item.duration || 0);
                    return item.scoreTimeMs < pageEndMs && itemEndMs >= pageStartMs;
                });
            },
            
            // Render a single track
            renderTrack(trackIndex) {
                if (trackIndex < 0 || trackIndex >= this.tracks.length) return;
                
                const track = this.tracks[trackIndex];
                
                // Clear existing rendered elements
                track.renderedElements.top.forEach(el => el.remove());
                track.renderedElements.bottom.forEach(el => el.remove());
                track.renderedElements.top = [];
                track.renderedElements.bottom = [];
                
                // Render for both sections
                this.renderTrackSection(trackIndex, 'top');
                this.renderTrackSection(trackIndex, 'bottom');
            },
            
            // Render track content for a specific section
            renderTrackSection(trackIndex, section) {
                const track = this.tracks[trackIndex];
                const container = section === 'top' ? track.topContainer : track.bottomContainer;
                const visibleItems = this.getVisibleGraphicItems(trackIndex, section);
                const pageNumber = section === 'top' ? track.currentTopPage : track.currentBottomPage;
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const pageStartMs = pageNumber * secondsPerPage * 1000;
                
                visibleItems.forEach(item => {
                    // Calculate x position as percentage based on score time
                    const itemOffsetMs = item.scoreTimeMs - pageStartMs;
                    const xPercent = (itemOffsetMs / (secondsPerPage * 1000)) * 100;
                    
                    // Create graphic element based on type
                    let element;
                    switch (item.type) {
                        case 'rect':
                            element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            element.setAttribute('x', `${xPercent}%`);
                            element.setAttribute('y', track.yPosition + (item.y || 0));
                            element.setAttribute('width', item.width || 10);
                            element.setAttribute('height', item.height || track.height);
                            element.setAttribute('fill', item.color || '#666');
                            break;
                        case 'line':
                            element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            element.setAttribute('x1', `${xPercent}%`);
                            element.setAttribute('y1', track.yPosition + (item.y1 || 0));
                            element.setAttribute('x2', `${xPercent + (item.widthPercent || 0)}%`);
                            element.setAttribute('y2', track.yPosition + (item.y2 || track.height));
                            element.setAttribute('stroke', item.color || '#666');
                            element.setAttribute('stroke-width', item.strokeWidth || 1);
                            break;
                        case 'text':
                            element = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            element.setAttribute('x', `${xPercent}%`);
                            element.setAttribute('y', track.yPosition + (item.y || track.height / 2));
                            element.setAttribute('font-size', item.fontSize || 10);
                            element.setAttribute('fill', item.color || '#333');
                            element.textContent = item.text || '';
                            break;
                        case 'note':
                            // MIDI note visualization - horizontal bar
                            element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            const noteHeight = track.height / 128; // 128 MIDI notes
                            const noteY = track.yPosition + track.height - ((item.note || 60) * noteHeight);
                            const durationPercent = ((item.duration || 100) / (secondsPerPage * 1000)) * 100;
                            element.setAttribute('x', `${xPercent}%`);
                            element.setAttribute('y', noteY);
                            element.setAttribute('width', `${durationPercent}%`);
                            element.setAttribute('height', noteHeight * 2);
                            element.setAttribute('fill', item.color || StaffCursors.colors[trackIndex]);
                            element.setAttribute('opacity', (item.velocity || 100) / 127);
                            break;
                        default:
                            return; // Unknown type, skip
                    }
                    
                    if (element) {
                        container.appendChild(element);
                        track.renderedElements[section].push(element);
                    }
                });
            },
            
            // Render all tracks
            renderAllTracks() {
                this.tracks.forEach((track, index) => {
                    this.renderTrack(index);
                });
            },
            
            // Update method called each frame
            update() {
                const currentScoreTimeMs = ScoreTime.now();
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                // Check for page changes on each track
                this.tracks.forEach((track, trackIndex) => {
                    const currentPage = Math.floor(currentScoreTimeMs / (secondsPerPage * 1000));
                    const cursorSection = currentPage % 2 === 0 ? 'top' : 'bottom';
                    
                    // Update page numbers if cursor moved to new section
                    if (cursorSection === 'bottom' && track.currentTopPage === currentPage - 1) {
                        // Cursor moved to bottom, update top to next even page
                        track.currentTopPage = currentPage + 1;
                        this.renderTrackSection(trackIndex, 'top');
                    } else if (cursorSection === 'top' && track.currentBottomPage === currentPage - 1) {
                        // Cursor moved to top, update bottom to next odd page
                        track.currentBottomPage = currentPage + 1;
                        this.renderTrackSection(trackIndex, 'bottom');
                    }
                });
            },
            
            // Reset all tracks to beginning
            reset() {
                this.tracks.forEach(track => {
                    track.currentTopPage = 0;
                    track.currentBottomPage = 1;
                });
                this.renderAllTracks();
            },
            
            // Called when goto is triggered
            onGoto(targetSeconds) {
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const targetPage = Math.floor(targetSeconds / secondsPerPage);
                
                // Always show the target page and the NEXT page (future), not the previous page
                this.tracks.forEach(track => {
                    if (targetPage % 2 === 0) {
                        // Target is on an even page (top section)
                        track.currentTopPage = targetPage;
                        track.currentBottomPage = targetPage + 1;  // Show future page
                    } else {
                        // Target is on an odd page (bottom section)
                        track.currentBottomPage = targetPage;
                        track.currentTopPage = targetPage + 1;  // Show future page
                    }
                });
                this.renderAllTracks();
            },
            
            // Get track by index
            getTrack(trackIndex) {
                if (trackIndex >= 0 && trackIndex < this.tracks.length) {
                    return this.tracks[trackIndex];
                }
                return null;
            }
        };
        
        // Initialize track system after DOM is ready
        TrackSystem.init();
        window.TrackSystem = TrackSystem;
        
        // Graphic Timeline System - Visual timeline at the top of ScoreTop and ScoreBottom
        // Dots at y=0 for each second, 3px lines for every 5th second, Lato 7pt labels for 5th seconds
        // Uses percentage-based positioning so all clients see identical graphics regardless of window size
        const GraphicTimeline = {
            scoreTopEl: null,
            scoreBottomEl: null,
            topGroup: null,
            bottomGroup: null,
            currentTopPage: 0,
            currentBottomPage: 1,
            lastCursorSection: 'top',
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Create groups for timeline graphics
                this.topGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.bottomGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.topGroup.setAttribute('class', 'graphic-timeline');
                this.bottomGroup.setAttribute('class', 'graphic-timeline');
                
                this.scoreTopEl.appendChild(this.topGroup);
                this.scoreBottomEl.appendChild(this.bottomGroup);
                
                // Create clickable areas for timeline (invisible rectangles)
                this.createClickableArea('top');
                this.createClickableArea('bottom');
                
                // Initial render
                this.renderTicks();
                
                // Hook into animation to check for page changes
                const originalOnDraw = AnimationEngine.onDraw;
                AnimationEngine.onDraw = (frameNumber, elapsedMs) => {
                    if (originalOnDraw) originalOnDraw(frameNumber, elapsedMs);
                    this.checkPageChange();
                };
                
                // Refresh on window resize
                window.addEventListener('resize', () => {
                    this.renderTicks();
                    this.updateClickableAreas();
                });
            },
            
            createClickableArea(section) {
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const clickArea = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                clickArea.setAttribute('x', '0');
                clickArea.setAttribute('y', '0');
                clickArea.setAttribute('width', '100%');
                clickArea.setAttribute('height', '20');
                clickArea.setAttribute('fill', 'transparent');
                clickArea.setAttribute('cursor', 'pointer');
                
                clickArea.addEventListener('click', (e) => this.onTimelineClick(e, section));
                
                scoreEl.appendChild(clickArea);
                
                if (section === 'top') {
                    this.topClickArea = clickArea;
                } else {
                    this.bottomClickArea = clickArea;
                }
            },
            
            updateClickableAreas() {
                // Click areas use 100% width so no update needed for width
            },
            
            onTimelineClick(e, section) {
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const rect = scoreEl.getBoundingClientRect();
                const xPercent = ((e.clientX - rect.left) / rect.width) * 100;
                
                // Get the page number for this section
                const pageNumber = section === 'top' ? this.currentTopPage : this.currentBottomPage;
                const secondsPerPage = this.getSecondsPerPage();
                
                // Calculate the seconds position
                const seconds = (pageNumber + xPercent / 100) * secondsPerPage - leadInSeconds;
                
                // Jump edit cursor to this position
                if (window.EditCursor) {
                    EditCursor.setPositionSeconds(seconds);
                }
            },
            
            // Calculate seconds per page based on tempo
            getSecondsPerPage() {
                return (beatsPerPage / beatsPerMinute) * 60;
            },
            
            // Get the starting second for a given page
            getPageStartSecond(pageNumber) {
                return pageNumber * this.getSecondsPerPage();
            },
            
            renderTicks() {
                this.renderTicksForSection('top');
                this.renderTicksForSection('bottom');
            },
            
            renderTicksForSection(section) {
                const group = section === 'top' ? this.topGroup : this.bottomGroup;
                const pageNumber = section === 'top' ? this.currentTopPage : this.currentBottomPage;
                
                // Clear existing graphics
                while (group.firstChild) {
                    group.removeChild(group.firstChild);
                }
                
                const secondsPerPage = this.getSecondsPerPage();
                const rawStartSecond = this.getPageStartSecond(pageNumber);
                const startSecond = rawStartSecond - leadInSeconds;
                const endSecond = startSecond + secondsPerPage;
                
                // Render graphics for each second
                for (let sec = Math.floor(startSecond); sec <= Math.ceil(endSecond); sec++) {
                    const adjustedSec = sec + leadInSeconds;
                    const xPercent = ((adjustedSec - rawStartSecond) / secondsPerPage) * 100;
                    
                    if (xPercent < 0 || xPercent > 100) continue;
                    
                    const isFifthSecond = sec % 5 === 0;
                    const isLeadIn = sec < 0;
                    const color = isLeadIn ? '#cc3333' : '#333';
                    
                    if (isFifthSecond) {
                        // 5th second: 3px vertical line, 1px width
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', `${xPercent}%`);
                        line.setAttribute('y1', '0');
                        line.setAttribute('x2', `${xPercent}%`);
                        line.setAttribute('y2', '3');
                        line.setAttribute('stroke', color);
                        line.setAttribute('stroke-width', '1');
                        group.appendChild(line);
                        
                        // Label for 5th second - Lato font, 7pt
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        label.setAttribute('x', `${xPercent}%`);
                        label.setAttribute('y', '10');
                        label.setAttribute('font-family', 'Lato, sans-serif');
                        label.setAttribute('font-size', '7');
                        label.setAttribute('fill', color);
                        
                        // Adjust text-anchor based on position
                        let textAnchor = 'middle';
                        if (xPercent < 3) {
                            textAnchor = 'start';
                        } else if (xPercent > 97) {
                            textAnchor = 'end';
                        }
                        label.setAttribute('text-anchor', textAnchor);
                        label.textContent = sec.toString();
                        group.appendChild(label);
                    } else {
                        // Non-5th second: small dot at y=0
                        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        dot.setAttribute('cx', `${xPercent}%`);
                        dot.setAttribute('cy', '1');
                        dot.setAttribute('r', '1');
                        dot.setAttribute('fill', color);
                        group.appendChild(dot);
                    }
                }
            },
            
            checkPageChange() {
                const position = StaffCursors.getPosition(0);
                if (!position) return;
                
                const cursorSection = position.section;
                
                // Only check for section changes during normal playback
                if (cursorSection !== this.lastCursorSection) {
                    if (cursorSection === 'bottom' && this.lastCursorSection === 'top') {
                        this.currentTopPage = this.currentTopPage + 2;
                        this.renderTicksForSection('top');
                    } else if (cursorSection === 'top' && this.lastCursorSection === 'bottom') {
                        this.currentBottomPage = this.currentBottomPage + 2;
                        this.renderTicksForSection('bottom');
                    }
                    this.lastCursorSection = cursorSection;
                    
                    // Update visibility of graphic objects
                    this.updateGraphicObjectsVisibility();
                }
            },
            
            // Update visibility of all graphic objects (SVGs, curves, connectors, motives)
            updateGraphicObjectsVisibility() {
                if (window.SVGElementManager) SVGElementManager.updateVisibility();
                if (window.CurveMaker) CurveMaker.updateVisibility();
                if (window.MotiveMaker) MotiveMaker.updateVisibility();
                if (window.FlowchartConnector) FlowchartConnector.updateVisibility();
                if (window.MidiController) MidiController.updateMidiDisplayVisibility();
                
                // Show staff headers only on page 0 (top) or page 1 (bottom)
                if (window.StaffCursors && StaffCursors.staffHeaderGroup) {
                    const showHeaders = this.currentTopPage === 0;
                    StaffCursors.staffHeaderGroup.style.display = showHeaders ? '' : 'none';
                }
            },
            
            reset() {
                this.currentTopPage = 0;
                this.currentBottomPage = 1;
                this.lastCursorSection = 'top';
                this.renderTicks();
                this.updateGraphicObjectsVisibility();
            },
            
            onGoto(targetSeconds) {
                const secondsPerPage = this.getSecondsPerPage();
                const targetPage = Math.floor(targetSeconds / secondsPerPage);
                
                // Always show the target page and the NEXT page (future), not the previous page
                if (targetPage % 2 === 0) {
                    // Target is on an even page (top section)
                    this.currentTopPage = targetPage;
                    this.currentBottomPage = targetPage + 1;  // Show future page
                    this.lastCursorSection = 'top';
                } else {
                    // Target is on an odd page (bottom section)
                    this.currentBottomPage = targetPage;
                    this.currentTopPage = targetPage + 1;  // Show future page
                    this.lastCursorSection = 'bottom';
                }
                this.renderTicks();
                this.updateGraphicObjectsVisibility();
            }
        };
        
        // Initialize graphic timeline
        GraphicTimeline.init();
        window.GraphicTimeline = GraphicTimeline;
        
        // MIDI Controller System - Multi-track MIDI file management and cursor-synced playback
        const MidiController = {
            // Device elements
            inputSelect: null,
            outputSelect: null,
            refreshBtn: null,
            
            // File elements
            loadBtn: null,
            fileInput: null,
            downloadBtn: null,
            exportCsvBtn: null,
            insertBtn: null,
            insertTimeDisplay: null,
            fileNameDisplay: null,
            
            // Display elements
            timecodeDisplay: null,
            eventCountDisplay: null,
            showGraphicItemsToggle: null,
            showMidiDisplayToggle: null,
            ccDisplaySelect: null,
            
            // Selected CC for display (default CC7)
            selectedCC: 7,
            
            // CC name mapping
            ccNames: {
                0: 'Bank Select',
                1: 'Modulation',
                5: 'Portamento Time',
                7: 'Main Volume',
                10: 'Pan',
                11: 'Expression',
                120: 'All Sound Off',
                123: 'All Notes Off'
            },
            
            // Track enable checkboxes
            trackEnables: [null, null, null, null],
            
            // MIDI state
            midiAccess: null,
            selectedInput: null,
            selectedOutput: null,
            
            // Track selection (1-4)
            selectedTrack: 1,
            
            // MIDI data per track (4 tracks)
            // Each track: { midiEvents: [], channel: trackIndex+1 }
            tracks: [
                { midiEvents: [], channel: 1 },
                { midiEvents: [], channel: 2 },
                { midiEvents: [], channel: 3 },
                { midiEvents: [], channel: 4 }
            ],
            
            // Loaded MIDI file data (temporary before insert)
            loadedFileEvents: [],
            loadedFileName: '',
            
            // Playback state - synced to graphic cursors
            lastPlaybackTimeMs: [0, 0, 0, 0], // Per-track last processed time
            currentEventIndices: [0, 0, 0, 0], // Per-track playback position
            
            // MIDI Display SVG layers
            midiDisplayLayers: { top: [], bottom: [] }, // Per track SVG groups
            scoreTopEl: null,
            scoreBottomEl: null,
            timelineHeight: 8, // Match StaffCursors.timelineHeight
            
            init() {
                // Get SVG elements
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Get device elements
                this.inputSelect = document.getElementById('midiInputSelect');
                this.outputSelect = document.getElementById('midiOutputSelect');
                this.refreshBtn = document.getElementById('midiRefreshBtn');
                
                // Get file elements
                this.loadBtn = document.getElementById('midiLoadBtn');
                this.fileInput = document.getElementById('midiFileInput');
                this.downloadBtn = document.getElementById('midiDownloadBtn');
                this.exportCsvBtn = document.getElementById('midiExportCsvBtn');
                this.insertBtn = document.getElementById('midiInsertBtn');
                this.insertTimeDisplay = document.getElementById('midiInsertTime');
                this.fileNameDisplay = document.getElementById('midiFileName');
                
                // Get display elements
                this.timecodeDisplay = document.getElementById('midiTimecode');
                this.eventCountDisplay = document.getElementById('midiEventCount');
                this.showGraphicItemsToggle = document.getElementById('showGraphicItems');
                this.showMidiDisplayToggle = document.getElementById('showMidiDisplay');
                this.ccDisplaySelect = document.getElementById('ccDisplaySelect');
                
                // Get track enable checkboxes
                this.trackEnables = [
                    document.getElementById('midiEnableT1'),
                    document.getElementById('midiEnableT2'),
                    document.getElementById('midiEnableT3'),
                    document.getElementById('midiEnableT4')
                ];
                
                // Set up track selection radio buttons
                document.querySelectorAll('input[name="midiTrack"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.selectedTrack = parseInt(e.target.value);
                        this.updateEventCount();
                    });
                });
                
                // Set up event listeners
                if (this.refreshBtn) this.refreshBtn.addEventListener('click', () => this.refreshDevices());
                if (this.inputSelect) this.inputSelect.addEventListener('change', (e) => this.selectInput(e.target.value));
                if (this.outputSelect) this.outputSelect.addEventListener('change', (e) => this.selectOutput(e.target.value));
                
                if (this.loadBtn) this.loadBtn.addEventListener('click', () => this.fileInput.click());
                if (this.fileInput) this.fileInput.addEventListener('change', (e) => this.loadMidiFile(e));
                if (this.downloadBtn) this.downloadBtn.addEventListener('click', () => this.downloadMidiFile());
                if (this.exportCsvBtn) this.exportCsvBtn.addEventListener('click', () => this.exportCsv());
                if (this.insertBtn) this.insertBtn.addEventListener('click', () => this.insertAtEditCursor());
                
                // Set up display toggle listeners
                if (this.showGraphicItemsToggle) {
                    this.showGraphicItemsToggle.addEventListener('change', () => this.updateGraphicItemsVisibility());
                }
                if (this.showMidiDisplayToggle) {
                    this.showMidiDisplayToggle.addEventListener('change', () => this.updateMidiDisplayVisibility());
                }
                if (this.ccDisplaySelect) {
                    this.ccDisplaySelect.addEventListener('change', (e) => {
                        this.selectedCC = parseInt(e.target.value);
                        this.renderAllMidiDisplays();
                    });
                }
                
                // Create MIDI display layers for each track
                this.createMidiDisplayLayers();
                
                // Initialize Web MIDI API
                this.initMidi();
                
                // Hook into animation for timecode updates, insert time sync, and cursor-synced playback
                const originalOnDraw = AnimationEngine.onDraw;
                AnimationEngine.onDraw = (frameNumber, elapsedMs) => {
                    if (originalOnDraw) originalOnDraw(frameNumber, elapsedMs);
                    this.updateTimecode();
                    this.updateInsertTime();
                    this.processCursorSyncedPlayback();
                };
                
                // Add resize handler to re-render MIDI display
                window.addEventListener('resize', () => {
                    this.renderAllMidiDisplays();
                });
                
                console.log('MidiController initialized with cursor-synced playback');
            },
            
            // Create SVG layers for MIDI display per track
            createMidiDisplayLayers() {
                if (!this.scoreTopEl || !this.scoreBottomEl) return;
                for (let trackIndex = 0; trackIndex < 4; trackIndex++) {
                    // Create groups for top and bottom score sections
                    const topGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    const bottomGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    
                    topGroup.setAttribute('id', `midi-display-t${trackIndex + 1}-top`);
                    topGroup.setAttribute('class', 'midi-display-layer');
                    bottomGroup.setAttribute('id', `midi-display-t${trackIndex + 1}-bottom`);
                    bottomGroup.setAttribute('class', 'midi-display-layer');
                    
                    this.scoreTopEl.appendChild(topGroup);
                    this.scoreBottomEl.appendChild(bottomGroup);
                    
                    this.midiDisplayLayers.top.push(topGroup);
                    this.midiDisplayLayers.bottom.push(bottomGroup);
                }
            },
            
            // Update visibility of graphic items (curves, etc.)
            updateGraphicItemsVisibility() {
                const show = this.showGraphicItemsToggle?.checked ?? true;
                // Hide/show all curve elements but keep timeline, cursors, staff dividers visible
                document.querySelectorAll('.curve-path, .curve-fill, .curve-bounding-box').forEach(el => {
                    el.style.display = show ? '' : 'none';
                });
            },
            
            // Process MIDI playback synced to graphic cursor positions
            processCursorSyncedPlayback() {
                if (!window.ScoreTime || !ScoreTime.isPlaying) return;
                
                const currentScoreTimeMs = ScoreTime.now();
                const currentDisplayTimeSec = (currentScoreTimeMs / 1000) - leadInSeconds;
                const currentDisplayTimeMs = currentDisplayTimeSec * 1000;
                
                // Process each enabled track
                for (let trackIndex = 0; trackIndex < 4; trackIndex++) {
                    // Check if track is enabled
                    if (!this.trackEnables[trackIndex] || !this.trackEnables[trackIndex].checked) continue;
                    
                    const trackEvents = this.tracks[trackIndex].midiEvents;
                    if (trackEvents.length === 0) continue;
                    
                    // Send any events between last time and current time
                    while (this.currentEventIndices[trackIndex] < trackEvents.length &&
                           trackEvents[this.currentEventIndices[trackIndex]].timeMs <= currentDisplayTimeMs) {
                        const event = trackEvents[this.currentEventIndices[trackIndex]];
                        
                        // Only send if we haven't already passed this event
                        if (event.timeMs > this.lastPlaybackTimeMs[trackIndex]) {
                            // Send to output if available
                            if (this.selectedOutput) {
                                this.selectedOutput.send(event.data);
                            }
                        }
                        
                        this.currentEventIndices[trackIndex]++;
                    }
                    
                    this.lastPlaybackTimeMs[trackIndex] = currentDisplayTimeMs;
                }
            },
            
            // Reset playback indices when score time resets
            resetPlaybackIndices() {
                this.currentEventIndices = [0, 0, 0, 0];
                this.lastPlaybackTimeMs = [0, 0, 0, 0];
            },
            
            // Reset playback to a specific time (used when jumping to a position)
            resetPlaybackToTime(targetTimeMs) {
                for (let trackIndex = 0; trackIndex < 4; trackIndex++) {
                    const trackEvents = this.tracks[trackIndex].midiEvents;
                    
                    // Find the first event at or after the target time
                    let eventIndex = 0;
                    while (eventIndex < trackEvents.length && trackEvents[eventIndex].timeMs < targetTimeMs) {
                        eventIndex++;
                    }
                    
                    this.currentEventIndices[trackIndex] = eventIndex;
                    this.lastPlaybackTimeMs[trackIndex] = targetTimeMs;
                }
            },
            
            // Web MIDI API initialization
            async initMidi() {
                try {
                    this.midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                    this.midiAccess.onstatechange = () => this.refreshDevices();
                    this.refreshDevices();
                    console.log('Web MIDI API initialized');
                } catch (err) {
                    console.error('Web MIDI API not available:', err);
                    this.inputSelect.innerHTML = '<option value="">MIDI not available</option>';
                    this.outputSelect.innerHTML = '<option value="">MIDI not available</option>';
                }
            },
            
            refreshDevices() {
                if (!this.midiAccess) return;
                
                // Clear and populate input select
                this.inputSelect.innerHTML = '<option value="">-- Select Input --</option>';
                for (const input of this.midiAccess.inputs.values()) {
                    const option = document.createElement('option');
                    option.value = input.id;
                    option.textContent = input.name;
                    this.inputSelect.appendChild(option);
                }
                
                // Clear and populate output select
                this.outputSelect.innerHTML = '<option value="">-- Select Output --</option>';
                for (const output of this.midiAccess.outputs.values()) {
                    const option = document.createElement('option');
                    option.value = output.id;
                    option.textContent = output.name;
                    this.outputSelect.appendChild(option);
                }
                
                console.log('MIDI devices refreshed');
            },
            
            selectInput(inputId) {
                if (this.selectedInput) {
                    this.selectedInput.onmidimessage = null;
                }
                
                if (inputId && this.midiAccess) {
                    this.selectedInput = this.midiAccess.inputs.get(inputId);
                    if (this.selectedInput) {
                        this.selectedInput.onmidimessage = (e) => this.onMidiMessage(e);
                        console.log('MIDI input selected:', this.selectedInput.name);
                    }
                } else {
                    this.selectedInput = null;
                }
            },
            
            selectOutput(outputId) {
                if (outputId && this.midiAccess) {
                    this.selectedOutput = this.midiAccess.outputs.get(outputId);
                    console.log('MIDI output selected:', this.selectedOutput?.name);
                } else {
                    this.selectedOutput = null;
                }
            },
            
            onMidiMessage(event) {
                // MIDI input handling - can be extended for live input features
                console.log('MIDI message received:', event.data);
            },
            
            // Update insert time display from edit cursor position
            updateInsertTime() {
                if (window.EditCursor && this.insertTimeDisplay) {
                    this.insertTimeDisplay.textContent = EditCursor.positionSeconds.toFixed(3);
                }
            },
            
            // Insert loaded MIDI file at edit cursor position into selected track
            insertAtEditCursor() {
                if (this.loadedFileEvents.length === 0) {
                    alert('No MIDI file loaded. Load a MIDI file first.');
                    return;
                }
                
                const trackIndex = this.selectedTrack - 1;
                const insertTimeMs = (window.EditCursor ? EditCursor.positionSeconds : 0) * 1000;
                const channel = trackIndex + 1; // Track 1 = Channel 1, etc.
                
                // Add events to selected track with time offset and channel remapping
                for (const event of this.loadedFileEvents) {
                    const newEvent = {
                        timeMs: event.timeMs + insertTimeMs,
                        type: event.type,
                        data: [...event.data]
                    };
                    
                    // Remap channel for channel voice messages (0x80-0xEF)
                    const statusByte = newEvent.data[0];
                    if (statusByte >= 0x80 && statusByte < 0xF0) {
                        newEvent.data[0] = (statusByte & 0xF0) | (channel - 1);
                    }
                    
                    this.tracks[trackIndex].midiEvents.push(newEvent);
                }
                
                // Sort events by time
                this.tracks[trackIndex].midiEvents.sort((a, b) => a.timeMs - b.timeMs);
                
                // Mark score as dirty (has unsaved changes)
                if (window.ScoreManager) ScoreManager.markDirty();
                
                this.updateEventCount();
                this.renderMidiDisplay(trackIndex); // Update MIDI display
                this.updateMidiDisplayVisibility(); // Apply page visibility
            },
            
            getMidiEventType(statusByte) {
                const type = statusByte & 0xF0;
                switch (type) {
                    case 0x80: return 'noteOff';
                    case 0x90: return 'noteOn';
                    case 0xA0: return 'aftertouch';
                    case 0xB0: return 'controlChange';
                    case 0xC0: return 'programChange';
                    case 0xD0: return 'channelPressure';
                    case 0xE0: return 'pitchBend';
                    default: return 'unknown';
                }
            },
            
            // File operations
            loadMidiFile(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        this.parseMidiFile(e.target.result);
                        this.loadedFileName = file.name;
                        this.fileNameDisplay.textContent = file.name;
                        console.log(`Loaded MIDI file: ${file.name} (${this.loadedFileEvents.length} events)`);
                    } catch (err) {
                        console.error('Error parsing MIDI file:', err);
                        alert('Error parsing MIDI file');
                    }
                };
                reader.readAsArrayBuffer(file);
                event.target.value = ''; // Reset file input
            },
            
            parseMidiFile(arrayBuffer) {
                const data = new Uint8Array(arrayBuffer);
                this.loadedFileEvents = [];
                
                // Simple MIDI file parser
                let pos = 0;
                
                // Check header
                const header = String.fromCharCode(data[0], data[1], data[2], data[3]);
                if (header !== 'MThd') {
                    throw new Error('Invalid MIDI file header');
                }
                
                pos = 4;
                const headerLength = (data[pos] << 24) | (data[pos+1] << 16) | (data[pos+2] << 8) | data[pos+3];
                pos += 4;
                
                const format = (data[pos] << 8) | data[pos+1];
                const numTracks = (data[pos+2] << 8) | data[pos+3];
                const division = (data[pos+4] << 8) | data[pos+5];
                pos += headerLength;
                
                // Parse tracks
                let currentTimeMs = 0;
                const ticksPerBeat = division;
                const microsecondsPerBeat = 500000; // Default 120 BPM
                const msPerTick = (microsecondsPerBeat / 1000) / ticksPerBeat;
                
                for (let track = 0; track < numTracks; track++) {
                    const trackHeader = String.fromCharCode(data[pos], data[pos+1], data[pos+2], data[pos+3]);
                    if (trackHeader !== 'MTrk') continue;
                    
                    pos += 4;
                    const trackLength = (data[pos] << 24) | (data[pos+1] << 16) | (data[pos+2] << 8) | data[pos+3];
                    pos += 4;
                    
                    const trackEnd = pos + trackLength;
                    let trackTimeMs = 0;
                    let runningStatus = 0;
                    
                    while (pos < trackEnd) {
                        // Read delta time (variable length)
                        let deltaTime = 0;
                        let byte;
                        do {
                            byte = data[pos++];
                            deltaTime = (deltaTime << 7) | (byte & 0x7F);
                        } while (byte & 0x80);
                        
                        trackTimeMs += deltaTime * msPerTick;
                        
                        // Read event
                        let status = data[pos];
                        if (status < 0x80) {
                            // Running status
                            status = runningStatus;
                        } else {
                            pos++;
                            if (status < 0xF0) {
                                runningStatus = status;
                            }
                        }
                        
                        const eventType = status & 0xF0;
                        
                        if (status === 0xFF) {
                            // Meta event
                            const metaType = data[pos++];
                            let length = 0;
                            do {
                                byte = data[pos++];
                                length = (length << 7) | (byte & 0x7F);
                            } while (byte & 0x80);
                            pos += length;
                        } else if (status === 0xF0 || status === 0xF7) {
                            // SysEx
                            let length = 0;
                            do {
                                byte = data[pos++];
                                length = (length << 7) | (byte & 0x7F);
                            } while (byte & 0x80);
                            pos += length;
                        } else if (eventType >= 0x80 && eventType <= 0xE0) {
                            // Channel event
                            const data1 = data[pos++];
                            let data2 = 0;
                            if (eventType !== 0xC0 && eventType !== 0xD0) {
                                data2 = data[pos++];
                            }
                            
                            this.loadedFileEvents.push({
                                timeMs: trackTimeMs,
                                type: this.getMidiEventType(status),
                                data: eventType === 0xC0 || eventType === 0xD0 
                                    ? [status, data1] 
                                    : [status, data1, data2]
                            });
                        }
                    }
                }
                
                // Sort events by time
                this.loadedFileEvents.sort((a, b) => a.timeMs - b.timeMs);
            },
            
            downloadMidiFile() {
                const trackIndex = this.selectedTrack - 1;
                const trackEvents = this.tracks[trackIndex].midiEvents;
                
                if (trackEvents.length === 0) {
                    alert(`No MIDI data in Track ${this.selectedTrack} to download`);
                    return;
                }
                
                // Create simple MIDI file from track events
                const midiData = this.createMidiFile(trackEvents);
                const blob = new Blob([midiData], { type: 'audio/midi' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `track${this.selectedTrack}.mid`;
                a.click();
                URL.revokeObjectURL(url);
            },
            
            createMidiFile(events) {
                // Create a simple Format 0 MIDI file
                const ticksPerBeat = 480;
                const msPerTick = (500000 / 1000) / ticksPerBeat; // 120 BPM default
                
                // Build track data
                const trackData = [];
                let lastTimeMs = 0;
                
                for (const event of events) {
                    const deltaTicks = Math.round((event.timeMs - lastTimeMs) / msPerTick);
                    lastTimeMs = event.timeMs;
                    
                    // Write variable length delta time
                    const deltaBytes = this.writeVariableLength(deltaTicks);
                    trackData.push(...deltaBytes);
                    
                    // Write event data
                    trackData.push(...event.data);
                }
                
                // Add end of track
                trackData.push(0x00, 0xFF, 0x2F, 0x00);
                
                // Build file
                const file = [];
                
                // Header chunk
                file.push(0x4D, 0x54, 0x68, 0x64); // MThd
                file.push(0x00, 0x00, 0x00, 0x06); // Header length
                file.push(0x00, 0x00); // Format 0
                file.push(0x00, 0x01); // 1 track
                file.push((ticksPerBeat >> 8) & 0xFF, ticksPerBeat & 0xFF); // Division
                
                // Track chunk
                file.push(0x4D, 0x54, 0x72, 0x6B); // MTrk
                const trackLength = trackData.length;
                file.push((trackLength >> 24) & 0xFF, (trackLength >> 16) & 0xFF, 
                          (trackLength >> 8) & 0xFF, trackLength & 0xFF);
                file.push(...trackData);
                
                return new Uint8Array(file);
            },
            
            writeVariableLength(value) {
                const bytes = [];
                bytes.unshift(value & 0x7F);
                value >>= 7;
                while (value > 0) {
                    bytes.unshift((value & 0x7F) | 0x80);
                    value >>= 7;
                }
                return bytes;
            },
            
            exportCsv() {
                const trackIndex = this.selectedTrack - 1;
                const trackEvents = this.tracks[trackIndex].midiEvents;
                
                if (trackEvents.length === 0) {
                    alert(`No MIDI data in Track ${this.selectedTrack} to export`);
                    return;
                }
                
                let csv = 'Time (ms),Time (sec),Type,Channel,Status,Data1,Data2,Note,Velocity\n';
                for (const event of trackEvents) {
                    const data1 = event.data[1] !== undefined ? event.data[1] : '';
                    const data2 = event.data[2] !== undefined ? event.data[2] : '';
                    const channel = (event.data[0] & 0x0F) + 1;
                    const noteName = event.type === 'noteOn' || event.type === 'noteOff' ? this.midiNoteToName(data1) : '';
                    const velocity = event.type === 'noteOn' || event.type === 'noteOff' ? data2 : '';
                    csv += `${event.timeMs.toFixed(3)},${(event.timeMs/1000).toFixed(3)},${event.type},${channel},${event.data[0]},${data1},${data2},${noteName},${velocity}\n`;
                }
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `track${this.selectedTrack}_midi.csv`;
                a.click();
                URL.revokeObjectURL(url);
            },
            
            midiNoteToName(noteNumber) {
                const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const octave = Math.floor(noteNumber / 12) - 1;
                const note = notes[noteNumber % 12];
                return `${note}${octave}`;
            },
            
            // Update timecode display from cursor position (synced to ScoreTime)
            updateTimecode() {
                if (!this.timecodeDisplay) return;
                
                let timeMs = 0;
                if (window.ScoreTime) {
                    const currentScoreTimeMs = ScoreTime.now();
                    const currentDisplayTimeSec = (currentScoreTimeMs / 1000) - leadInSeconds;
                    timeMs = Math.max(0, currentDisplayTimeSec * 1000);
                }
                
                this.timecodeDisplay.textContent = this.formatTimecode(timeMs);
            },
            
            formatTimecode(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                const milliseconds = Math.floor(ms % 1000);
                
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            },
            
            updateEventCount() {
                if (this.eventCountDisplay) {
                    const trackIndex = this.selectedTrack - 1;
                    const trackEvents = this.tracks[trackIndex].midiEvents;
                    this.eventCountDisplay.textContent = `T${this.selectedTrack} Events: ${trackEvents.length}`;
                }
            },
            
            // Get current MIDI events for external use (selected track)
            getEvents() {
                const trackIndex = this.selectedTrack - 1;
                return this.tracks[trackIndex].midiEvents;
            },
            
            // Get all tracks' events
            getAllTracks() {
                return this.tracks;
            },
            
            // Get current playback time in ms (synced to cursor)
            getCurrentTimeMs() {
                if (window.ScoreTime && ScoreTime.isRunning) {
                    const currentScoreTimeMs = ScoreTime.now();
                    const currentDisplayTimeSec = (currentScoreTimeMs / 1000) - leadInSeconds;
                    return Math.max(0, currentDisplayTimeSec * 1000);
                }
                return 0;
            },
            
            // Render MIDI events as SVG graphics for a track
            // Layout per track (within track height):
            // - Top 40%: Note rectangles (pitch mapped to height)
            // - Next 15%: Velocity squares (black with white text)
            // - Next 15%: CC0 squares (blue with white text)
            // - Bottom 30%: CC7 line graph (0-127 height)
            renderMidiDisplay(trackIndex) {
                const trackEvents = this.tracks[trackIndex].midiEvents;
                const topGroup = this.midiDisplayLayers.top[trackIndex];
                const bottomGroup = this.midiDisplayLayers.bottom[trackIndex];
                
                // Clear existing display
                topGroup.innerHTML = '';
                bottomGroup.innerHTML = '';
                
                if (trackEvents.length === 0) return;
                
                // Get track dimensions
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                
                // If dimensions are 0, the SVG hasn't been laid out yet - skip rendering
                if (scoreWidth === 0 || scoreHeight === 0) return;
                const availableHeight = scoreHeight - this.timelineHeight;
                const trackHeight = availableHeight / 4;
                const trackY = this.timelineHeight + (trackIndex * trackHeight);
                
                // Layout heights within track:
                // - Note line: 2px at very top
                // - Velocity: small row just below note line
                // - CC display: bottom half of track (vertical lines)
                const noteLineHeight = 2;
                const velocityRowHeight = 14; // enough for 12px square + padding
                const ccRowHeight = trackHeight * 0.50; // bottom half
                
                const noteRowY = trackY;
                const velocityRowY = trackY + noteLineHeight + 2;
                const ccRowY = trackY + trackHeight - ccRowHeight; // starts at bottom half
                
                // Get selected CC number and name for display
                const selectedCCNum = this.selectedCC;
                const ccName = this.ccNames[selectedCCNum] || `CC${selectedCCNum}`;
                
                // Calculate time-to-pixel conversion using GraphicTimeline's getSecondsPerPage()
                let secondsPerPage = 10; // default
                if (window.GraphicTimeline && typeof GraphicTimeline.getSecondsPerPage === 'function') {
                    secondsPerPage = GraphicTimeline.getSecondsPerPage();
                }
                const msPerPage = secondsPerPage * 1000;
                const pixelsPerMs = scoreWidth / msPerPage;
                
                // Lead-in offset: MIDI events are in display time (0 = first beat)
                // but pages are in actual time (0 = start of lead-in)
                // So we need to add leadInSeconds to convert display time to actual time
                const leadInMs = leadInSeconds * 1000;
                
                // Build note pairs (noteOn -> noteOff)
                const activeNotes = {}; // key: note number, value: noteOn event
                const notePairs = [];
                const velocityEvents = [];
                const ccEvents = []; // Events for the selected CC
                
                for (const event of trackEvents) {
                    const statusType = event.data[0] & 0xF0;
                    
                    if (statusType === 0x90 && event.data[2] > 0) {
                        // Note On
                        const noteNum = event.data[1];
                        activeNotes[noteNum] = event;
                        velocityEvents.push({ timeMs: event.timeMs, velocity: event.data[2], noteNum });
                    } else if (statusType === 0x80 || (statusType === 0x90 && event.data[2] === 0)) {
                        // Note Off
                        const noteNum = event.data[1];
                        if (activeNotes[noteNum]) {
                            notePairs.push({
                                noteNum,
                                startMs: activeNotes[noteNum].timeMs,
                                endMs: event.timeMs,
                                velocity: activeNotes[noteNum].data[2]
                            });
                            delete activeNotes[noteNum];
                        }
                    } else if (statusType === 0xB0) {
                        // Control Change - collect events for selected CC
                        const ccNum = event.data[1];
                        const ccValue = event.data[2];
                        if (ccNum === selectedCCNum) {
                            ccEvents.push({ timeMs: event.timeMs, value: ccValue });
                        }
                    }
                }
                
                // Determine how many pages we need to render
                // Find the max time in the events (in display time)
                // Convert to actual time by adding lead-in
                let maxTimeMs = 0;
                for (const event of trackEvents) {
                    if (event.timeMs > maxTimeMs) maxTimeMs = event.timeMs;
                }
                const maxActualTimeMs = maxTimeMs + leadInMs;
                const totalPages = Math.ceil(maxActualTimeMs / msPerPage) + 1;
                
                // Render events to appropriate pages (top = even pages, bottom = odd pages)
                // Page times are in actual time (including lead-in)
                for (let pageNum = 0; pageNum < totalPages; pageNum++) {
                    const isTopPage = pageNum % 2 === 0;
                    const group = isTopPage ? topGroup : bottomGroup;
                    const pageStartActualMs = pageNum * msPerPage;
                    const pageEndActualMs = pageStartActualMs + msPerPage;
                    
                    // Convert to display time for event comparison
                    const pageStartDisplayMs = pageStartActualMs - leadInMs;
                    const pageEndDisplayMs = pageEndActualMs - leadInMs;
                    
                    // Render note lines (2px high at top of track)
                    for (const note of notePairs) {
                        // Check if note overlaps with this page (using display time)
                        if (note.endMs < pageStartDisplayMs || note.startMs >= pageEndDisplayMs) continue;
                        
                        // Calculate X positions: convert display time to actual time, then to pixels
                        const startActualMs = note.startMs + leadInMs;
                        const endActualMs = note.endMs + leadInMs;
                        const startX = Math.max(0, (startActualMs - pageStartActualMs) * pixelsPerMs);
                        const endX = Math.min(scoreWidth, (endActualMs - pageStartActualMs) * pixelsPerMs);
                        const width = Math.max(2, endX - startX);
                        
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', startX);
                        rect.setAttribute('y', noteRowY);
                        rect.setAttribute('width', width);
                        rect.setAttribute('height', noteLineHeight);
                        rect.setAttribute('fill', 'black');
                        rect.setAttribute('class', 'midi-note-rect');
                        rect.setAttribute('data-page', pageNum);
                        group.appendChild(rect);
                    }
                    
                    // Render velocity squares (red with white text)
                    for (const vel of velocityEvents) {
                        if (vel.timeMs < pageStartDisplayMs || vel.timeMs >= pageEndDisplayMs) continue;
                        
                        const actualMs = vel.timeMs + leadInMs;
                        const x = (actualMs - pageStartActualMs) * pixelsPerMs;
                        const squareSize = 12;
                        
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x);
                        rect.setAttribute('y', velocityRowY);
                        rect.setAttribute('width', squareSize);
                        rect.setAttribute('height', squareSize);
                        rect.setAttribute('fill', '#E53935'); // Red
                        rect.setAttribute('class', 'midi-velocity-rect');
                        rect.setAttribute('data-page', pageNum);
                        group.appendChild(rect);
                        
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', x + squareSize / 2);
                        text.setAttribute('y', velocityRowY + squareSize / 2 + 3);
                        text.setAttribute('fill', 'white');
                        text.setAttribute('font-size', '8');
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('class', 'midi-velocity-text');
                        text.setAttribute('data-page', pageNum);
                        text.textContent = vel.velocity;
                        group.appendChild(text);
                    }
                    
                    // Add CC label in upper left corner of CC area (only on first page for this track)
                    if (pageNum === 0) {
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        label.setAttribute('x', '2');
                        label.setAttribute('y', ccRowY + 10);
                        label.setAttribute('fill', '#4CAF50');
                        label.setAttribute('font-family', 'Lato, sans-serif');
                        label.setAttribute('font-size', '9');
                        label.setAttribute('class', 'midi-cc-label');
                        label.setAttribute('data-page', pageNum);
                        label.textContent = `CC${selectedCCNum} - ${ccName}`;
                        group.appendChild(label);
                    }
                    
                    // Render selected CC as vertical lines from bottom up (value/127 * ccRowHeight)
                    for (const cc of ccEvents) {
                        if (cc.timeMs < pageStartDisplayMs || cc.timeMs >= pageEndDisplayMs) continue;
                        
                        const actualMs = cc.timeMs + leadInMs;
                        const x = (actualMs - pageStartActualMs) * pixelsPerMs;
                        const valueRatio = cc.value / 127;
                        const lineHeight = valueRatio * ccRowHeight;
                        const lineY = ccRowY + ccRowHeight - lineHeight; // start from bottom
                        
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', x);
                        line.setAttribute('y1', ccRowY + ccRowHeight); // bottom of CC area
                        line.setAttribute('x2', x);
                        line.setAttribute('y2', lineY); // top based on value
                        line.setAttribute('stroke', '#4CAF50'); // Green
                        line.setAttribute('stroke-width', '1');
                        line.setAttribute('class', 'midi-cc-line');
                        line.setAttribute('data-page', pageNum);
                        group.appendChild(line);
                    }
                }
            },
            
            // Render MIDI display for all tracks
            renderAllMidiDisplays() {
                for (let i = 0; i < 4; i++) {
                    this.renderMidiDisplay(i);
                }
                // Apply visibility after rendering
                this.updateMidiDisplayVisibility();
            },
            
            // Update visibility of MIDI display elements based on toggle and current page
            updateMidiDisplayVisibility() {
                const showMidi = this.showMidiDisplayToggle?.checked ?? true;
                
                // If MIDI display is toggled off, hide all layers
                if (!showMidi) {
                    for (const topGroup of this.midiDisplayLayers.top) {
                        topGroup.style.display = 'none';
                    }
                    for (const bottomGroup of this.midiDisplayLayers.bottom) {
                        bottomGroup.style.display = 'none';
                    }
                    return;
                }
                
                // MIDI display is on - show layers and apply page-based visibility
                for (const topGroup of this.midiDisplayLayers.top) {
                    topGroup.style.display = '';
                }
                for (const bottomGroup of this.midiDisplayLayers.bottom) {
                    bottomGroup.style.display = '';
                }
                
                if (!window.GraphicTimeline) return;
                
                const currentTopPage = GraphicTimeline.currentTopPage;
                const currentBottomPage = GraphicTimeline.currentBottomPage;
                
                // Update top layers - show only elements matching currentTopPage
                for (const topGroup of this.midiDisplayLayers.top) {
                    const elements = topGroup.querySelectorAll('[data-page]');
                    elements.forEach(el => {
                        const elPage = parseInt(el.getAttribute('data-page'), 10);
                        el.style.display = (elPage === currentTopPage) ? '' : 'none';
                    });
                }
                
                // Update bottom layers - show only elements matching currentBottomPage
                for (const bottomGroup of this.midiDisplayLayers.bottom) {
                    const elements = bottomGroup.querySelectorAll('[data-page]');
                    elements.forEach(el => {
                        const elPage = parseInt(el.getAttribute('data-page'), 10);
                        el.style.display = (elPage === currentBottomPage) ? '' : 'none';
                    });
                }
            },
            
            // Debug function to check state
            debugState() {
                let msg = '=== MidiController Debug State ===\n';
                msg += 'loadedFileEvents: ' + this.loadedFileEvents.length + '\n';
                msg += 'selectedTrack: ' + this.selectedTrack + '\n';
                for (let i = 0; i < 4; i++) {
                    msg += 'Track ' + (i+1) + ' events: ' + this.tracks[i].midiEvents.length + '\n';
                }
                msg += 'midiDisplayLayers.top: ' + this.midiDisplayLayers.top.length + '\n';
                msg += 'midiDisplayLayers.bottom: ' + this.midiDisplayLayers.bottom.length + '\n';
                msg += 'scoreTopEl: ' + (this.scoreTopEl ? 'found' : 'null') + '\n';
                msg += 'scoreBottomEl: ' + (this.scoreBottomEl ? 'found' : 'null');
                alert(msg);
                return msg;
            }
        };
        
        // Initialize MIDI controller after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                MidiController.init();
                window.MidiController = MidiController;
            });
        } else {
            MidiController.init();
            window.MidiController = MidiController;
        }
        
        // Staff Y Positions - Named Y coordinates for each staff relative to page
        // These define the vertical layout of the 4 staff sections
        const StaffPositions = {
            timelineHeight: 8,  // Y position where staves begin (below timeline numbers)
            
            // Get staff Y positions dynamically based on current page height
            getPositions(scoreEl) {
                const scoreHeight = scoreEl.clientHeight;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                
                return {
                    Staff1Y: this.timelineHeight,
                    Staff2Y: this.timelineHeight + staffHeight,
                    Staff3Y: this.timelineHeight + (2 * staffHeight),
                    Staff4Y: this.timelineHeight + (3 * staffHeight),
                    staffHeight: staffHeight,
                    availableHeight: availableHeight
                };
            }
        };
        window.StaffPositions = StaffPositions;
        
        // G Track System - Graphic tracks working in Staff Y dimensions
        // Each G Track corresponds to a staff and stores graphic elements
        const GTrackSystem = {
            gTracks: [],       // Array of 4 G Track objects
            scoreTopEl: null,
            scoreBottomEl: null,
            initialized: false,
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                const positions = StaffPositions.getPositions(this.scoreTopEl);
                
                // Create 4 G Tracks
                for (let i = 0; i < 4; i++) {
                    const gTrack = this.createGTrack(i, positions);
                    this.gTracks.push(gTrack);
                }
                
                this.initialized = true;
                console.log('GTrackSystem initialized with 4 G Tracks');
            },
            
            createGTrack(trackIndex, positions) {
                const yPositions = [positions.Staff1Y, positions.Staff2Y, positions.Staff3Y, positions.Staff4Y];
                
                return {
                    index: trackIndex,
                    name: `G Track ${trackIndex + 1}`,
                    yPosition: yPositions[trackIndex],
                    height: positions.staffHeight,
                    
                    // Graphic items array - stores all graphic elements for this track
                    // Each item: { scoreTimeMs, duration, type, props }
                    graphicItems: [],
                    
                    // Link to corresponding MIDI track in TrackSystem
                    midiTrackIndex: trackIndex
                };
            },
            
            // Get G Track by index
            getGTrack(index) {
                if (index >= 0 && index < this.gTracks.length) {
                    return this.gTracks[index];
                }
                return null;
            },
            
            // Add graphic item to a G Track
            addGraphicItem(trackIndex, item) {
                if (trackIndex >= 0 && trackIndex < this.gTracks.length) {
                    this.gTracks[trackIndex].graphicItems.push(item);
                }
            },
            
            // Update dimensions on resize
            updateDimensions() {
                const positions = StaffPositions.getPositions(this.scoreTopEl);
                const yPositions = [positions.Staff1Y, positions.Staff2Y, positions.Staff3Y, positions.Staff4Y];
                
                this.gTracks.forEach((gTrack, index) => {
                    gTrack.yPosition = yPositions[index];
                    gTrack.height = positions.staffHeight;
                });
            },
            
            // Clear all graphic items (called before reload)
            clearAllGraphicItems() {
                this.gTracks.forEach(gTrack => {
                    gTrack.graphicItems = [];
                });
            }
        };
        
        // Initialize G Track System
        GTrackSystem.init();
        window.GTrackSystem = GTrackSystem;
        
        // Edit Cursor - Neon yellow SVG line with draggable triangle handle
        // Spans full page height, can be dragged across timeline
        const EditCursor = {
            scoreTopEl: null,
            scoreBottomEl: null,
            lineTop: null,
            lineBottom: null,
            handleTop: null,
            handleBottom: null,
            currentSection: 'top',    // 'top' or 'bottom'
            positionSeconds: 0,       // Current position in seconds
            isDragging: false,
            inputEl: null,
            initialized: false,
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                this.inputEl = document.getElementById('editCursorSecondsInput');
                
                // Create edit cursor elements for ScoreTop
                this.createCursorElements('top');
                this.createCursorElements('bottom');
                
                // Set up input handling
                this.inputEl.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.jumpToInputValue();
                    }
                });
                
                this.inputEl.addEventListener('blur', () => {
                    this.jumpToInputValue();
                });
                
                // Update on resize
                window.addEventListener('resize', () => {
                    this.updateDimensions();
                });
                
                // Initial position
                this.setPositionSeconds(0);
                
                this.initialized = true;
                console.log('EditCursor initialized');
            },
            
            // Triangle handle size (8px equilateral)
            handleSize: 8,
            
            createCursorElements(section) {
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreHeight = scoreEl.clientHeight;
                const positions = StaffPositions.getPositions(scoreEl);
                
                // Create vertical line spanning full page height below timeline
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', '0');
                line.setAttribute('y1', positions.Staff1Y);
                line.setAttribute('x2', '0');
                line.setAttribute('y2', scoreHeight);
                line.setAttribute('class', 'edit-cursor-line');
                
                // Create upside-down equilateral triangle handle at top of line (8px)
                const handle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const h = this.handleSize;
                const triHeight = h * Math.sqrt(3) / 2; // Height of equilateral triangle
                handle.setAttribute('points', `0,0 ${h},0 ${h/2},${triHeight}`);
                handle.setAttribute('class', 'edit-cursor-handle');
                handle.setAttribute('transform', `translate(-${h/2}, ${positions.Staff1Y - triHeight})`);
                
                // Add drag handlers to both line and handle
                line.addEventListener('mousedown', (e) => this.startDrag(e, section));
                handle.addEventListener('mousedown', (e) => this.startDrag(e, section));
                
                // Add to SVG
                scoreEl.appendChild(line);
                scoreEl.appendChild(handle);
                
                if (section === 'top') {
                    this.lineTop = line;
                    this.handleTop = handle;
                } else {
                    this.lineBottom = line;
                    this.handleBottom = handle;
                    // Initially hide bottom cursor
                    line.style.display = 'none';
                    handle.style.display = 'none';
                }
            },
            
            startDrag(e, section) {
                e.preventDefault();
                this.isDragging = true;
                this.dragSection = section;
                
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                const onMouseMove = (e) => {
                    if (!this.isDragging) return;
                    
                    // Determine which section (top/bottom) based on vertical mouse position
                    const topRect = this.scoreTopEl.getBoundingClientRect();
                    const bottomRect = this.scoreBottomEl.getBoundingClientRect();
                    
                    let targetSection;
                    let scoreEl;
                    let rect;
                    
                    if (e.clientY < bottomRect.top) {
                        // Mouse is above bottom section - use top
                        targetSection = 'top';
                        scoreEl = this.scoreTopEl;
                        rect = topRect;
                    } else {
                        // Mouse is in or below bottom section - use bottom
                        targetSection = 'bottom';
                        scoreEl = this.scoreBottomEl;
                        rect = bottomRect;
                    }
                    
                    // Get the current page for the target section from GraphicTimeline
                    let currentPage;
                    if (window.GraphicTimeline) {
                        currentPage = targetSection === 'top' ? GraphicTimeline.currentTopPage : GraphicTimeline.currentBottomPage;
                    } else {
                        currentPage = 0;
                    }
                    
                    // Calculate X position as percentage within the target section
                    let xPercent = ((e.clientX - rect.left) / rect.width) * 100;
                    xPercent = Math.max(0, Math.min(100, xPercent));
                    
                    // Calculate seconds based on the target section's page and x position
                    const seconds = (currentPage + xPercent / 100) * secondsPerPage - leadInSeconds;
                    
                    // Clamp to minimum of -leadInSeconds
                    const clampedSeconds = Math.max(-leadInSeconds, seconds);
                    
                    // Update drag section for visual feedback
                    this.dragSection = targetSection;
                    
                    this.setPositionSeconds(clampedSeconds);
                };
                
                const onMouseUp = () => {
                    this.isDragging = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            },
            
            setPositionSeconds(seconds) {
                // Clamp to minimum of -leadInSeconds
                this.positionSeconds = Math.max(-leadInSeconds, seconds);
                
                // Update input display
                this.inputEl.value = this.positionSeconds.toFixed(3);
                
                // Calculate which section and x position
                const actualSeconds = this.positionSeconds + leadInSeconds;
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const totalPages = Math.max(0, actualSeconds / secondsPerPage);
                const pageNumber = Math.floor(totalPages);
                const positionInPage = (totalPages - pageNumber) * 100;
                
                const inTop = pageNumber % 2 === 0;
                
                // Update visibility and position
                if (inTop) {
                    this.lineTop.style.display = 'block';
                    this.handleTop.style.display = 'block';
                    this.lineBottom.style.display = 'none';
                    this.handleBottom.style.display = 'none';
                    this.currentSection = 'top';
                    this.updateCursorPosition(this.lineTop, this.handleTop, positionInPage);
                } else {
                    this.lineTop.style.display = 'none';
                    this.handleTop.style.display = 'none';
                    this.lineBottom.style.display = 'block';
                    this.handleBottom.style.display = 'block';
                    this.currentSection = 'bottom';
                    this.updateCursorPosition(this.lineBottom, this.handleBottom, positionInPage);
                }
            },
            
            updateCursorPosition(line, handle, xPercent) {
                const scoreEl = this.currentSection === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                const xPixels = (xPercent / 100) * scoreWidth;
                const positions = StaffPositions.getPositions(scoreEl);
                const h = this.handleSize;
                const triHeight = h * Math.sqrt(3) / 2;
                
                line.setAttribute('x1', xPixels);
                line.setAttribute('x2', xPixels);
                handle.setAttribute('transform', `translate(${xPixels - h/2}, ${positions.Staff1Y - triHeight})`);
            },
            
            updateDimensions() {
                const positions = StaffPositions.getPositions(this.scoreTopEl);
                const scoreHeight = this.scoreTopEl.clientHeight;
                
                [this.lineTop, this.lineBottom].forEach(line => {
                    if (line) {
                        line.setAttribute('y1', positions.Staff1Y);
                        line.setAttribute('y2', scoreHeight);
                    }
                });
                
                // Re-apply current position
                this.setPositionSeconds(this.positionSeconds);
            },
            
            jumpToInputValue() {
                const seconds = parseFloat(this.inputEl.value) || 0;
                this.setPositionSeconds(seconds);
                // Edit cursor only - does not move scrolling/playback cursors
            },
            
            // Get current position in seconds
            getPositionSeconds() {
                return this.positionSeconds;
            }
        };
        
        // Initialize Edit Cursor
        EditCursor.init();
        window.EditCursor = EditCursor;
        
        // Composition Panel Controls
        const CompositionPanel = {
            panelEl: null,
            toggleEl: null,
            isOpen: false,
            selectedGTrack: 'A',  // 'A' = all (full height), '1'-'4' = specific track
            
            init() {
                this.panelEl = document.getElementById('compositionPanel');
                this.toggleEl = document.getElementById('compositionPanelToggle');
                
                // Toggle panel open/close
                this.toggleEl.addEventListener('click', () => this.toggle());
                
                // G Track radio button listeners
                const radioButtons = document.querySelectorAll('input[name="gtrack"]');
                radioButtons.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.selectedGTrack = e.target.value;
                        console.log(`G Track selected: ${this.selectedGTrack === 'A' ? 'All (full height)' : 'G' + this.selectedGTrack}`);
                    });
                });
            },
            
            toggle() {
                this.isOpen = !this.isOpen;
                this.panelEl.classList.toggle('open', this.isOpen);
                this.toggleEl.textContent = this.isOpen ? '◀ Composition' : '◀ Composition';
            },
            
            // Get selected G Track: returns 'A' for all, or 1-4 for specific track
            getSelectedGTrack() {
                return this.selectedGTrack;
            },
            
            // Get Y position and height for current selection
            getSelectedTrackDimensions(scoreEl) {
                return this.getTrackDimensions(this.selectedGTrack, scoreEl);
            },
            
            // Get Y position and height for a specific gTrack
            getTrackDimensions(gTrack, scoreEl) {
                const positions = StaffPositions.getPositions(scoreEl);
                
                if (gTrack === 'A') {
                    // Full height from Staff1Y to bottom
                    return {
                        y: positions.Staff1Y,
                        height: positions.availableHeight
                    };
                } else {
                    // Specific track
                    const trackIndex = parseInt(gTrack) - 1;
                    const yPositions = [positions.Staff1Y, positions.Staff2Y, positions.Staff3Y, positions.Staff4Y];
                    return {
                        y: yPositions[trackIndex],
                        height: positions.staffHeight
                    };
                }
            }
        };
        
        // Initialize Composition Panel
        CompositionPanel.init();
        window.CompositionPanel = CompositionPanel;
        
        // Curve Database - stores all curves with their attributes
        const CurveDatabase = {
            curves: [],
            nextId: 1,
            
            add(curveData) {
                const curve = {
                    id: this.nextId++,
                    ...curveData,
                    createdAt: Date.now()
                };
                this.curves.push(curve);
                return curve;
            },
            
            get(id) {
                return this.curves.find(c => c.id === id);
            },
            
            update(id, updates) {
                const curve = this.get(id);
                if (curve) {
                    Object.assign(curve, updates);
                }
                return curve;
            },
            
            remove(id) {
                const index = this.curves.findIndex(c => c.id === id);
                if (index !== -1) {
                    this.curves.splice(index, 1);
                }
            },
            
            getAll() {
                return this.curves;
            },
            
            // Export data for saving
            exportData() {
                return {
                    curves: this.curves,
                    nextId: this.nextId
                };
            },
            
            // Import data from saved score
            importData(data) {
                if (data && data.curves) {
                    this.curves = data.curves;
                    this.nextId = data.nextId || (this.curves.length > 0 ? Math.max(...this.curves.map(c => c.id)) + 1 : 1);
                }
            }
        };
        window.CurveDatabase = CurveDatabase;
        
        // Motive Database - stores all motives with their attributes
        const MotiveDatabase = {
            motives: [],
            nextId: 1,
            
            add(motiveData) {
                const motive = {
                    id: this.nextId++,
                    ...motiveData,
                    createdAt: Date.now()
                };
                this.motives.push(motive);
                return motive;
            },
            
            get(id) {
                return this.motives.find(m => m.id === id);
            },
            
            update(id, updates) {
                const motive = this.get(id);
                if (motive) {
                    Object.assign(motive, updates);
                }
                return motive;
            },
            
            remove(id) {
                const index = this.motives.findIndex(m => m.id === id);
                if (index !== -1) {
                    this.motives.splice(index, 1);
                    return true;
                }
                return false;
            },
            
            getAll() {
                return this.motives;
            },
            
            exportData() {
                return {
                    motives: this.motives,
                    nextId: this.nextId
                };
            },
            
            importData(data) {
                if (data && data.motives) {
                    this.motives = data.motives;
                    this.nextId = data.nextId || (this.motives.length > 0 ? Math.max(...this.motives.map(m => m.id)) + 1 : 1);
                }
            }
        };
        window.MotiveDatabase = MotiveDatabase;
        
        // ============================================
        // SCORE MANAGER - Client-side persistence
        // ============================================
        const ScoreManager = {
            // UI elements
            nameInput: null,
            saveBtn: null,
            loadBtn: null,
            scoreListSelect: null,
            versionListSelect: null,
            loadVersionBtn: null,
            statusDisplay: null,
            
            // Current score state
            currentScoreName: 'untitled',
            isDirty: false, // Has unsaved changes
            autoSaveInterval: null,
            autoSaveIntervalMs: 60000, // Auto-save every 60 seconds
            
            // Registered data sources for saving/loading
            // Each source: { name, getData: () => data, setData: (data) => void }
            registeredSources: new Map(),
            
            init() {
                // Get UI elements
                this.nameInput = document.getElementById('scoreNameInput');
                this.saveBtn = document.getElementById('scoreSaveBtn');
                this.loadBtn = document.getElementById('scoreLoadBtn');
                this.broadcastLoadBtn = document.getElementById('scoreBroadcastLoadBtn');
                this.scoreListSelect = document.getElementById('scoreListSelect');
                this.versionListSelect = document.getElementById('versionListSelect');
                this.loadVersionBtn = document.getElementById('loadVersionBtn');
                this.statusDisplay = document.getElementById('scoreStatus');
                
                // Set up event listeners
                if (this.saveBtn) {
                    this.saveBtn.addEventListener('click', () => this.saveScore());
                }
                if (this.loadBtn) {
                    this.loadBtn.addEventListener('click', () => this.loadSelectedScore());
                }
                if (this.broadcastLoadBtn) {
                    this.broadcastLoadBtn.addEventListener('click', () => this.loadAndBroadcast());
                }
                if (this.scoreListSelect) {
                    this.scoreListSelect.addEventListener('change', (e) => {
                        if (e.target.value) {
                            this.nameInput.value = e.target.value;
                            this.loadVersionList(e.target.value);
                        }
                    });
                }
                if (this.loadVersionBtn) {
                    this.loadVersionBtn.addEventListener('click', () => this.loadSelectedVersion());
                }
                
                // Register built-in data sources
                this.registerBuiltInSources();
                
                // Load score list
                this.refreshScoreList();
                
                // Listen for score saved events from server
                if (ClockSync.socket) {
                    ClockSync.socket.on('scoreSaved', (data) => {
                        this.updateStatus(`Saved: ${data.name}`);
                        this.isDirty = false;
                    });
                    
                    // Listen for score loaded broadcast from server (sync all clients)
                    ClockSync.socket.on('scoreLoaded', (data) => {
                        console.log(`ScoreManager: Received broadcast to load score '${data.name}'`);
                        this.distributeData(data.data);
                        this.currentScoreName = data.name;
                        this.nameInput.value = data.name;
                        this.isDirty = false;
                        this.updateStatus(`Synced: ${data.name}`);
                        this.loadVersionList(data.name);
                    });
                }
                
                // Start auto-save
                this.startAutoSave();
                
                console.log('ScoreManager initialized');
            },
            
            // Register a data source for saving/loading
            registerSource(name, getData, setData) {
                this.registeredSources.set(name, { name, getData, setData });
                console.log(`ScoreManager: Registered data source '${name}'`);
            },
            
            // Register built-in data sources
            registerBuiltInSources() {
                // Tempo history
                this.registerSource('tempoHistory', 
                    () => serverTempoHistory,
                    (data) => { serverTempoHistory = data || [{ scoreTimeMs: 0, bpm: 60, beatsPerPage: 8 }]; }
                );
                
                // MIDI tracks from MidiController
                this.registerSource('midiTracks',
                    () => {
                        if (!window.MidiController) return [];
                        return MidiController.tracks.map(t => ({
                            channel: t.channel,
                            midiEvents: t.midiEvents.map(e => ({
                                ...e,
                                timestamp: e.timeMs // Ensure timestamp is saved
                            }))
                        }));
                    },
                    (data) => {
                        if (!window.MidiController || !data) return;
                        data.forEach((trackData, i) => {
                            if (i < MidiController.tracks.length) {
                                MidiController.tracks[i].midiEvents = trackData.midiEvents || [];
                            }
                        });
                        MidiController.renderAllMidiDisplays();
                    }
                );
                
                // Graphic tracks from TrackSystem
                this.registerSource('graphicTracks',
                    () => {
                        if (!window.TrackSystem) return [];
                        return TrackSystem.tracks.map(t => ({
                            graphicItems: t.graphicItems.map(item => ({
                                ...item,
                                timestamp: item.scoreTimeMs // Ensure timestamp
                            }))
                        }));
                    },
                    (data) => {
                        if (!window.TrackSystem || !data) return;
                        data.forEach((trackData, i) => {
                            if (i < TrackSystem.tracks.length) {
                                TrackSystem.tracks[i].graphicItems = trackData.graphicItems || [];
                            }
                        });
                        TrackSystem.renderAllTracks();
                    }
                );
                
                // CurveDatabase
                this.registerSource('databases.curves',
                    () => CurveDatabase.exportData(),
                    (data) => {
                        CurveDatabase.importData(data);
                        // Re-render curves if CurveMaker exists
                        if (window.CurveMaker) {
                            CurveMaker.reloadFromDatabase();
                        }
                    }
                );
                
                // MotiveDatabase
                this.registerSource('databases.motives',
                    () => MotiveDatabase.exportData(),
                    (data) => {
                        MotiveDatabase.importData(data);
                        // Re-render motives if MotiveMaker exists
                        if (window.MotiveMaker) {
                            MotiveMaker.reloadFromDatabase();
                        }
                    }
                );
                
                // SVGElementManager - inserted SVG elements
                this.registerSource('svgElements',
                    () => window.SVGElementManager ? SVGElementManager.exportData() : [],
                    (data) => {
                        if (window.SVGElementManager) {
                            SVGElementManager.importData(data);
                        }
                    }
                );
                
                // FlowchartConnector - connector lines between objects
                this.registerSource('connectors',
                    () => window.FlowchartConnector ? FlowchartConnector.exportData() : [],
                    (data) => {
                        if (window.FlowchartConnector) {
                            FlowchartConnector.importData(data);
                        }
                    }
                );
                
                // NotationManager (registered after NotationManager is initialized)
                // This will be called from NotationManager.init() to register itself
            },
            
            // Register NotationManager (called after NotationManager is initialized)
            registerNotationSource() {
                if (window.NotationManager) {
                    this.registerSource('databases.notation',
                        () => NotationManager.exportData(),
                        (data) => NotationManager.importData(data)
                    );
                }
            },
            
            // Collect all data from registered sources
            collectAllData() {
                const data = {
                    version: '1.0',
                    metadata: {
                        title: this.nameInput?.value || 'Untitled Score',
                        created: new Date().toISOString(),
                        modified: new Date().toISOString(),
                        author: ''
                    },
                    tempoHistory: [],
                    midiTracks: [],
                    graphicTracks: [],
                    databases: {},
                    svgGraphics: []
                };
                
                // Collect from all registered sources
                for (const [name, source] of this.registeredSources) {
                    try {
                        const sourceData = source.getData();
                        
                        // Handle nested paths like 'databases.curves'
                        if (name.includes('.')) {
                            const parts = name.split('.');
                            let target = data;
                            for (let i = 0; i < parts.length - 1; i++) {
                                if (!target[parts[i]]) target[parts[i]] = {};
                                target = target[parts[i]];
                            }
                            target[parts[parts.length - 1]] = sourceData;
                        } else {
                            data[name] = sourceData;
                        }
                    } catch (err) {
                        console.error(`ScoreManager: Error collecting data from '${name}':`, err);
                    }
                }
                
                return data;
            },
            
            // Distribute loaded data to all registered sources
            distributeData(data) {
                for (const [name, source] of this.registeredSources) {
                    try {
                        let sourceData;
                        
                        // Handle nested paths like 'databases.curves'
                        if (name.includes('.')) {
                            const parts = name.split('.');
                            sourceData = data;
                            for (const part of parts) {
                                sourceData = sourceData?.[part];
                            }
                        } else {
                            sourceData = data[name];
                        }
                        
                        if (sourceData !== undefined) {
                            source.setData(sourceData);
                        }
                    } catch (err) {
                        console.error(`ScoreManager: Error distributing data to '${name}':`, err);
                    }
                }
            },
            
            // Save score to server
            async saveScore() {
                const name = this.nameInput?.value?.trim() || 'untitled';
                const data = this.collectAllData();
                
                this.updateStatus('Saving...');
                
                try {
                    const response = await fetch('/api/score/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, data })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.currentScoreName = name;
                        this.isDirty = false;
                        this.updateStatus(`Saved: ${name}`);
                        this.refreshScoreList();
                        console.log(`Score saved: ${name}`);
                    } else {
                        this.updateStatus(`Error: ${result.error}`);
                        console.error('Save failed:', result.error);
                    }
                } catch (err) {
                    this.updateStatus('Save failed');
                    console.error('Save error:', err);
                }
            },
            
            // Load selected score from dropdown
            async loadSelectedScore() {
                const name = this.scoreListSelect?.value || this.nameInput?.value?.trim();
                if (!name) {
                    this.updateStatus('Select a score');
                    return;
                }
                
                await this.loadScore(name);
            },
            
            // Load and broadcast to all connected clients
            async loadAndBroadcast() {
                const name = this.scoreListSelect?.value || this.nameInput?.value?.trim();
                if (!name) {
                    this.updateStatus('Select a score');
                    return;
                }
                
                this.updateStatus('Loading & syncing...');
                
                try {
                    const response = await fetch(`/api/score/load-broadcast/${encodeURIComponent(name)}`, {
                        method: 'POST'
                    });
                    const result = await response.json();
                    
                    if (result.success) {
                        // Data will be distributed via the scoreLoaded socket event
                        console.log(`Score broadcast initiated: ${name}`);
                    } else {
                        this.updateStatus(`Error: ${result.error}`);
                        console.error('Broadcast load failed:', result.error);
                    }
                } catch (err) {
                    this.updateStatus('Broadcast failed');
                    console.error('Broadcast load error:', err);
                }
            },
            
            // Load score from server
            async loadScore(name) {
                this.updateStatus('Loading...');
                
                try {
                    const response = await fetch(`/api/score/load/${encodeURIComponent(name)}`);
                    const result = await response.json();
                    
                    if (result.success) {
                        this.distributeData(result.data);
                        this.currentScoreName = name;
                        this.nameInput.value = name;
                        this.isDirty = false;
                        this.updateStatus(`Loaded: ${name}`);
                        this.loadVersionList(name);
                        console.log(`Score loaded: ${name}`);
                    } else {
                        this.updateStatus(`Error: ${result.error}`);
                        console.error('Load failed:', result.error);
                    }
                } catch (err) {
                    this.updateStatus('Load failed');
                    console.error('Load error:', err);
                }
            },
            
            // Refresh the score list dropdown
            async refreshScoreList() {
                try {
                    const response = await fetch('/api/scores');
                    const scores = await response.json();
                    
                    if (this.scoreListSelect) {
                        this.scoreListSelect.innerHTML = '<option value="">-- Select Score --</option>';
                        scores.forEach(score => {
                            const option = document.createElement('option');
                            option.value = score.name;
                            option.textContent = `${score.title} (${new Date(score.modified).toLocaleDateString()})`;
                            this.scoreListSelect.appendChild(option);
                        });
                    }
                } catch (err) {
                    console.error('Error refreshing score list:', err);
                }
            },
            
            // Load version list for a score
            async loadVersionList(scoreName) {
                try {
                    const response = await fetch(`/api/score/versions/${encodeURIComponent(scoreName)}`);
                    const versions = await response.json();
                    
                    if (this.versionListSelect) {
                        this.versionListSelect.innerHTML = '<option value="">-- Versions --</option>';
                        versions.forEach(version => {
                            const option = document.createElement('option');
                            option.value = version.filename;
                            const date = new Date(version.created);
                            option.textContent = date.toLocaleString();
                            this.versionListSelect.appendChild(option);
                        });
                    }
                } catch (err) {
                    console.error('Error loading version list:', err);
                }
            },
            
            // Load selected version
            async loadSelectedVersion() {
                const filename = this.versionListSelect?.value;
                if (!filename) {
                    this.updateStatus('Select a version');
                    return;
                }
                
                this.updateStatus('Loading version...');
                
                try {
                    const response = await fetch(`/api/score/version/${encodeURIComponent(filename)}`);
                    const result = await response.json();
                    
                    if (result.success) {
                        this.distributeData(result.data);
                        this.isDirty = true; // Mark as dirty since it's a version restore
                        this.updateStatus(`Restored: ${filename}`);
                        console.log(`Version loaded: ${filename}`);
                    } else {
                        this.updateStatus(`Error: ${result.error}`);
                    }
                } catch (err) {
                    this.updateStatus('Load failed');
                    console.error('Load version error:', err);
                }
            },
            
            // Update status display
            updateStatus(message) {
                if (this.statusDisplay) {
                    this.statusDisplay.textContent = message;
                }
            },
            
            // Mark score as dirty (has unsaved changes)
            markDirty() {
                if (!this.isDirty) {
                    this.isDirty = true;
                    this.updateStatus('Unsaved changes');
                }
            },
            
            // Start auto-save interval
            startAutoSave() {
                if (this.autoSaveInterval) {
                    clearInterval(this.autoSaveInterval);
                }
                
                this.autoSaveInterval = setInterval(() => {
                    if (this.isDirty && this.currentScoreName !== 'untitled') {
                        console.log('Auto-saving...');
                        this.saveScore();
                    }
                }, this.autoSaveIntervalMs);
            },
            
            // Stop auto-save
            stopAutoSave() {
                if (this.autoSaveInterval) {
                    clearInterval(this.autoSaveInterval);
                    this.autoSaveInterval = null;
                }
            }
        };
        
        // ============================================
        // NOTATION MANAGER - LilyPond SVG integration
        // ============================================
        const NotationManager = {
            // UI elements
            nameInput: null,
            widthInput: null,
            codeInput: null,
            renderBtn: null,
            placeBtn: null,
            listSelect: null,
            scaleSlider: null,
            scaleValue: null,
            statusDisplay: null,
            
            // Notation items database
            items: [],
            nextId: 1,
            
            // Currently selected notation for placement
            selectedNotation: null,
            currentScale: 1.0,
            
            // SVG container groups
            topNotationGroup: null,
            bottomNotationGroup: null,
            
            // Placed notation elements
            placedNotations: [],
            
            init() {
                // Get UI elements
                this.nameInput = document.getElementById('notationNameInput');
                this.widthInput = document.getElementById('notationWidthInput');
                this.codeInput = document.getElementById('lilypondCodeInput');
                this.renderBtn = document.getElementById('notationRenderBtn');
                this.placeBtn = document.getElementById('notationPlaceBtn');
                this.listSelect = document.getElementById('notationListSelect');
                this.scaleSlider = document.getElementById('notationScaleSlider');
                this.scaleValue = document.getElementById('notationScaleValue');
                this.statusDisplay = document.getElementById('notationStatus');
                
                // Create SVG groups for notation
                const scoreTop = document.getElementById('ScoreTop');
                const scoreBottom = document.getElementById('ScoreBottom');
                
                if (scoreTop) {
                    this.topNotationGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    this.topNotationGroup.setAttribute('class', 'notation-group');
                    scoreTop.appendChild(this.topNotationGroup);
                }
                if (scoreBottom) {
                    this.bottomNotationGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    this.bottomNotationGroup.setAttribute('class', 'notation-group');
                    scoreBottom.appendChild(this.bottomNotationGroup);
                }
                
                // Set up event listeners
                if (this.renderBtn) {
                    this.renderBtn.addEventListener('click', () => this.renderNotation());
                }
                if (this.placeBtn) {
                    this.placeBtn.addEventListener('click', () => this.placeNotation());
                }
                if (this.listSelect) {
                    this.listSelect.addEventListener('change', (e) => {
                        if (e.target.value) {
                            this.selectNotation(e.target.value);
                        }
                    });
                }
                if (this.scaleSlider) {
                    this.scaleSlider.addEventListener('input', (e) => {
                        this.currentScale = parseFloat(e.target.value);
                        if (this.scaleValue) {
                            this.scaleValue.textContent = this.currentScale.toFixed(1);
                        }
                        this.updateSelectedScale();
                    });
                }
                
                // Load existing notation list
                this.refreshNotationList();
                
                console.log('NotationManager initialized');
            },
            
            updateStatus(message) {
                if (this.statusDisplay) {
                    this.statusDisplay.textContent = message;
                }
            },
            
            async renderNotation() {
                const code = this.codeInput?.value?.trim();
                const name = this.nameInput?.value?.trim() || 'snippet';
                const lineWidth = parseInt(this.widthInput?.value) || 100;
                
                if (!code) {
                    this.updateStatus('Enter LilyPond code first');
                    return;
                }
                
                this.updateStatus('Rendering...');
                
                try {
                    const response = await fetch('/api/lilypond/render', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ code, name, lineWidth })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        // Add to local items
                        const item = {
                            id: this.nextId++,
                            name: name,
                            filename: result.filename,
                            path: result.path,
                            svg: result.svg,
                            lilypondCode: code,
                            lilypondFile: result.lilypondFile,
                            createdAt: Date.now()
                        };
                        this.items.push(item);
                        this.selectedNotation = item;
                        
                        this.refreshNotationList();
                        this.updateStatus(`Rendered: ${result.filename}`);
                        
                        // Mark score as dirty
                        if (window.ScoreManager) ScoreManager.markDirty();
                        
                        console.log('Notation rendered:', result.filename);
                    } else {
                        this.updateStatus(`Error: ${result.error}`);
                        console.error('Render failed:', result.details || result.error);
                    }
                } catch (err) {
                    this.updateStatus('Render failed');
                    console.error('Render error:', err);
                }
            },
            
            async refreshNotationList() {
                try {
                    const response = await fetch('/api/lilypond/list');
                    const files = await response.json();
                    
                    if (this.listSelect) {
                        this.listSelect.innerHTML = '<option value="">-- Rendered Notation --</option>';
                        files.forEach(file => {
                            const option = document.createElement('option');
                            option.value = file.path;
                            option.textContent = file.filename;
                            this.listSelect.appendChild(option);
                        });
                    }
                } catch (err) {
                    console.error('Error refreshing notation list:', err);
                }
            },
            
            selectNotation(path) {
                // Find in local items or create reference
                let item = this.items.find(i => i.path === path);
                if (!item) {
                    // Create a reference for server-side file
                    item = {
                        id: this.nextId++,
                        path: path,
                        filename: path.split('/').pop(),
                        name: path.split('/').pop().replace('.svg', '')
                    };
                }
                this.selectedNotation = item;
                this.updateStatus(`Selected: ${item.filename || item.name}`);
            },
            
            placeNotation() {
                if (!this.selectedNotation) {
                    this.updateStatus('Select notation first');
                    return;
                }
                
                // Get edit cursor position
                const editCursorSeconds = window.EditCursor ? EditCursor.positionSeconds : 0;
                
                // Get selected G track
                const gTrackRadio = document.querySelector('input[name="gtrack"]:checked');
                const gTrack = gTrackRadio ? gTrackRadio.value : 'A';
                
                // Determine which section based on current page
                const section = 'top'; // Default to top, could be made dynamic
                
                // Create placed notation object
                const placed = {
                    id: `notation_${Date.now()}`,
                    notationId: this.selectedNotation.id,
                    path: this.selectedNotation.path,
                    svg: this.selectedNotation.svg,
                    scoreTimeMs: editCursorSeconds * 1000,
                    gTrack: gTrack,
                    section: section,
                    scale: this.currentScale,
                    x: 0, // Will be calculated
                    y: 0, // Will be calculated based on track
                    createdAt: Date.now()
                };
                
                this.placedNotations.push(placed);
                this.renderPlacedNotation(placed);
                
                // Mark score as dirty
                if (window.ScoreManager) ScoreManager.markDirty();
                
                this.updateStatus(`Placed at ${editCursorSeconds.toFixed(2)}s`);
            },
            
            renderPlacedNotation(placed) {
                const container = placed.section === 'bottom' ? this.bottomNotationGroup : this.topNotationGroup;
                if (!container) return;
                
                // Calculate X position based on score time
                const scoreWidth = container.ownerSVGElement?.clientWidth || 1000;
                const secondsPerPage = window.GraphicTimeline ? GraphicTimeline.getSecondsPerPage() : 8;
                // Use global leadInSeconds variable
                const leadInSec = window.leadInSeconds !== undefined ? window.leadInSeconds : leadInSeconds;
                
                const totalSeconds = (placed.scoreTimeMs / 1000) + leadInSec;
                const xPercent = (totalSeconds / secondsPerPage) * 100;
                
                // Calculate Y position based on G track
                let yPosition = 50; // Default middle
                if (placed.gTrack !== 'A') {
                    const trackIndex = parseInt(placed.gTrack) - 1;
                    const trackHeight = 25; // Approximate percentage per track
                    yPosition = 10 + (trackIndex * trackHeight);
                }
                
                // Create SVG group for this notation
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'placed-notation');
                group.setAttribute('data-id', placed.id);
                group.setAttribute('transform', `translate(${xPercent}%, ${yPosition}%) scale(${placed.scale})`);
                
                // If we have inline SVG, parse and embed it
                if (placed.svg) {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(placed.svg, 'image/svg+xml');
                    const svgElement = svgDoc.documentElement;
                    
                    // Copy SVG content into our group
                    Array.from(svgElement.childNodes).forEach(child => {
                        group.appendChild(child.cloneNode(true));
                    });
                } else if (placed.path) {
                    // Use image element for external SVG
                    const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    image.setAttribute('href', placed.path);
                    image.setAttribute('x', '0');
                    image.setAttribute('y', '0');
                    group.appendChild(image);
                }
                
                // Store element reference
                placed.element = group;
                container.appendChild(group);
                
                // Make draggable
                this.makeNotationDraggable(placed);
            },
            
            makeNotationDraggable(placed) {
                if (!placed.element) return;
                
                let isDragging = false;
                let startX, startY;
                let startTransformX, startTransformY;
                
                placed.element.style.cursor = 'move';
                
                placed.element.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    // Parse current transform
                    const transform = placed.element.getAttribute('transform') || '';
                    const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    startTransformX = match ? parseFloat(match[1]) : 0;
                    startTransformY = match ? parseFloat(match[2]) : 0;
                    
                    e.preventDefault();
                    e.stopPropagation();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    
                    const newX = startTransformX + dx;
                    const newY = startTransformY + dy;
                    
                    placed.element.setAttribute('transform', 
                        `translate(${newX}, ${newY}) scale(${placed.scale})`);
                    
                    placed.x = newX;
                    placed.y = newY;
                });
                
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        if (window.ScoreManager) ScoreManager.markDirty();
                    }
                });
            },
            
            updateSelectedScale() {
                // Update scale of selected placed notation if any
                const selected = this.placedNotations.find(p => p.element && p.element.classList.contains('selected'));
                if (selected) {
                    selected.scale = this.currentScale;
                    const transform = selected.element.getAttribute('transform') || '';
                    const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    const x = match ? match[1] : '0';
                    const y = match ? match[2] : '0';
                    selected.element.setAttribute('transform', `translate(${x}, ${y}) scale(${this.currentScale})`);
                }
            },
            
            // Export data for saving
            exportData() {
                return {
                    items: this.items.map(item => ({
                        id: item.id,
                        name: item.name,
                        filename: item.filename,
                        path: item.path,
                        lilypondCode: item.lilypondCode,
                        createdAt: item.createdAt
                    })),
                    placedNotations: this.placedNotations.map(p => ({
                        id: p.id,
                        notationId: p.notationId,
                        path: p.path,
                        scoreTimeMs: p.scoreTimeMs,
                        gTrack: p.gTrack,
                        section: p.section,
                        scale: p.scale,
                        x: p.x,
                        y: p.y,
                        createdAt: p.createdAt
                    })),
                    nextId: this.nextId
                };
            },
            
            // Import data from saved score
            importData(data) {
                if (!data) return;
                
                // Clear existing
                this.items = [];
                this.placedNotations.forEach(p => {
                    if (p.element) p.element.remove();
                });
                this.placedNotations = [];
                
                // Import items
                if (data.items) {
                    this.items = data.items;
                }
                if (data.nextId) {
                    this.nextId = data.nextId;
                }
                
                // Import and render placed notations
                if (data.placedNotations) {
                    data.placedNotations.forEach(p => {
                        this.placedNotations.push(p);
                        this.renderPlacedNotation(p);
                    });
                }
                
                this.refreshNotationList();
                console.log(`NotationManager: Imported ${this.items.length} items, ${this.placedNotations.length} placed`);
            },
            
            // Reload all placed notations (recalculate positions based on current leadInSeconds)
            reloadPlacedNotations() {
                // Re-render each placed notation with updated positions
                this.placedNotations.forEach(p => {
                    if (p.element) {
                        p.element.remove();
                    }
                    this.renderPlacedNotation(p);
                });
            },
            
            // Place string quartet staff labels in the lead-in area (before time 0)
            placeStaffLabels(svgPath = '/notation/string_quartet_template.svg') {
                const scoreTop = document.getElementById('ScoreTop');
                const scoreBottom = document.getElementById('ScoreBottom');
                if (!scoreTop || !scoreBottom) return;
                
                // Get dimensions
                const scoreHeight = scoreTop.clientHeight;
                const scoreWidth = scoreTop.clientWidth;
                const timelineHeight = 8; // Match GraphicTimeline
                const trackHeight = (scoreHeight - timelineHeight) / 4;
                
                // Calculate position: place at the start of lead-in, before time 0
                // Use global leadInSeconds variable
                const leadInSec = window.leadInSeconds !== undefined ? window.leadInSeconds : leadInSeconds;
                const secondsPerPage = window.GraphicTimeline ? GraphicTimeline.getSecondsPerPage() : 8;
                
                // Position just before time 0 - calculate X so the right edge is at time 0
                // Time 0 is at (leadInSeconds / secondsPerPage) * 100 percent
                const time0Percent = (leadInSeconds / secondsPerPage) * 100;
                const xPosition = 5; // Start 5px from left edge
                
                // Create image element for the SVG
                const staffLabels = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                staffLabels.setAttribute('href', svgPath);
                staffLabels.setAttribute('x', xPosition);
                staffLabels.setAttribute('y', timelineHeight);
                staffLabels.setAttribute('class', 'staff-labels');
                
                // Scale to fit the track area height (4 tracks)
                const availableHeight = scoreHeight - timelineHeight;
                staffLabels.setAttribute('height', availableHeight);
                staffLabels.setAttribute('preserveAspectRatio', 'xMinYMin meet');
                
                // Add to ScoreTop only (page 1) - not on subsequent pages
                if (this.topNotationGroup) {
                    // Remove any existing staff labels
                    const existing = this.topNotationGroup.querySelector('.staff-labels');
                    if (existing) existing.remove();
                    
                    this.topNotationGroup.appendChild(staffLabels);
                    console.log('Staff labels placed in lead-in area (page 1 only)');
                }
                
                // Remove from ScoreBottom if it exists (we only want it on page 1)
                if (this.bottomNotationGroup) {
                    const existingBottom = this.bottomNotationGroup.querySelector('.staff-labels');
                    if (existingBottom) existingBottom.remove();
                }
            }
        };
        
        // Color map for swatches
        const ColorMap = {
            brightOrange: 'rgba(240,75,0,255)',
            brightBlue: 'rgba(56,126,211,255)',
            mustard: 'rgba(244,182,0,255)',
            brightRed: 'rgba(229,42,25,255)',
            green: 'rgba(0,147,92,255)',
            limeGreen: 'rgb(153,255,0)',
            brightGreen: '#31d196',
            navyBlue: 'rgba(28,72,121,255)',
            plum: 'rgba(82,44,85,255)',
            lavander: 'rgba(162,126,198,255)',
            yellow: 'rgba(254,213,0,255)',
            neonMagenta: 'rgb(255, 21, 160)'
        };
        
        // Curve Maker - creates and manages curves on the timeline
        // Features: auto-naming (CRV###), selection with bounding box, DAW-style curve drag
        const CurveMaker = {
            scoreTopEl: null,
            scoreBottomEl: null,
            topCurveGroup: null,
            bottomCurveGroup: null,
            
            // Rendered curves with elements
            curves: [],
            
            // UI elements
            nameDisplay: null,
            startInput: null,
            endInput: null,
            y1Input: null,
            y2Input: null,
            drawBtn: null,
            
            // Curve naming
            curveCounter: 0,
            
            // Selected curve
            selectedCurve: null,
            
            // Dragging state
            isDragging: false,
            dragTarget: null,  // 'start', 'end', 'curve'
            dragStartX: 0,
            dragStartY: 0,
            
            // Segment extraction state
            segmentX1Line: null,
            segmentX2Line: null,
            segmentX1Seconds: null,
            segmentX2Seconds: null,
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Get UI elements
                this.nameDisplay = document.getElementById('curveNameDisplay');
                this.startInput = document.getElementById('curveStartInput');
                this.endInput = document.getElementById('curveEndInput');
                this.y1Input = document.getElementById('curveY1Input');
                this.y2Input = document.getElementById('curveY2Input');
                this.drawBtn = document.getElementById('curveDrawBtn');
                this.saveBtn = document.getElementById('curveSaveBtn');
                this.descriptionInput = document.getElementById('curveDescriptionInput');
                this.recallSelect = document.getElementById('curveRecallSelect');
                this.recallDropdown = document.getElementById('curveRecallDropdown');
                this.recallSelected = document.getElementById('curveRecallSelected');
                this.recallOptions = document.getElementById('curveRecallOptions');
                this.insertBtn = document.getElementById('curveInsertBtn');
                
                // Custom dropdown toggle handler
                if (this.recallSelected) {
                    this.recallSelected.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = this.recallOptions.style.display !== 'none';
                        this.recallOptions.style.display = isOpen ? 'none' : 'block';
                    });
                }
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (this.recallOptions && !this.recallDropdown?.contains(e.target)) {
                        this.recallOptions.style.display = 'none';
                    }
                });
                
                // Segment extraction UI elements
                this.segmentX1Btn = document.getElementById('segmentX1Btn');
                this.segmentX1Input = document.getElementById('segmentX1Input');
                this.segmentX2Btn = document.getElementById('segmentX2Btn');
                this.segmentX2Input = document.getElementById('segmentX2Input');
                this.segmentCreateBtn = document.getElementById('segmentCreateBtn');
                this.segmentClearBtn = document.getElementById('segmentClearBtn');
                
                // Create curve container groups
                this.topCurveGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.bottomCurveGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.topCurveGroup.setAttribute('class', 'curve-container');
                this.bottomCurveGroup.setAttribute('class', 'curve-container');
                this.scoreTopEl.appendChild(this.topCurveGroup);
                this.scoreBottomEl.appendChild(this.bottomCurveGroup);
                
                // Draw button handler
                this.drawBtn.addEventListener('click', () => this.createCurve());
                
                // Save button handler - save selected curve to library
                this.saveBtn.addEventListener('click', () => this.saveCurveToLibrary());
                
                // Insert button handler - insert recalled curve at edit line
                this.insertBtn.addEventListener('click', () => this.insertRecalledCurve());
                
                // Load curve library on init
                this.loadCurveLibrary();
                
                // Segment extraction handlers
                if (this.segmentX1Btn) {
                    this.segmentX1Btn.addEventListener('click', () => this.setSegmentX1());
                }
                if (this.segmentX1Input) {
                    this.segmentX1Input.addEventListener('change', () => this.updateSegmentX1FromInput());
                }
                if (this.segmentX2Btn) {
                    this.segmentX2Btn.addEventListener('click', () => this.setSegmentX2());
                }
                if (this.segmentX2Input) {
                    this.segmentX2Input.addEventListener('change', () => this.updateSegmentX2FromInput());
                }
                if (this.segmentCreateBtn) {
                    this.segmentCreateBtn.addEventListener('click', () => this.createSegment());
                }
                if (this.segmentClearBtn) {
                    this.segmentClearBtn.addEventListener('click', () => this.clearSegmentLines());
                }
                
                // Color swatch handlers - dynamic for selected curve
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.addEventListener('click', (e) => {
                        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                        e.target.classList.add('selected');
                        const newColor = e.target.dataset.color;
                        if (this.selectedCurve) {
                            this.selectedCurve.color = newColor;
                            this.updateCurveRendering(this.selectedCurve);
                            this.syncCurveToDatabase(this.selectedCurve);
                            // Update visibility to refresh continuation segments
                            this.updateVisibility();
                        }
                    });
                });
                
                // Fill mode handlers - dynamic for selected curve
                document.querySelectorAll('input[name="curveFill"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        const newFillMode = e.target.value;
                        if (this.selectedCurve) {
                            this.selectedCurve.fillMode = newFillMode;
                            this.updateCurveRendering(this.selectedCurve);
                            this.syncCurveToDatabase(this.selectedCurve);
                            // Update visibility to refresh continuation segments
                            this.updateVisibility();
                        }
                    });
                });
                
                // Input field handlers - dynamic for selected curve
                this.startInput.addEventListener('change', () => this.updateSelectedFromInputs());
                this.endInput.addEventListener('change', () => this.updateSelectedFromInputs());
                this.y1Input.addEventListener('change', () => this.updateSelectedFromInputs());
                this.y2Input.addEventListener('change', () => this.updateSelectedFromInputs());
                
                // Click on score to deselect
                this.scoreTopEl.addEventListener('click', (e) => this.handleScoreClick(e, 'top'));
                this.scoreBottomEl.addEventListener('click', (e) => this.handleScoreClick(e, 'bottom'));
                
                // Delete button handler
                this.deleteBtn = document.getElementById('curveDeleteBtn');
                if (this.deleteBtn) {
                    this.deleteBtn.addEventListener('click', () => this.deleteSelectedCurve());
                }
                
                // Re-render curves on window resize (debounced)
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.reloadFromDatabase();
                    }, 100);
                });
                
                console.log('CurveMaker initialized');
            },
            
            generateCurveName() {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                return `CRV_${year}${month}${day}_${hours}${minutes}${seconds}`;
            },
            
            generateCurveDataArray(curve) {
                // TIMECODE-BASED SYSTEM: Generate samples at fixed time intervals
                // Sample rate: 100 samples/second (10ms intervals) for smooth curves
                // Each entry contains normalized Y value
                // For G1-G4: normalized 0-1 from bottom to top of track
                // For GA: normalized 0-1 from bottom of page to top of cursor area
                
                const SAMPLE_INTERVAL = 0.01; // 10ms = 100 samples/second
                const startTime = curve.startSeconds;
                const endTime = curve.endSeconds;
                const duration = endTime - startTime;
                
                if (duration <= 0) return { startTime, endTime, sampleInterval: SAMPLE_INTERVAL, samples: [] };
                
                const sampleCount = Math.ceil(duration / SAMPLE_INTERVAL) + 1;
                const samples = [];
                const slope = curve.slope || 0;
                
                // Use normalized Y values (0-10 scale) for consistent curve data
                // These are the authoritative values, not the pixel values which can change
                const y1Norm = curve.y1 / 10;  // 0 to 1
                const y2Norm = curve.y2 / 10;  // 0 to 1
                
                // Calculate control point Y in normalized space (same logic as rendering)
                const ctrlYNorm = slope >= 0 
                    ? y1Norm + (y2Norm - y1Norm) * (1 - Math.abs(slope)) * 0.5
                    : y2Norm - (y2Norm - y1Norm) * (1 - Math.abs(slope)) * 0.5;
                
                // Calculate control point X position in normalized space (0 to 1)
                // ctrlX is at 0.5 + slope * 0.45 of the curve width
                const ctrlXNorm = 0.5 + slope * 0.45;
                
                // Generate samples at fixed time intervals
                for (let i = 0; i < sampleCount; i++) {
                    const time = startTime + (i * SAMPLE_INTERVAL);
                    
                    // Calculate normalized position (0 to 1) based on time
                    const timeT = Math.min(1, (time - startTime) / duration);
                    
                    // For a quadratic bezier in normalized X space (0 to 1):
                    // X(t) = (1-t)²*0 + 2(1-t)t*ctrlXNorm + t²*1
                    // We need to find t such that X(t) = timeT
                    // Solve: 2(1-t)t*ctrlXNorm + t² = timeT
                    // Rearranging: t²(1 - 2*ctrlXNorm) + t*2*ctrlXNorm - timeT = 0
                    const a = 1 - 2 * ctrlXNorm;
                    const b = 2 * ctrlXNorm;
                    const c = -timeT;
                    
                    let t;
                    if (Math.abs(a) < 0.0001) {
                        // Linear case (ctrlXNorm is at 0.5)
                        t = timeT;
                    } else {
                        // Quadratic formula: t = (-b + sqrt(b² - 4ac)) / 2a
                        const discriminant = b * b - 4 * a * c;
                        if (discriminant < 0) {
                            t = timeT; // Fallback
                        } else {
                            const sqrtD = Math.sqrt(discriminant);
                            const t1 = (-b + sqrtD) / (2 * a);
                            const t2 = (-b - sqrtD) / (2 * a);
                            // Choose t in range [0, 1]
                            t = (t1 >= 0 && t1 <= 1) ? t1 : t2;
                            t = Math.max(0, Math.min(1, t));
                        }
                    }
                    
                    // Now calculate Y using the correct t value in normalized space
                    // Quadratic bezier: B(t) = (1-t)²P0 + 2(1-t)tP1 + t²P2
                    const oneMinusT = 1 - t;
                    const normalizedY = oneMinusT * oneMinusT * y1Norm 
                                      + 2 * oneMinusT * t * ctrlYNorm 
                                      + t * t * y2Norm;
                    
                    // Clamp to valid range
                    samples.push(Math.max(0, Math.min(1, normalizedY)));
                }
                
                return {
                    startTime,
                    endTime,
                    sampleInterval: SAMPLE_INTERVAL,
                    samples  // Array of normalizedY values, indexed by time
                };
            },
            
            createCurve() {
                const startSeconds = parseFloat(this.startInput.value) || 0;
                const endSeconds = parseFloat(this.endInput.value) || 1;
                const y1 = parseFloat(this.y1Input.value) || 0;
                const y2 = parseFloat(this.y2Input.value) || 10;
                const gTrack = CompositionPanel.getSelectedGTrack();
                
                // Get current fill mode and color from UI
                const fillMode = document.querySelector('input[name="curveFill"]:checked').value;
                const colorSwatch = document.querySelector('.color-swatch.selected');
                const color = colorSwatch ? colorSwatch.dataset.color : 'brightOrange';
                
                // Get track dimensions - use the section where the curve starts
                // Note: Both top and bottom sections have the same coordinate system
                const trackDims = CompositionPanel.getSelectedTrackDimensions(this.scoreTopEl);
                // Store gTrack for later use in multi-page rendering
                const gTrackForDims = CompositionPanel.getSelectedGTrack();
                
                // Calculate pixel positions
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                // Determine which page(s) the curve spans
                const startActual = startSeconds + leadInSeconds;
                const endActual = endSeconds + leadInSeconds;
                const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                
                // Draw on the start page
                const section = startPage % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const curveGroup = section === 'top' ? this.topCurveGroup : this.bottomCurveGroup;
                const scoreWidth = scoreEl.clientWidth;
                
                // Calculate X positions as percentages within the page
                const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                
                // Calculate Y positions (0 = bottom of track, 10 = top of track)
                const trackBottom = trackDims.y + trackDims.height;
                const y1Pixel = trackBottom - (y1 / 10) * trackDims.height;
                const y2Pixel = trackBottom - (y2 / 10) * trackDims.height;
                
                // Calculate pixel positions
                const x1Pixel = (startXPercent / 100) * scoreWidth;
                const x2Pixel = (endXPercent / 100) * scoreWidth;
                
                // DAW-style curve: single control point for curvature (tension)
                // tension: 0 = straight line, positive = curve up, negative = curve down
                const tension = 0;
                
                // Generate unique name
                const name = this.generateCurveName();
                
                // Create curve data
                const curveDataObj = {
                    name,
                    startSeconds,
                    endSeconds,
                    y1,
                    y2,
                    gTrack,
                    color,
                    fillMode,
                    section,
                    page: startPage,
                    x1: x1Pixel,
                    y1Pixel,
                    x2: x2Pixel,
                    y2Pixel,
                    // Store original values for multi-page clipping
                    origY1Pixel: y1Pixel,
                    origY2Pixel: y2Pixel,
                    tension,  // DAW-style: vertical drag changes depth
                    slope: 0,  // DAW-style: horizontal drag shifts apex position
                    trackDims
                };
                
                // Generate curveData array (normalized Y values for each horizontal pixel)
                const curveDataArray = this.generateCurveDataArray(curveDataObj);
                curveDataObj.curveData = curveDataArray;
                
                // Add to database
                const curve = CurveDatabase.add(curveDataObj);
                
                // Mark score as dirty (has unsaved changes)
                if (window.ScoreManager) ScoreManager.markDirty();
                
                // Add to G Track graphic data
                if (gTrack !== 'A') {
                    const trackIndex = parseInt(gTrack) - 1;
                    if (window.GTrackSystem) {
                        GTrackSystem.addGraphicItem(trackIndex, {
                            type: 'curve',
                            curveId: curve.id,
                            curveName: curve.name,
                            color: color,
                            fillMode: fillMode,
                            scoreTimeMs: startSeconds * 1000,
                            duration: (endSeconds - startSeconds) * 1000,
                            curveData: curveDataArray
                        });
                    }
                }
                
                // Render the curve
                this.renderCurve(curve, curveGroup, scoreEl);
                
                // Add to curves array for connector system
                this.curves.push(curve);
                
                // Update visibility to handle multi-page curves
                this.updateVisibility();
                
                // Auto-select the new curve
                this.selectCurve(curve);
                
                console.log(`Curve created: ${curve.name} (ID: ${curve.id})`);
            },
            
            renderCurve(curve, curveGroup, scoreEl) {
                const color = ColorMap[curve.color] || curve.color;
                
                // Create SVG group for this curve
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('data-curve-id', curve.id);
                group.setAttribute('class', 'curve-element');
                
                // DAW-style curve shaping:
                // slope controls where the "knee" is (-1 = left edge, +1 = right edge)
                // Drag right = flat at start, steep rise at end
                // Drag left = steep rise at start, flat at end
                // Curve stays within Y bounds of endpoints (no protrusion)
                const slope = curve.slope || 0;
                const curveWidth = curve.x2 - curve.x1;
                
                // Control point X: slope moves it from left edge to right edge
                // slope -1 = control at x1, slope +1 = control at x2, slope 0 = middle
                const ctrlX = curve.x1 + (curveWidth * (0.5 + slope * 0.45));
                
                // Control point Y: stays at the Y value of the opposite endpoint
                // This creates the "flat then steep" or "steep then flat" effect
                // When slope > 0 (dragging right): ctrl Y near y1 (start), curve flat then rises
                // When slope < 0 (dragging left): ctrl Y near y2 (end), curve rises then flat
                const ctrlY = slope >= 0 
                    ? curve.y1Pixel + (curve.y2Pixel - curve.y1Pixel) * (1 - Math.abs(slope)) * 0.5
                    : curve.y2Pixel - (curve.y2Pixel - curve.y1Pixel) * (1 - Math.abs(slope)) * 0.5;
                
                // Create the quadratic bezier path
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const d = `M ${curve.x1} ${curve.y1Pixel} Q ${ctrlX} ${ctrlY}, ${curve.x2} ${curve.y2Pixel}`;
                
                if (curve.fillMode === 'line' || !curve.trackDims) {
                    // Line mode or missing trackDims - just draw the curve
                    path.setAttribute('d', d);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('opacity', '0.3');
                } else {
                    const fillY = curve.fillMode === 'bottom' ? curve.trackDims.y + curve.trackDims.height : curve.trackDims.y;
                    const filledD = `M ${curve.x1} ${fillY} L ${curve.x1} ${curve.y1Pixel} Q ${ctrlX} ${ctrlY}, ${curve.x2} ${curve.y2Pixel} L ${curve.x2} ${fillY} Z`;
                    path.setAttribute('d', filledD);
                    path.setAttribute('fill', color);
                    path.setAttribute('fill-opacity', '0.3');
                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('opacity', '0.3');
                }
                
                path.style.cursor = 'pointer';
                group.appendChild(path);
                
                // Create invisible wider hit area for easier clicking on the curve
                const hitPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                hitPath.setAttribute('d', d);
                hitPath.setAttribute('fill', 'none');
                hitPath.setAttribute('stroke', 'transparent');
                hitPath.setAttribute('stroke-width', '20');
                hitPath.style.cursor = 'pointer';
                hitPath.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'curve'));
                path.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'curve'));
                group.appendChild(hitPath);
                
                // Create draggable endpoint circles
                const pointRadius = 6;
                
                // Start point
                const startPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                startPoint.setAttribute('cx', curve.x1);
                startPoint.setAttribute('cy', curve.y1Pixel);
                startPoint.setAttribute('r', pointRadius);
                startPoint.setAttribute('fill', color);
                startPoint.setAttribute('stroke', '#fff');
                startPoint.setAttribute('stroke-width', '2');
                startPoint.style.cursor = 'ns-resize';
                startPoint.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'start'));
                group.appendChild(startPoint);
                
                // End point
                const endPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                endPoint.setAttribute('cx', curve.x2);
                endPoint.setAttribute('cy', curve.y2Pixel);
                endPoint.setAttribute('r', pointRadius);
                endPoint.setAttribute('fill', color);
                endPoint.setAttribute('stroke', '#fff');
                endPoint.setAttribute('stroke-width', '2');
                endPoint.style.cursor = 'ns-resize';
                endPoint.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'end'));
                group.appendChild(endPoint);
                
                // Bounding box (hidden by default, colored to match curve)
                const bbox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bbox.setAttribute('class', 'curve-bounding-box');
                bbox.setAttribute('stroke', color);
                bbox.setAttribute('fill', color);
                bbox.style.display = 'none';
                bbox.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'bbox'));
                group.insertBefore(bbox, path);
                
                // Store element references
                curve.elements = {
                    group,
                    path,
                    hitPath,
                    startPoint,
                    endPoint,
                    boundingBox: bbox
                };
                
                curveGroup.appendChild(group);
                this.updateBoundingBox(curve);
            },
            
            handleCurveMouseDown(e, curve, target) {
                e.preventDefault();
                e.stopPropagation();
                
                // Select this curve
                this.selectCurve(curve);
                
                // If clicking on bounding box (not on curve/endpoints), just select, don't drag
                if (target === 'bbox') return;
                
                // Start dragging
                this.isDragging = true;
                this.dragTarget = target;
                this.dragStartX = e.clientX;
                this.dragStartY = e.clientY;
                
                // All controls are on the first segment, so use its section
                const scoreEl = curve.section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const rect = scoreEl.getBoundingClientRect();
                const trackDims = curve.trackDims;
                
                // Store initial curve state for curve drag
                const initialTension = curve.tension;
                const initialSlope = curve.slope || 0;  // slope: shifts the apex left/right
                const initialY1 = curve.y1Pixel;
                const initialY2 = curve.y2Pixel;
                
                const onMouseMove = (e) => {
                    if (!this.isDragging) return;
                    
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const deltaX = e.clientX - this.dragStartX;
                    const deltaY = e.clientY - this.dragStartY;
                    
                    // Clamp Y to track bounds
                    const clampedY = Math.max(trackDims.y, Math.min(trackDims.y + trackDims.height, y));
                    
                    switch (this.dragTarget) {
                        case 'start':
                            // Vertical only - X stays fixed
                            // Update both current and original Y values for multi-page support
                            curve.y1Pixel = clampedY;
                            curve.origY1Pixel = clampedY;
                            // Also update normalized y1 value
                            curve.y1 = ((trackDims.y + trackDims.height - clampedY) / trackDims.height) * 10;
                            break;
                        case 'end':
                            // Vertical only - X stays fixed
                            // Update both current and original Y values for multi-page support
                            curve.y2Pixel = clampedY;
                            curve.origY2Pixel = clampedY;
                            // Also update normalized y2 value
                            curve.y2 = ((trackDims.y + trackDims.height - clampedY) / trackDims.height) * 10;
                            break;
                        case 'curve':
                        case 'preview':
                            // DAW-style curve shaping - horizontal drag only
                            // Maps mouse X position within first segment bounds to slope (-1 to +1)
                            // For multi-page curves, use first segment (curve.x1 to page edge)
                            // Drag right = flat start, steep end (slope +1)
                            // Drag left = steep start, flat end (slope -1)
                            
                            // Use first segment bounds for slope calculation
                            const segmentLeft = curve.x1;
                            const segmentRight = scoreEl.clientWidth; // Page edge for multi-page, or curve.x2 for single
                            const isMultiPageCurve = curve.x2 > scoreEl.clientWidth;
                            const segmentWidth = (isMultiPageCurve ? segmentRight : curve.x2) - segmentLeft;
                            
                            if (segmentWidth > 0) {
                                // Map mouse X to slope: left edge = -1, right edge = +1
                                const relativeX = (x - segmentLeft) / segmentWidth;
                                curve.slope = Math.max(-1, Math.min(1, (relativeX - 0.5) * 2));
                            }
                            break;
                    }
                    
                    // Update input fields
                    this.updateInputsFromCurve(curve);
                    
                    // Re-render curve (primary segment)
                    this.updateCurveRendering(curve);
                    this.updateBoundingBox(curve);
                    
                    // Update all segments for multi-page curves
                    this.updateVisibility();
                    
                    // Update preview curve for multi-page curves
                    this.updatePreviewCurve(curve);
                    
                    // Sync to database
                    this.syncCurveToDatabase(curve);
                };
                
                const onMouseUp = () => {
                    this.isDragging = false;
                    this.dragTarget = null;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            },
            
            handleScoreClick(e, section) {
                // Check if click was on a curve element
                if (e.target.closest('.curve-element')) return;
                
                // Deselect current curve
                this.deselectCurve();
            },
            
            selectCurve(curve) {
                // Deselect previous
                if (this.selectedCurve && this.selectedCurve !== curve) {
                    this.deselectCurve();
                }
                
                this.selectedCurve = curve;
                
                // Show bounding box and endpoint circles on first segment only
                // For multi-page curves, all controls are on the first segment
                if (curve.elements) {
                    if (curve.elements.boundingBox) curve.elements.boundingBox.style.display = 'block';
                    if (curve.elements.startPoint) curve.elements.startPoint.style.display = 'block';
                    if (curve.elements.endPoint) curve.elements.endPoint.style.display = 'block';
                    
                    // Show preview curve for multi-page curves
                    this.updatePreviewCurve(curve);
                }
                
                // Update UI to reflect selected curve
                this.nameDisplay.value = curve.name;
                this.updateInputsFromCurve(curve);
                
                // Update color swatch selection
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                const matchingSwatch = document.querySelector(`.color-swatch[data-color="${curve.color}"]`);
                if (matchingSwatch) matchingSwatch.classList.add('selected');
                
                // Update fill mode selection
                document.querySelector(`input[name="curveFill"][value="${curve.fillMode}"]`).checked = true;
            },
            
            deselectCurve() {
                if (this.selectedCurve && this.selectedCurve.elements) {
                    // Hide all controls on first segment
                    if (this.selectedCurve.elements.boundingBox) this.selectedCurve.elements.boundingBox.style.display = 'none';
                    if (this.selectedCurve.elements.startPoint) this.selectedCurve.elements.startPoint.style.display = 'none';
                    if (this.selectedCurve.elements.endPoint) this.selectedCurve.elements.endPoint.style.display = 'none';
                    // Hide preview curve and hit path
                    if (this.selectedCurve.elements.previewPath) this.selectedCurve.elements.previewPath.style.display = 'none';
                    if (this.selectedCurve.elements.previewHitPath) this.selectedCurve.elements.previewHitPath.style.display = 'none';
                }
                this.selectedCurve = null;
                this.nameDisplay.value = '';
            },
            
            // Create/update preview curve showing entire curve shape within the first segment
            // For multi-page curves, this is the INTERACTIVE controller for the entire curve
            updatePreviewCurve(curve) {
                if (!curve.elements || !curve.elements.boundingBox) return;
                if (!curve.trackDims) return;
                
                const secondsPerPage = window.GraphicTimeline ? GraphicTimeline.getSecondsPerPage() : 8;
                const leadInSec = leadInSeconds;
                
                // Check if this is a multi-page curve
                const startActual = curve.startSeconds + leadInSec;
                const endActual = curve.endSeconds + leadInSec;
                const curveStartPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                const curveEndPage = Math.floor(Math.max(0, endActual) / secondsPerPage);
                
                const isMultiPage = curveEndPage > curveStartPage;
                
                // Create preview elements if they don't exist
                if (!curve.elements.previewPath) {
                    const previewPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    previewPath.setAttribute('class', 'curve-preview');
                    previewPath.setAttribute('fill', 'none');
                    previewPath.setAttribute('stroke-width', '2');
                    previewPath.setAttribute('stroke-dasharray', '4,3');
                    previewPath.setAttribute('opacity', '0.9');
                    previewPath.style.cursor = 'ew-resize';
                    // Make preview path interactive for slope adjustment
                    previewPath.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'preview'));
                    curve.elements.group.appendChild(previewPath);
                    curve.elements.previewPath = previewPath;
                    
                    // Create hit area for preview curve
                    const previewHitPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    previewHitPath.setAttribute('fill', 'none');
                    previewHitPath.setAttribute('stroke', 'transparent');
                    previewHitPath.setAttribute('stroke-width', '20');
                    previewHitPath.style.cursor = 'ew-resize';
                    previewHitPath.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'preview'));
                    curve.elements.group.appendChild(previewHitPath);
                    curve.elements.previewHitPath = previewHitPath;
                }
                
                const previewPath = curve.elements.previewPath;
                const previewHitPath = curve.elements.previewHitPath;
                const color = ColorMap[curve.color] || curve.color;
                previewPath.setAttribute('stroke', color);
                
                if (!isMultiPage) {
                    // Single page curve - hide preview (solid curve is the controller)
                    previewPath.style.display = 'none';
                    if (previewHitPath) previewHitPath.style.display = 'none';
                    return;
                }
                
                // Multi-page curve - show preview as the controller
                previewPath.style.display = 'block';
                if (previewHitPath) previewHitPath.style.display = 'block';
                
                // Get first segment bounds (from curve.x1 to page edge)
                const scoreEl = curve.section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                const segmentX1 = curve.x1;
                const segmentX2 = scoreWidth;
                
                // Preview spans the full first segment width
                const previewX1 = segmentX1;
                const previewX2 = segmentX2;
                
                // Preview Y uses the FULL track height for control points
                // This allows full Y range adjustment even though it's a scaled representation
                const trackTop = curve.trackDims.y;
                const trackBottom = curve.trackDims.y + curve.trackDims.height;
                const trackHeight = curve.trackDims.height;
                
                // Map normalized Y values (0-10) to track coordinates
                const previewY1 = trackBottom - (curve.y1 / 10) * trackHeight;
                const previewY2 = trackBottom - (curve.y2 / 10) * trackHeight;
                
                // Calculate control point for preview using the curve's slope
                const slope = curve.slope || 0;
                const previewWidth = previewX2 - previewX1;
                const ctrlXOffset = previewWidth * 0.5 * (1 + slope);
                const ctrlX = previewX1 + ctrlXOffset;
                
                // Control point Y based on slope direction
                const ctrlY = slope >= 0 
                    ? previewY1 + (previewY2 - previewY1) * (1 - Math.abs(slope)) * 0.5
                    : previewY2 - (previewY2 - previewY1) * (1 - Math.abs(slope)) * 0.5;
                
                const pathD = `M ${previewX1} ${previewY1} Q ${ctrlX} ${ctrlY} ${previewX2} ${previewY2}`;
                previewPath.setAttribute('d', pathD);
                if (previewHitPath) previewHitPath.setAttribute('d', pathD);
                
                // Update control point positions to match preview endpoints
                if (curve.elements.startPoint) {
                    curve.elements.startPoint.setAttribute('cx', previewX1);
                    curve.elements.startPoint.setAttribute('cy', previewY1);
                }
                if (curve.elements.endPoint) {
                    curve.elements.endPoint.setAttribute('cx', previewX2);
                    curve.elements.endPoint.setAttribute('cy', previewY2);
                }
            },
            
            // Show/hide curves based on current page (supports multi-page curves)
            updateVisibility() {
                if (!window.GraphicTimeline) return;
                
                const topPage = GraphicTimeline.currentTopPage;
                const bottomPage = GraphicTimeline.currentBottomPage;
                const secondsPerPage = GraphicTimeline.getSecondsPerPage();
                // Use the global leadInSeconds variable directly
                const leadInSec = leadInSeconds;
                
                // Iterate directly over CurveMaker.curves
                for (let i = 0; i < CurveMaker.curves.length; i++) {
                    const curve = CurveMaker.curves[i];
                    if (!curve.elements || !curve.elements.group) continue;
                    
                    // Calculate which pages this curve spans
                    const startActual = curve.startSeconds + leadInSec;
                    const endActual = curve.endSeconds + leadInSec;
                    const curveStartPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                    const curveEndPage = Math.floor(Math.max(0, endActual) / secondsPerPage);
                    
                    // Check if curve overlaps with EITHER visible page (top or bottom)
                    const overlapsTop = curveStartPage <= topPage && curveEndPage >= topPage;
                    const overlapsBottom = curveStartPage <= bottomPage && curveEndPage >= bottomPage;
                    const visible = overlapsTop || overlapsBottom;
                    
                    // For multi-page curves, we need to show segments on BOTH visible pages
                    const isMultiPage = curveEndPage > curveStartPage;
                    
                    if (!isMultiPage) {
                        // Single-page curve: simple show/hide
                        curve.elements.group.style.display = visible ? '' : 'none';
                        // Hide continuation segment if it exists
                        if (curve.elements.continuationGroup) {
                            curve.elements.continuationGroup.style.display = 'none';
                        }
                    } else {
                        // Multi-page curve: show segments on each visible page
                        // Original segment on original page (clipped to page end)
                        if (overlapsTop && topPage === curveStartPage) {
                            curve.elements.group.style.display = '';
                            this.clipCurveToPageEnd(curve, curveStartPage, secondsPerPage, leadInSec);
                        } else if (overlapsBottom && bottomPage === curveStartPage) {
                            curve.elements.group.style.display = '';
                            this.clipCurveToPageEnd(curve, curveStartPage, secondsPerPage, leadInSec);
                        } else {
                            curve.elements.group.style.display = 'none';
                        }
                        
                        // Continuation segments on subsequent pages
                        // For curves spanning 3+ pages, we may need segments on BOTH visible pages
                        const showContinuationOnTop = overlapsTop && topPage > curveStartPage && topPage <= curveEndPage;
                        const showContinuationOnBottom = overlapsBottom && bottomPage > curveStartPage && bottomPage <= curveEndPage;
                        
                        // Show continuation on top page
                        if (showContinuationOnTop) {
                            this.showContinuationSegment(curve, topPage, secondsPerPage, leadInSec, 'top');
                        } else if (curve.elements.continuationGroupTop) {
                            curve.elements.continuationGroupTop.style.display = 'none';
                        }
                        
                        // Show continuation on bottom page
                        if (showContinuationOnBottom) {
                            this.showContinuationSegment(curve, bottomPage, secondsPerPage, leadInSec, 'bottom');
                        } else if (curve.elements.continuationGroupBottom) {
                            curve.elements.continuationGroupBottom.style.display = 'none';
                        }
                        
                        // Hide old single continuation group if it exists
                        if (curve.elements.continuationGroup) {
                            curve.elements.continuationGroup.style.display = 'none';
                        }
                    }
                }
            },
            
            // Clip the original curve segment to end at the page boundary
            // Uses curveData samples for pixel-accurate rendering
            clipCurveToPageEnd(curve, page, secondsPerPage, leadInSec) {
                if (!curve.elements || !curve.elements.path) return;
                
                const startActual = curve.startSeconds + leadInSec;
                const endActual = curve.endSeconds + leadInSec;
                const pageEndTime = (page + 1) * secondsPerPage;
                
                // If curve ends before page end, use original rendering
                if (endActual <= pageEndTime) {
                    this.restoreOriginalRendering(curve);
                    return;
                }
                
                const section = page % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                
                // Use curveData samples for pixel-accurate curve rendering
                const pathD = this.generatePathFromCurveData(curve, curve.startSeconds, 
                    pageEndTime - leadInSec, scoreEl, curve.x1, scoreWidth);
                
                if (pathD) {
                    curve.elements.path.setAttribute('d', pathD);
                    if (curve.elements.hitPath) curve.elements.hitPath.setAttribute('d', pathD);
                }
                
                // Ensure in correct container
                const targetContainer = section === 'top' ? this.topCurveGroup : this.bottomCurveGroup;
                if (curve.elements.group.parentNode !== targetContainer) {
                    targetContainer.appendChild(curve.elements.group);
                }
            },
            
            // Generate SVG path from curveData samples for pixel-accurate rendering
            // This uses the same data as the curve follower for perfect alignment
            generatePathFromCurveData(curve, startSec, endSec, scoreEl, x1Pixel, x2Pixel) {
                if (!curve.curveData || !curve.curveData.samples || curve.curveData.samples.length === 0) {
                    return null;
                }
                
                const { startTime, endTime, sampleInterval, samples } = curve.curveData;
                const trackDims = curve.trackDims;
                if (!trackDims) return null;
                
                const trackTop = trackDims.y;
                const trackBottom = trackDims.y + trackDims.height;
                const trackHeight = trackDims.height;
                
                // Clamp to curve bounds
                const clampedStart = Math.max(startSec, startTime);
                const clampedEnd = Math.min(endSec, endTime);
                
                if (clampedStart >= clampedEnd) return null;
                
                // Calculate pixel range
                const curveDuration = endTime - startTime;
                const segmentWidth = x2Pixel - x1Pixel;
                
                // Sample every few pixels for smooth curve (every 2-3 pixels)
                const pixelStep = 2;
                const points = [];
                
                for (let x = x1Pixel; x <= x2Pixel; x += pixelStep) {
                    // Map pixel X to time
                    const xProgress = (x - x1Pixel) / segmentWidth;
                    const timeSec = clampedStart + xProgress * (clampedEnd - clampedStart);
                    
                    // Get sample index
                    const sampleIndex = Math.floor((timeSec - startTime) / sampleInterval);
                    if (sampleIndex < 0 || sampleIndex >= samples.length) continue;
                    
                    // Get normalized Y (0-1, where 1 is top)
                    const normalizedY = samples[sampleIndex];
                    
                    // Convert to pixel Y (invert because SVG Y increases downward)
                    const yPixel = trackBottom - normalizedY * trackHeight;
                    
                    points.push({ x, y: yPixel });
                }
                
                // Add final point at x2Pixel
                if (points.length > 0 && points[points.length - 1].x < x2Pixel) {
                    const timeSec = clampedEnd;
                    const sampleIndex = Math.min(samples.length - 1, Math.floor((timeSec - startTime) / sampleInterval));
                    const normalizedY = samples[sampleIndex];
                    const yPixel = trackBottom - normalizedY * trackHeight;
                    points.push({ x: x2Pixel, y: yPixel });
                }
                
                if (points.length < 2) return null;
                
                // Build path - use line segments for accuracy
                let pathD = `M ${points[0].x} ${points[0].y}`;
                for (let i = 1; i < points.length; i++) {
                    pathD += ` L ${points[i].x} ${points[i].y}`;
                }
                
                // Handle fill mode
                if (curve.fillMode !== 'line' && trackDims) {
                    const fillY = curve.fillMode === 'bottom' ? trackBottom : trackTop;
                    pathD = `M ${points[0].x} ${fillY} L ${points[0].x} ${points[0].y}`;
                    for (let i = 1; i < points.length; i++) {
                        pathD += ` L ${points[i].x} ${points[i].y}`;
                    }
                    pathD += ` L ${points[points.length - 1].x} ${fillY} Z`;
                }
                
                return pathD;
            },
            
            // Show continuation segment on a subsequent page
            // Uses curveData samples for pixel-accurate rendering
            // sectionHint: 'top' or 'bottom' to specify which section to render on
            showContinuationSegment(curve, page, secondsPerPage, leadInSec, sectionHint) {
                const startActual = curve.startSeconds + leadInSec;
                const endActual = curve.endSeconds + leadInSec;
                const pageStartTime = page * secondsPerPage;
                const pageEndTime = (page + 1) * secondsPerPage;
                
                // Clip times to this page (in score time, not actual time)
                const clippedStartActual = Math.max(startActual, pageStartTime);
                const clippedEndActual = Math.min(endActual, pageEndTime);
                const clippedStartSec = clippedStartActual - leadInSec;
                const clippedEndSec = clippedEndActual - leadInSec;
                
                // Use sectionHint if provided, otherwise calculate from page
                const section = sectionHint || (page % 2 === 0 ? 'top' : 'bottom');
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const targetContainer = section === 'top' ? this.topCurveGroup : this.bottomCurveGroup;
                const scoreWidth = scoreEl.clientWidth;
                
                // X positions within this page
                const startXPercent = ((clippedStartActual / secondsPerPage) - page) * 100;
                const endXPercent = ((clippedEndActual / secondsPerPage) - page) * 100;
                const x1Pixel = (startXPercent / 100) * scoreWidth;
                const x2Pixel = (endXPercent / 100) * scoreWidth;
                
                // Get track dimensions for this section
                let trackDimsForSection = curve.trackDims;
                if (curve.gTrack && window.CompositionPanel) {
                    trackDimsForSection = CompositionPanel.getTrackDimensions(curve.gTrack, scoreEl) || curve.trackDims;
                }
                
                // Use curveData samples for pixel-accurate curve rendering
                // Create a temporary curve object with the section's trackDims
                const tempCurve = { ...curve, trackDims: trackDimsForSection };
                const pathD = this.generatePathFromCurveData(tempCurve, clippedStartSec, clippedEndSec, scoreEl, x1Pixel, x2Pixel);
                
                // Use separate continuation groups for top and bottom sections
                // This allows showing continuation segments on both visible pages simultaneously
                const groupKey = section === 'top' ? 'continuationGroupTop' : 'continuationGroupBottom';
                const pathKey = section === 'top' ? 'continuationPathTop' : 'continuationPathBottom';
                
                // Create or update continuation segment
                // Clickable to select the curve, but all controls remain on the first segment
                const hitPathKey = section === 'top' ? 'continuationHitPathTop' : 'continuationHitPathBottom';
                
                if (!curve.elements[groupKey]) {
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.classList.add('curve-continuation');
                    group.classList.add('curve-element');
                    group.setAttribute('data-curve-id', curve.id);
                    
                    // Hit path for click detection (wider, invisible)
                    const hitPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    hitPath.setAttribute('fill', 'none');
                    hitPath.setAttribute('stroke', 'transparent');
                    hitPath.setAttribute('stroke-width', '12');
                    hitPath.setAttribute('stroke-linecap', 'round');
                    hitPath.style.cursor = 'pointer';
                    group.appendChild(hitPath);
                    
                    // Main path (display only)
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', ColorMap[curve.color] || curve.color);
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('stroke-linecap', 'round');
                    path.style.pointerEvents = 'none'; // Visual only, hit path handles clicks
                    group.appendChild(path);
                    
                    // Add click handler to select the parent curve
                    hitPath.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectCurve(curve);
                    });
                    
                    curve.elements[groupKey] = group;
                    curve.elements[pathKey] = path;
                    curve.elements[hitPathKey] = hitPath;
                }
                
                const color = ColorMap[curve.color] || curve.color;
                if (pathD) {
                    curve.elements[pathKey].setAttribute('d', pathD);
                    // Update hit path with same path data for click detection
                    if (curve.elements[hitPathKey]) {
                        curve.elements[hitPathKey].setAttribute('d', pathD);
                    }
                }
                curve.elements[pathKey].setAttribute('stroke', color);
                
                // Apply fill mode to continuation segment
                if (curve.fillMode && curve.fillMode !== 'line') {
                    curve.elements[pathKey].setAttribute('fill', color);
                    curve.elements[pathKey].setAttribute('fill-opacity', '0.3');
                } else {
                    curve.elements[pathKey].setAttribute('fill', 'none');
                }
                curve.elements[pathKey].setAttribute('opacity', '0.3');
                
                curve.elements[groupKey].style.display = '';
                
                // Add to correct container
                if (curve.elements[groupKey].parentNode !== targetContainer) {
                    targetContainer.appendChild(curve.elements[groupKey]);
                }
                
                // Store segment info for later use
                curve.continuationSegment = {
                    page,
                    x1: x1Pixel,
                    x2: x2Pixel
                };
            },
            
            // Restore original rendering when returning to curve's original page
            restoreOriginalRendering(curve) {
                if (!curve.elements || !curve.elements.path) return;
                
                // Move curve back to original container
                const originalContainer = curve.section === 'bottom' ? this.bottomCurveGroup : this.topCurveGroup;
                if (curve.elements.group.parentNode !== originalContainer) {
                    originalContainer.appendChild(curve.elements.group);
                }
                
                // Restore original path using stored coordinates
                const color = ColorMap[curve.color] || curve.color;
                const slope = curve.slope || 0;
                const curveWidth = curve.x2 - curve.x1;
                const ctrlX = curve.x1 + (curveWidth * (0.5 + slope * 0.45));
                const ctrlY = slope >= 0 
                    ? curve.y1Pixel + (curve.y2Pixel - curve.y1Pixel) * (1 - Math.abs(slope)) * 0.5
                    : curve.y2Pixel - (curve.y2Pixel - curve.y1Pixel) * (1 - Math.abs(slope)) * 0.5;
                
                const pathD = `M ${curve.x1} ${curve.y1Pixel} Q ${ctrlX} ${ctrlY}, ${curve.x2} ${curve.y2Pixel}`;
                console.log(`[restoreOriginalRendering] ${curve.name}: pathD=${pathD}`);
                
                curve.elements.path.setAttribute('d', pathD);
                if (curve.elements.hitPath) {
                    curve.elements.hitPath.setAttribute('d', pathD);
                }
                
                // Update bounding box and endpoints
                this.updateBoundingBox(curve);
                if (curve.elements.startPoint) {
                    curve.elements.startPoint.setAttribute('cx', curve.x1);
                    curve.elements.startPoint.setAttribute('cy', curve.y1Pixel);
                }
                if (curve.elements.endPoint) {
                    curve.elements.endPoint.setAttribute('cx', curve.x2);
                    curve.elements.endPoint.setAttribute('cy', curve.y2Pixel);
                }
            },
            
            // Clip curve path to current visible page bounds
            updateCurveClipping(curve, targetPage, secondsPerPage, leadInSeconds) {
                if (!curve.elements || !curve.elements.path) return;
                
                const startActual = curve.startSeconds + leadInSeconds;
                const endActual = curve.endSeconds + leadInSeconds;
                
                // Calculate page time bounds
                const pageStartTime = targetPage * secondsPerPage;
                const pageEndTime = (targetPage + 1) * secondsPerPage;
                
                // Clip curve times to page bounds
                const clippedStart = Math.max(startActual, pageStartTime);
                const clippedEnd = Math.min(endActual, pageEndTime);
                
                // Calculate X positions as percentages within the page
                const startXPercent = ((clippedStart / secondsPerPage) - targetPage) * 100;
                const endXPercent = ((clippedEnd / secondsPerPage) - targetPage) * 100;
                
                // Get score dimensions
                const section = targetPage % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                
                console.log(`[updateCurveClipping] ${curve.name}: targetPage=${targetPage}, section=${section}`);
                console.log(`  startActual=${startActual.toFixed(2)}, endActual=${endActual.toFixed(2)}`);
                console.log(`  pageStartTime=${pageStartTime}, pageEndTime=${pageEndTime}`);
                console.log(`  clippedStart=${clippedStart.toFixed(2)}, clippedEnd=${clippedEnd.toFixed(2)}`);
                console.log(`  startXPercent=${startXPercent.toFixed(1)}%, endXPercent=${endXPercent.toFixed(1)}%`);
                const scoreWidth = scoreEl.clientWidth;
                
                // Calculate pixel positions
                const x1Pixel = (startXPercent / 100) * scoreWidth;
                const x2Pixel = (endXPercent / 100) * scoreWidth;
                
                // Calculate Y positions based on curve progress at clipped points
                const curveProgress1 = (clippedStart - startActual) / (endActual - startActual);
                const curveProgress2 = (clippedEnd - startActual) / (endActual - startActual);
                
                // For multi-page curves, recalculate Y positions based on track dimensions
                // Get fresh track dimensions for the TARGET section (may differ from original)
                let trackDims = curve.trackDims;
                if (window.CompositionPanel && curve.gTrack) {
                    // Get track dimensions for the target section's SVG
                    trackDims = CompositionPanel.getTrackDimensions(curve.gTrack, scoreEl);
                }
                
                let y1Clipped, y2Clipped;
                if (!trackDims) {
                    // Fallback to original pixel values
                    const origY1 = curve.origY1Pixel || curve.y1Pixel;
                    const origY2 = curve.origY2Pixel || curve.y2Pixel;
                    y1Clipped = origY1 + (origY2 - origY1) * curveProgress1;
                    y2Clipped = origY1 + (origY2 - origY1) * curveProgress2;
                } else {
                    // Recalculate Y from normalized values for the target section
                    const trackBottom = trackDims.y + trackDims.height;
                    const origY1Pixel = trackBottom - (curve.y1 / 10) * trackDims.height;
                    const origY2Pixel = trackBottom - (curve.y2 / 10) * trackDims.height;
                    y1Clipped = origY1Pixel + (origY2Pixel - origY1Pixel) * curveProgress1;
                    y2Clipped = origY1Pixel + (origY2Pixel - origY1Pixel) * curveProgress2;
                }
                
                // Update the path with clipped coordinates
                const color = ColorMap[curve.color] || curve.color;
                const slope = curve.slope || 0;
                const curveWidth = x2Pixel - x1Pixel;
                const ctrlXOffset = curveWidth * 0.5 * (1 + slope);
                const ctrlX = x1Pixel + ctrlXOffset;
                
                // Control point Y: interpolate based on tension
                const tension = curve.tension || 0;
                const midY = (y1Clipped + y2Clipped) / 2;
                const ctrlY = midY - tension * 50;
                
                const pathD = `M ${x1Pixel} ${y1Clipped} Q ${ctrlX} ${ctrlY} ${x2Pixel} ${y2Clipped}`;
                console.log(`  pathD: ${pathD}`);
                
                curve.elements.path.setAttribute('d', pathD);
                if (curve.elements.hitPath) {
                    curve.elements.hitPath.setAttribute('d', pathD);
                }
                
                // Move curve to correct container if needed
                const targetContainer = section === 'top' ? this.topCurveGroup : this.bottomCurveGroup;
                if (curve.elements.group.parentNode !== targetContainer) {
                    targetContainer.appendChild(curve.elements.group);
                }
                
                // Update bounding box
                this.updateBoundingBox(curve);
                
                // Update endpoint positions
                if (curve.elements.startPoint) {
                    curve.elements.startPoint.setAttribute('cx', x1Pixel);
                    curve.elements.startPoint.setAttribute('cy', y1Clipped);
                }
                if (curve.elements.endPoint) {
                    curve.elements.endPoint.setAttribute('cx', x2Pixel);
                    curve.elements.endPoint.setAttribute('cy', y2Clipped);
                }
                
                // Store clipped values for connector system
                curve.x1 = x1Pixel;
                curve.x2 = x2Pixel;
                curve.y1Pixel = y1Clipped;
                curve.y2Pixel = y2Clipped;
            },
            
            deleteSelectedCurve() {
                if (!this.selectedCurve) return;
                
                const curve = this.selectedCurve;
                const curveName = curve.name;
                
                // Remove SVG elements from DOM (primary segment)
                if (curve.elements && curve.elements.group) {
                    curve.elements.group.remove();
                }
                
                // Remove continuation segments if they exist (multi-page curves)
                if (curve.elements && curve.elements.continuationGroup) {
                    curve.elements.continuationGroup.remove();
                }
                if (curve.elements && curve.elements.continuationGroupTop) {
                    curve.elements.continuationGroupTop.remove();
                }
                if (curve.elements && curve.elements.continuationGroupBottom) {
                    curve.elements.continuationGroupBottom.remove();
                }
                
                // Remove from G Track graphic items
                if (curve.gTrack !== 'A' && window.GTrackSystem) {
                    const trackIndex = parseInt(curve.gTrack) - 1;
                    const gTrack = GTrackSystem.getGTrack(trackIndex);
                    if (gTrack) {
                        const itemIndex = gTrack.graphicItems.findIndex(i => i.curveId === curve.id);
                        if (itemIndex !== -1) {
                            gTrack.graphicItems.splice(itemIndex, 1);
                        }
                    }
                }
                
                // Remove from CurveDatabase
                CurveDatabase.remove(curve.id);
                
                // Remove from CurveMaker.curves array
                const curveIndex = this.curves.findIndex(c => c.id === curve.id);
                if (curveIndex !== -1) {
                    this.curves.splice(curveIndex, 1);
                }
                
                // Mark score as dirty (has unsaved changes)
                if (window.ScoreManager) ScoreManager.markDirty();
                
                // Clear selection
                this.selectedCurve = null;
                this.nameDisplay.value = '';
                
                console.log(`Curve deleted: ${curveName}`);
            },
            
            updateBoundingBox(curve) {
                if (!curve.elements || !curve.elements.boundingBox) return;
                if (!curve.trackDims) return; // Guard against missing trackDims
                
                const bbox = curve.elements.boundingBox;
                const padding = 8;
                
                // Check if this is a multi-page curve
                const secondsPerPage = window.GraphicTimeline ? GraphicTimeline.getSecondsPerPage() : 8;
                const leadInSec = leadInSeconds;
                const startActual = curve.startSeconds + leadInSec;
                const endActual = curve.endSeconds + leadInSec;
                const curveStartPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                const curveEndPage = Math.floor(Math.max(0, endActual) / secondsPerPage);
                const isMultiPage = curveEndPage > curveStartPage;
                
                // For multi-page curves, clip bounding box to first segment (page edge)
                const scoreEl = curve.section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                const x2ForBbox = isMultiPage ? scoreWidth : curve.x2;
                
                const minX = Math.min(curve.x1, x2ForBbox) - padding;
                const maxX = Math.max(curve.x1, x2ForBbox) + padding;
                
                if (isMultiPage) {
                    // Multi-page curve: bounding box spans FULL track height
                    // This allows full Y range control via the preview curve
                    bbox.setAttribute('x', minX);
                    bbox.setAttribute('y', curve.trackDims.y);
                    bbox.setAttribute('width', Math.max(1, maxX - minX));
                    bbox.setAttribute('height', curve.trackDims.height);
                } else {
                    // Single-page curve: bounding box fits the actual curve
                    const tensionOffset = Math.abs(curve.tension || 0) * curve.trackDims.height * 0.5;
                    const minY = Math.min(curve.y1Pixel, curve.y2Pixel) - padding - tensionOffset;
                    const maxY = Math.max(curve.y1Pixel, curve.y2Pixel) + padding + tensionOffset;
                    
                    bbox.setAttribute('x', minX);
                    bbox.setAttribute('y', Math.max(curve.trackDims.y, minY));
                    bbox.setAttribute('width', Math.max(1, maxX - minX));
                    bbox.setAttribute('height', Math.max(1, Math.min(curve.trackDims.height, maxY - minY)));
                }
            },
            
            updateInputsFromCurve(curve) {
                const scoreEl = curve.section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                // Convert X pixels back to seconds
                const startXPercent = (curve.x1 / scoreWidth) * 100;
                const endXPercent = (curve.x2 / scoreWidth) * 100;
                const startSeconds = (curve.page + startXPercent / 100) * secondsPerPage - leadInSeconds;
                const endSeconds = (curve.page + endXPercent / 100) * secondsPerPage - leadInSeconds;
                
                // Convert Y pixels back to relative (0-10)
                const trackBottom = curve.trackDims.y + curve.trackDims.height;
                const y1 = ((trackBottom - curve.y1Pixel) / curve.trackDims.height) * 10;
                const y2 = ((trackBottom - curve.y2Pixel) / curve.trackDims.height) * 10;
                
                // Update inputs
                this.startInput.value = startSeconds.toFixed(3);
                this.endInput.value = endSeconds.toFixed(3);
                this.y1Input.value = Math.max(0, Math.min(10, y1)).toFixed(1);
                this.y2Input.value = Math.max(0, Math.min(10, y2)).toFixed(1);
                
                // Update curve data
                curve.startSeconds = startSeconds;
                curve.endSeconds = endSeconds;
                curve.y1 = y1;
                curve.y2 = y2;
            },
            
            updateSelectedFromInputs() {
                if (!this.selectedCurve) return;
                
                const curve = this.selectedCurve;
                const scoreEl = curve.section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                // Read values from inputs
                const startSeconds = parseFloat(this.startInput.value) || 0;
                const endSeconds = parseFloat(this.endInput.value) || 1;
                const y1 = parseFloat(this.y1Input.value) || 0;
                const y2 = parseFloat(this.y2Input.value) || 10;
                
                // Convert to pixels
                const startActual = startSeconds + leadInSeconds;
                const endActual = endSeconds + leadInSeconds;
                const startXPercent = ((startActual / secondsPerPage) - curve.page) * 100;
                const endXPercent = ((endActual / secondsPerPage) - curve.page) * 100;
                
                curve.x1 = (startXPercent / 100) * scoreWidth;
                curve.x2 = (endXPercent / 100) * scoreWidth;
                
                const trackBottom = curve.trackDims.y + curve.trackDims.height;
                curve.y1Pixel = trackBottom - (y1 / 10) * curve.trackDims.height;
                curve.y2Pixel = trackBottom - (y2 / 10) * curve.trackDims.height;
                
                curve.startSeconds = startSeconds;
                curve.endSeconds = endSeconds;
                curve.y1 = y1;
                curve.y2 = y2;
                
                // Update rendering
                this.updateCurveRendering(curve);
                this.updateBoundingBox(curve);
                this.syncCurveToDatabase(curve);
                // Update visibility to refresh continuation segments
                this.updateVisibility();
            },
            
            syncCurveToDatabase(curve) {
                // Regenerate curveData array when curve is modified
                const curveDataArray = this.generateCurveDataArray(curve);
                curve.curveData = curveDataArray;
                
                // Mark score as dirty (has unsaved changes)
                if (window.ScoreManager) ScoreManager.markDirty();
                
                // Update curve in database
                CurveDatabase.update(curve.id, {
                    startSeconds: curve.startSeconds,
                    endSeconds: curve.endSeconds,
                    y1: curve.y1,
                    y2: curve.y2,
                    color: curve.color,
                    fillMode: curve.fillMode,
                    tension: curve.tension,
                    slope: curve.slope,
                    x1: curve.x1,
                    y1Pixel: curve.y1Pixel,
                    x2: curve.x2,
                    y2Pixel: curve.y2Pixel,
                    curveData: curveDataArray
                });
                
                // Update in G Track if applicable
                if (curve.gTrack !== 'A' && window.GTrackSystem) {
                    const trackIndex = parseInt(curve.gTrack) - 1;
                    const gTrack = GTrackSystem.getGTrack(trackIndex);
                    if (gTrack) {
                        const item = gTrack.graphicItems.find(i => i.curveId === curve.id);
                        if (item) {
                            item.scoreTimeMs = curve.startSeconds * 1000;
                            item.duration = (curve.endSeconds - curve.startSeconds) * 1000;
                            item.curveData = curveDataArray;
                            item.color = curve.color;
                            item.fillMode = curve.fillMode;
                        }
                    }
                }
            },
            
            updateCurveRendering(curve) {
                if (!curve.elements) return;
                
                const { path, hitPath, startPoint, endPoint, boundingBox } = curve.elements;
                const color = ColorMap[curve.color] || curve.color;
                
                // DAW-style curve shaping:
                // slope controls where the "knee" is (-1 = left edge, +1 = right edge)
                // Drag right = flat at start, steep rise at end
                // Drag left = steep rise at start, flat at end
                // Curve stays within Y bounds of endpoints (no protrusion)
                const slope = curve.slope || 0;
                const curveWidth = Math.abs(curve.x2 - curve.x1);
                
                // Control point X: slope moves it from left edge to right edge
                // slope -1 = control at x1, slope +1 = control at x2, slope 0 = middle
                const ctrlX = curve.x1 + (curveWidth * (0.5 + slope * 0.45));
                
                // Control point Y: stays at the Y value of the opposite endpoint
                // This creates the "flat then steep" or "steep then flat" effect
                // When slope > 0 (dragging right): ctrl Y near y1 (start), curve flat then rises
                // When slope < 0 (dragging left): ctrl Y near y2 (end), curve rises then flat
                const ctrlY = slope >= 0 
                    ? curve.y1Pixel + (curve.y2Pixel - curve.y1Pixel) * (1 - Math.abs(slope)) * 0.5
                    : curve.y2Pixel - (curve.y2Pixel - curve.y1Pixel) * (1 - Math.abs(slope)) * 0.5;
                
                // Update path
                const d = `M ${curve.x1} ${curve.y1Pixel} Q ${ctrlX} ${ctrlY}, ${curve.x2} ${curve.y2Pixel}`;
                
                if (curve.fillMode === 'line' || !curve.trackDims) {
                    // Line mode or missing trackDims - just draw the curve
                    path.setAttribute('d', d);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', color);
                    path.setAttribute('opacity', '0.3');
                } else {
                    const fillY = curve.fillMode === 'bottom' ? curve.trackDims.y + curve.trackDims.height : curve.trackDims.y;
                    const filledD = `M ${curve.x1} ${fillY} L ${curve.x1} ${curve.y1Pixel} Q ${ctrlX} ${ctrlY}, ${curve.x2} ${curve.y2Pixel} L ${curve.x2} ${fillY} Z`;
                    path.setAttribute('d', filledD);
                    path.setAttribute('fill', color);
                    path.setAttribute('fill-opacity', '0.3');
                    path.setAttribute('stroke', color);
                    path.setAttribute('opacity', '0.3');
                }
                
                // Update hit path for easier clicking
                if (hitPath) {
                    hitPath.setAttribute('d', d);
                }
                
                // Update endpoint colors
                startPoint.setAttribute('fill', color);
                endPoint.setAttribute('fill', color);
                
                // Update bounding box color
                boundingBox.setAttribute('stroke', color);
                boundingBox.setAttribute('fill', color);
                
                // Update points positions
                startPoint.setAttribute('cx', curve.x1);
                startPoint.setAttribute('cy', curve.y1Pixel);
                endPoint.setAttribute('cx', curve.x2);
                endPoint.setAttribute('cy', curve.y2Pixel);
            },
            
            // Reload curves from CurveDatabase (called after loading a score)
            reloadFromDatabase() {
                // Clear existing curve elements
                if (this.topCurveGroup) this.topCurveGroup.innerHTML = '';
                if (this.bottomCurveGroup) this.bottomCurveGroup.innerHTML = '';
                this.curves = [];
                this.selectedCurve = null;
                
                // Clear GTrackSystem graphic items to avoid duplicates
                if (window.GTrackSystem) {
                    GTrackSystem.clearAllGraphicItems();
                }
                
                // Recreate curves from database
                const dbCurves = CurveDatabase.getAll();
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                for (const dbCurve of dbCurves) {
                    // Recreate the curve visual elements
                    const curve = { ...dbCurve };
                    
                    // Recalculate page and section from time-based values
                    const startActual = curve.startSeconds + leadInSeconds;
                    const endActual = curve.endSeconds + leadInSeconds;
                    const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                    
                    // Update page and section based on new lead-in
                    curve.page = startPage;
                    curve.section = startPage % 2 === 0 ? 'top' : 'bottom';
                    
                    // Determine which container to use based on recalculated section
                    const container = curve.section === 'bottom' ? this.bottomCurveGroup : this.topCurveGroup;
                    const scoreEl = curve.section === 'bottom' ? this.scoreBottomEl : this.scoreTopEl;
                    const scoreWidth = scoreEl.clientWidth;
                    
                    // Recalculate X positions
                    const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                    const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                    curve.x1 = (startXPercent / 100) * scoreWidth;
                    curve.x2 = (endXPercent / 100) * scoreWidth;
                    
                    // Recalculate Y positions from normalized y1/y2 (0-10 scale)
                    if (curve.gTrack && window.CompositionPanel) {
                        const trackDims = CompositionPanel.getTrackDimensions(curve.gTrack, scoreEl);
                        if (trackDims && trackDims.height) {
                            curve.trackDims = trackDims;
                            const trackBottom = trackDims.y + trackDims.height;
                            const trackHeight = trackDims.height;
                            curve.y1Pixel = trackBottom - (curve.y1 / 10) * trackHeight;
                            curve.y2Pixel = trackBottom - (curve.y2 / 10) * trackHeight;
                            curve.origY1Pixel = curve.y1Pixel;
                            curve.origY2Pixel = curve.y2Pixel;
                        }
                    }
                    
                    // Create SVG elements for the curve
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.setAttribute('class', 'curve-group');
                    
                    // Create path
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('class', 'curve-path');
                    path.setAttribute('stroke', curve.color || '#4CAF50');
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('fill', 'none');
                    
                    // Create hit path for easier clicking
                    const hitPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    hitPath.setAttribute('class', 'curve-hit-path');
                    hitPath.setAttribute('stroke', 'transparent');
                    hitPath.setAttribute('stroke-width', '10');
                    hitPath.setAttribute('fill', 'none');
                    hitPath.style.cursor = 'pointer';
                    
                    // Create bounding box (hidden by default)
                    const boundingBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    boundingBox.setAttribute('class', 'curve-bounding-box');
                    boundingBox.setAttribute('stroke', curve.color || '#4CAF50');
                    boundingBox.setAttribute('stroke-width', '1');
                    boundingBox.setAttribute('stroke-dasharray', '4,2');
                    boundingBox.setAttribute('fill', curve.color || '#4CAF50');
                    boundingBox.setAttribute('fill-opacity', '0.1');
                    boundingBox.style.display = 'none';
                    
                    // Create endpoint circles
                    const startPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    startPoint.setAttribute('class', 'curve-endpoint curve-start');
                    startPoint.setAttribute('r', '4');
                    startPoint.setAttribute('fill', curve.color || '#4CAF50');
                    startPoint.style.display = 'none';
                    
                    const endPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    endPoint.setAttribute('class', 'curve-endpoint curve-end');
                    endPoint.setAttribute('r', '4');
                    endPoint.setAttribute('fill', curve.color || '#4CAF50');
                    endPoint.style.display = 'none';
                    
                    // Assemble group
                    group.appendChild(hitPath);
                    group.appendChild(path);
                    group.appendChild(boundingBox);
                    group.appendChild(startPoint);
                    group.appendChild(endPoint);
                    container.appendChild(group);
                    
                    // Store element references
                    curve.elements = { group, path, hitPath, boundingBox, startPoint, endPoint };
                    
                    // Add to curves array
                    this.curves.push(curve);
                    
                    // Update rendering
                    this.updateCurveRendering(curve);
                    this.updateBoundingBox(curve);
                    
                    // Add click handler for selection
                    hitPath.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectCurve(curve);
                    });
                    
                    // Add drag handlers for endpoints (makes curves editable)
                    startPoint.style.cursor = 'ns-resize';
                    startPoint.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'start'));
                    
                    endPoint.style.cursor = 'ns-resize';
                    endPoint.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'end'));
                    
                    // Add drag handler for bounding box (move entire curve)
                    boundingBox.style.cursor = 'move';
                    boundingBox.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'move'));
                    
                    // Re-add to GTrackSystem for curve follower functionality
                    if (curve.gTrack && curve.gTrack !== 'A' && window.GTrackSystem) {
                        const trackIndex = parseInt(curve.gTrack) - 1;
                        if (trackIndex >= 0 && trackIndex < 4) {
                            // Regenerate curveData if not present
                            let curveDataArray = curve.curveData;
                            if (!curveDataArray) {
                                curveDataArray = this.generateCurveDataArray(curve);
                                curve.curveData = curveDataArray;
                            }
                            
                            GTrackSystem.addGraphicItem(trackIndex, {
                                type: 'curve',
                                curveId: curve.id,
                                curveName: curve.name,
                                color: curve.color,
                                fillMode: curve.fillMode,
                                scoreTimeMs: curve.startSeconds * 1000,
                                duration: (curve.endSeconds - curve.startSeconds) * 1000,
                                curveData: curveDataArray
                            });
                        }
                    }
                }
                
                console.log(`CurveMaker: Reloaded ${this.curves.length} curves from database`);
                
                // Update visibility to show all visible segments immediately
                this.updateVisibility();
            },
            
            // Re-render all curves on window resize
            reRenderAllCurves() {
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                for (const curve of this.curves) {
                    // Recalculate pixel positions from time-based values
                    const startActual = curve.startSeconds + leadInSeconds;
                    const endActual = curve.endSeconds + leadInSeconds;
                    const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                    
                    // Determine section based on page
                    const section = startPage % 2 === 0 ? 'top' : 'bottom';
                    const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                    const scoreWidth = scoreEl.clientWidth;
                    
                    // Calculate X positions as percentages within the page
                    const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                    const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                    
                    // Update pixel X positions
                    curve.x1 = (startXPercent / 100) * scoreWidth;
                    curve.x2 = (endXPercent / 100) * scoreWidth;
                    
                    // Recalculate Y positions if trackDims exists
                    if (curve.trackDims && curve.gTrack) {
                        // Get fresh track dimensions
                        const trackDims = window.CompositionPanel ? 
                            CompositionPanel.getTrackDimensions(scoreEl, curve.gTrack) : curve.trackDims;
                        
                        if (trackDims) {
                            curve.trackDims = trackDims;
                            const trackBottom = trackDims.y + trackDims.height;
                            const trackHeight = trackDims.height;
                            
                            // Recalculate Y pixel positions from normalized y1/y2 (0-10 scale)
                            curve.y1Pixel = trackBottom - (curve.y1 / 10) * trackHeight;
                            curve.y2Pixel = trackBottom - (curve.y2 / 10) * trackHeight;
                            curve.origY1Pixel = curve.y1Pixel;
                            curve.origY2Pixel = curve.y2Pixel;
                        }
                    }
                    
                    // Update the curve rendering
                    this.updateCurveRendering(curve);
                    this.updateBoundingBox(curve);
                }
                
                // Update visibility for multi-page curves
                this.updateVisibility();
            },
            
            // Save selected curve to library
            async saveCurveToLibrary() {
                if (!this.selectedCurve) {
                    alert('No curve selected. Select a curve to save.');
                    return;
                }
                
                const curve = this.selectedCurve;
                const description = this.descriptionInput?.value || '';
                
                // Build complete curve data for saving
                const curveData = {
                    name: curve.name,
                    description: description,
                    // Core curve parameters (relative/normalized)
                    startSeconds: curve.startSeconds,
                    endSeconds: curve.endSeconds,
                    y1: curve.y1,
                    y2: curve.y2,
                    gTrack: curve.gTrack,
                    color: curve.color,
                    fillMode: curve.fillMode,
                    tension: curve.tension || 0,
                    slope: curve.slope || 0,
                    // Curve data array for playback
                    curveData: curve.curveData,
                    // Duration for easy reference
                    duration: curve.endSeconds - curve.startSeconds
                };
                
                try {
                    const response = await fetch('/api/curve-library/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ curveData })
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        console.log(`Curve saved to library: ${curve.name}`);
                        alert(`Curve "${curve.name}" saved to library.`);
                        // Refresh the recall dropdown
                        this.loadCurveLibrary();
                    } else {
                        alert(`Failed to save curve: ${result.error}`);
                    }
                } catch (err) {
                    console.error('Error saving curve:', err);
                    alert(`Error saving curve: ${err.message}`);
                }
            },
            
            // Load curve library into recall dropdown
            async loadCurveLibrary() {
                if (!this.recallOptions) return;
                
                try {
                    const response = await fetch('/api/curve-library/list');
                    const result = await response.json();
                    
                    if (result.success) {
                        // Clear existing options
                        this.recallOptions.innerHTML = '';
                        
                        // Reset hidden input and selected display
                        if (this.recallSelect) this.recallSelect.value = '';
                        if (this.recallSelected) this.recallSelected.textContent = '-- Select Saved Curve --';
                        
                        // Add placeholder option
                        const placeholder = document.createElement('div');
                        placeholder.className = 'custom-dropdown-option';
                        placeholder.style.cssText = 'padding: 6px 8px; cursor: pointer; font-size: 10px; color: #888; border-bottom: 1px solid #444;';
                        placeholder.textContent = '-- Select Saved Curve --';
                        placeholder.dataset.value = '';
                        placeholder.addEventListener('click', () => this.selectRecallOption('', '-- Select Saved Curve --'));
                        placeholder.addEventListener('mouseenter', () => placeholder.style.background = 'rgba(60,60,80,0.8)');
                        placeholder.addEventListener('mouseleave', () => placeholder.style.background = '');
                        this.recallOptions.appendChild(placeholder);
                        
                        // Add curves to dropdown with full descriptions
                        for (const curve of result.curves) {
                            const option = document.createElement('div');
                            option.className = 'custom-dropdown-option';
                            option.style.cssText = 'padding: 6px 8px; cursor: pointer; border-bottom: 1px solid #333;';
                            option.dataset.value = curve.name;
                            
                            // Name line
                            const nameLine = document.createElement('div');
                            nameLine.style.cssText = 'font-size: 10px; font-weight: bold; color: #ddd;';
                            const dur = curve.duration ? ` (${curve.duration.toFixed(1)}s)` : '';
                            nameLine.textContent = `${curve.name}${dur}`;
                            option.appendChild(nameLine);
                            
                            // Description line (full text, wrapped)
                            if (curve.description) {
                                const descLine = document.createElement('div');
                                descLine.style.cssText = 'font-size: 9px; color: #999; margin-top: 2px; white-space: normal; word-wrap: break-word;';
                                descLine.textContent = curve.description;
                                option.appendChild(descLine);
                            }
                            
                            option.addEventListener('click', () => this.selectRecallOption(curve.name, `${curve.name}${dur}`));
                            option.addEventListener('mouseenter', () => option.style.background = 'rgba(60,60,80,0.8)');
                            option.addEventListener('mouseleave', () => option.style.background = '');
                            this.recallOptions.appendChild(option);
                        }
                        
                        console.log(`Loaded ${result.curves.length} curves from library`);
                    }
                } catch (err) {
                    console.error('Error loading curve library:', err);
                }
            },
            
            // Select an option from the custom recall dropdown
            selectRecallOption(value, displayText) {
                if (this.recallSelect) this.recallSelect.value = value;
                if (this.recallSelected) this.recallSelected.textContent = displayText;
                if (this.recallOptions) this.recallOptions.style.display = 'none';
            },
            
            // Insert recalled curve at edit line position
            async insertRecalledCurve() {
                const selectedName = this.recallSelect?.value;
                if (!selectedName) {
                    alert('Select a curve from the library to insert.');
                    return;
                }
                
                // Get insertion point from edit cursor (yellow line position)
                let insertionSeconds = 0;
                if (window.EditCursor && typeof EditCursor.getPositionSeconds === 'function') {
                    insertionSeconds = EditCursor.getPositionSeconds();
                } else if (window.EditCursor) {
                    insertionSeconds = EditCursor.positionSeconds || 0;
                } else {
                    // Fallback: use current score time
                    const scoreTimeMs = window.ScoreTime ? ScoreTime.now() : 0;
                    insertionSeconds = (scoreTimeMs / 1000) - leadInSeconds;
                }
                
                // Get target track from CompositionPanel G track selection
                const targetGTrack = window.CompositionPanel ? CompositionPanel.getSelectedGTrack() : '1';
                
                try {
                    const response = await fetch(`/api/curve-library/load/${encodeURIComponent(selectedName)}`);
                    const result = await response.json();
                    
                    if (!result.success) {
                        alert(`Failed to load curve: ${result.error}`);
                        return;
                    }
                    
                    const savedCurve = result.curveData;
                    const duration = savedCurve.duration || (savedCurve.endSeconds - savedCurve.startSeconds);
                    
                    // Calculate new start/end times based on insertion point
                    const newStartSeconds = insertionSeconds;
                    const newEndSeconds = insertionSeconds + duration;
                    
                    // Get track dimensions for the target track
                    const trackDims = window.CompositionPanel ? 
                        CompositionPanel.getSelectedTrackDimensions(this.scoreTopEl) : null;
                    
                    // Determine which page(s) the curve spans
                    const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                    const startActual = newStartSeconds + leadInSeconds;
                    const endActual = newEndSeconds + leadInSeconds;
                    const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                    
                    // Draw on the start page
                    const section = startPage % 2 === 0 ? 'top' : 'bottom';
                    const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                    const curveGroup = section === 'top' ? this.topCurveGroup : this.bottomCurveGroup;
                    const scoreWidth = scoreEl.clientWidth;
                    
                    // Calculate X positions as percentages within the page
                    const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                    const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                    
                    // Calculate Y positions using saved normalized values
                    const trackBottom = trackDims ? trackDims.y + trackDims.height : 100;
                    const trackHeight = trackDims ? trackDims.height : 100;
                    const y1Pixel = trackBottom - (savedCurve.y1 / 10) * trackHeight;
                    const y2Pixel = trackBottom - (savedCurve.y2 / 10) * trackHeight;
                    
                    // Calculate pixel positions
                    const x1Pixel = (startXPercent / 100) * scoreWidth;
                    const x2Pixel = (endXPercent / 100) * scoreWidth;
                    
                    // Generate new unique name
                    const name = this.generateCurveName();
                    
                    // Create new curve data object
                    const curveDataObj = {
                        name,
                        startSeconds: newStartSeconds,
                        endSeconds: newEndSeconds,
                        y1: savedCurve.y1,
                        y2: savedCurve.y2,
                        gTrack: targetGTrack,
                        color: savedCurve.color,
                        fillMode: savedCurve.fillMode,
                        section,
                        page: startPage,
                        x1: x1Pixel,
                        y1Pixel,
                        x2: x2Pixel,
                        y2Pixel,
                        origY1Pixel: y1Pixel,
                        origY2Pixel: y2Pixel,
                        tension: savedCurve.tension || 0,
                        slope: savedCurve.slope || 0,
                        trackDims
                    };
                    
                    // Regenerate curve data array for new position
                    const curveDataArray = this.generateCurveDataArray(curveDataObj);
                    curveDataObj.curveData = curveDataArray;
                    
                    // Add to database
                    const curve = CurveDatabase.add(curveDataObj);
                    
                    // Mark score as dirty
                    if (window.ScoreManager) ScoreManager.markDirty();
                    
                    // Add to G Track graphic data
                    if (targetGTrack !== 'A') {
                        const trackIndex = parseInt(targetGTrack) - 1;
                        if (window.GTrackSystem) {
                            GTrackSystem.addGraphicItem(trackIndex, {
                                type: 'curve',
                                curveId: curve.id,
                                curveName: curve.name,
                                color: savedCurve.color,
                                fillMode: savedCurve.fillMode,
                                scoreTimeMs: newStartSeconds * 1000,
                                duration: duration * 1000,
                                curveData: curveDataArray
                            });
                        }
                    }
                    
                    // Render the curve
                    this.renderCurve(curve, curveGroup, scoreEl);
                    
                    // Add to curves array
                    this.curves.push(curve);
                    
                    // Update visibility for multi-page curves
                    this.updateVisibility();
                    
                    // Auto-select the new curve
                    this.selectCurve(curve);
                    
                    console.log(`Curve inserted: ${curve.name} at ${newStartSeconds}s on track ${targetGTrack}`);
                    
                } catch (err) {
                    console.error('Error inserting curve:', err);
                    alert(`Error inserting curve: ${err.message}`);
                }
            },
            
            // Set X1 segment marker at edit cursor position
            setSegmentX1() {
                if (!this.selectedCurve) {
                    alert('Select a curve first to set segment markers.');
                    return;
                }
                
                // Get current edit cursor position
                let seconds = 0;
                if (window.EditCursor && typeof EditCursor.getPositionSeconds === 'function') {
                    seconds = EditCursor.getPositionSeconds();
                } else if (window.EditCursor) {
                    seconds = EditCursor.positionSeconds || 0;
                }
                
                // Clamp to curve bounds
                seconds = Math.max(this.selectedCurve.startSeconds, Math.min(this.selectedCurve.endSeconds, seconds));
                
                this.segmentX1Seconds = seconds;
                if (this.segmentX1Input) {
                    this.segmentX1Input.value = seconds.toFixed(1);
                }
                
                this.renderSegmentLine('x1', seconds);
            },
            
            // Set X2 segment marker at edit cursor position
            setSegmentX2() {
                if (!this.selectedCurve) {
                    alert('Select a curve first to set segment markers.');
                    return;
                }
                
                // Get current edit cursor position
                let seconds = 0;
                if (window.EditCursor && typeof EditCursor.getPositionSeconds === 'function') {
                    seconds = EditCursor.getPositionSeconds();
                } else if (window.EditCursor) {
                    seconds = EditCursor.positionSeconds || 0;
                }
                
                // Clamp to curve bounds
                seconds = Math.max(this.selectedCurve.startSeconds, Math.min(this.selectedCurve.endSeconds, seconds));
                
                this.segmentX2Seconds = seconds;
                if (this.segmentX2Input) {
                    this.segmentX2Input.value = seconds.toFixed(1);
                }
                
                this.renderSegmentLine('x2', seconds);
            },
            
            // Update X1 from input field
            updateSegmentX1FromInput() {
                if (!this.selectedCurve) return;
                
                let seconds = parseFloat(this.segmentX1Input?.value) || 0;
                seconds = Math.max(this.selectedCurve.startSeconds, Math.min(this.selectedCurve.endSeconds, seconds));
                
                this.segmentX1Seconds = seconds;
                this.segmentX1Input.value = seconds.toFixed(1);
                this.renderSegmentLine('x1', seconds);
            },
            
            // Update X2 from input field
            updateSegmentX2FromInput() {
                if (!this.selectedCurve) return;
                
                let seconds = parseFloat(this.segmentX2Input?.value) || 0;
                seconds = Math.max(this.selectedCurve.startSeconds, Math.min(this.selectedCurve.endSeconds, seconds));
                
                this.segmentX2Seconds = seconds;
                this.segmentX2Input.value = seconds.toFixed(1);
                this.renderSegmentLine('x2', seconds);
            },
            
            // Render a dotted yellow vertical line at the given time position
            renderSegmentLine(which, seconds) {
                if (!this.selectedCurve) return;
                
                const curve = this.selectedCurve;
                const trackDims = curve.trackDims;
                if (!trackDims) return;
                
                // Remove existing line
                if (which === 'x1' && this.segmentX1Line) {
                    this.segmentX1Line.remove();
                    this.segmentX1Line = null;
                }
                if (which === 'x2' && this.segmentX2Line) {
                    this.segmentX2Line.remove();
                    this.segmentX2Line = null;
                }
                
                // Calculate position
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const actualSeconds = seconds + leadInSeconds;
                const pageNumber = Math.floor(actualSeconds / secondsPerPage);
                const section = pageNumber % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const curveGroup = section === 'top' ? this.topCurveGroup : this.bottomCurveGroup;
                const scoreWidth = scoreEl.clientWidth;
                
                // Calculate X position within the page
                const xPercent = ((actualSeconds / secondsPerPage) - pageNumber) * 100;
                const xPixel = (xPercent / 100) * scoreWidth;
                
                // Create dotted yellow line spanning track height
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', xPixel);
                line.setAttribute('y1', trackDims.y);
                line.setAttribute('x2', xPixel);
                line.setAttribute('y2', trackDims.y + trackDims.height);
                line.setAttribute('stroke', 'yellow');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('stroke-dasharray', '4,4');
                line.setAttribute('class', 'segment-marker-line');
                
                curveGroup.appendChild(line);
                
                if (which === 'x1') {
                    this.segmentX1Line = line;
                } else {
                    this.segmentX2Line = line;
                }
            },
            
            // Clear segment marker lines
            clearSegmentLines() {
                if (this.segmentX1Line) {
                    this.segmentX1Line.remove();
                    this.segmentX1Line = null;
                }
                if (this.segmentX2Line) {
                    this.segmentX2Line.remove();
                    this.segmentX2Line = null;
                }
                this.segmentX1Seconds = null;
                this.segmentX2Seconds = null;
                if (this.segmentX1Input) this.segmentX1Input.value = '0.0';
                if (this.segmentX2Input) this.segmentX2Input.value = '0.0';
            },
            
            // Create a new curve segment from X1 to X2 and save to library
            async createSegment() {
              try {
                
                if (!this.selectedCurve) {
                    alert('Select a curve first.');
                    return;
                }
                
                if (this.segmentX1Seconds === null || this.segmentX2Seconds === null) {
                    alert('Set both X1 and X2 markers first.');
                    return;
                }
                
                // Ensure X1 < X2
                const startSeconds = Math.min(this.segmentX1Seconds, this.segmentX2Seconds);
                const endSeconds = Math.max(this.segmentX1Seconds, this.segmentX2Seconds);
                
                if (startSeconds === endSeconds) {
                    alert('X1 and X2 must be different.');
                    return;
                }
                
                const curve = this.selectedCurve;
                const duration = endSeconds - startSeconds;
                
                // Calculate Y values at X1 and X2 by interpolating from original curve
                const curveStartSeconds = curve.startSeconds;
                const curveDuration = curve.endSeconds - curve.startSeconds;
                
                // Normalized positions within the original curve (0-1)
                const t1 = (startSeconds - curveStartSeconds) / curveDuration;
                const t2 = (endSeconds - curveStartSeconds) / curveDuration;
                
                // Interpolate Y values (linear interpolation based on original y1/y2)
                const y1 = curve.y1 + (curve.y2 - curve.y1) * t1;
                const y2 = curve.y1 + (curve.y2 - curve.y1) * t2;
                
                // Extract the relevant portion of curveData samples array
                // curveData is an object with { startTime, endTime, sampleInterval, samples }
                // samples are at 100 samples/second (10ms intervals)
                const SAMPLE_INTERVAL = 0.01;
                const segmentStartIndex = Math.floor((startSeconds - curveStartSeconds) / SAMPLE_INTERVAL);
                const segmentEndIndex = Math.ceil((endSeconds - curveStartSeconds) / SAMPLE_INTERVAL);
                
                // Extract samples from the curveData object
                let segmentSamples = [];
                if (curve.curveData && curve.curveData.samples && Array.isArray(curve.curveData.samples)) {
                    segmentSamples = curve.curveData.samples.slice(segmentStartIndex, segmentEndIndex + 1);
                }
                
                // Build segment curveData object
                const segmentCurveData = {
                    startTime: 0,
                    endTime: duration,
                    sampleInterval: SAMPLE_INTERVAL,
                    samples: segmentSamples
                };
                
                // Generate unique name with timestamp
                const name = this.generateCurveName();
                
                // Build segment curve data for saving to library
                // Include user's description field text if provided
                const userDescription = this.descriptionInput?.value?.trim() || '';
                const autoDescription = 'Segment from ' + curve.name + ' (' + startSeconds.toFixed(1) + 's - ' + endSeconds.toFixed(1) + 's)';
                const fullDescription = userDescription ? autoDescription + ' - ' + userDescription : autoDescription;
                
                const segmentData = {
                    name: name,
                    description: fullDescription,
                    startSeconds: 0,  // Normalized to start at 0 for library storage
                    endSeconds: duration,
                    y1: y1,
                    y2: y2,
                    gTrack: curve.gTrack,
                    color: curve.color,
                    fillMode: curve.fillMode,
                    tension: curve.tension || 0,
                    slope: curve.slope || 0,
                    curveData: segmentCurveData,
                    duration: duration
                };
                
                // Save to curve library
                try {
                    const response = await fetch('/api/curve-library/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ curveData: segmentData })
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        console.log('Segment saved to library:', name);
                        // Refresh the recall dropdown
                        this.loadCurveLibrary();
                        // Clear segment lines
                        this.clearSegmentLines();
                    } else {
                        console.error('Failed to save segment:', result.error);
                    }
                } catch (err) {
                    console.error('Error saving segment:', err.message);
                }
              } catch (outerErr) {
                console.error('OUTER ERROR:', outerErr.message);
              }
            }
        };
        
        // Initialize Curve Maker
        CurveMaker.init();
        window.CurveMaker = CurveMaker;
        
        // Bring SVG elements containers to front (after curves are initialized)
        // This ensures inserted SVGs appear on top of curves for selection
        if (window.SVGElementManager) {
            SVGElementManager.bringToFront();
        }
        
        // ============================================
        // MOTIVE MAKER (SIMPLIFIED) - Line-only version
        // Creates colored lines on tracks with selection/deletion
        // ============================================
        const MotiveMaker = {
            scoreTopEl: null,
            scoreBottomEl: null,
            topMotiveGroup: null,
            bottomMotiveGroup: null,
            motives: [],
            selectedMotive: null,
            selectedColor: 'neonMagenta',
            
            // UI elements
            startInput: null,
            endInput: null,
            drawBtn: null,
            deleteBtn: null,
            colorSwatches: null,
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Get UI elements
                this.startInput = document.getElementById('motiveStartInput');
                this.endInput = document.getElementById('motiveEndInput');
                this.drawBtn = document.getElementById('motiveDrawBtn');
                this.deleteBtn = document.getElementById('motiveDeleteBtn');
                // Use the shared color swatches (same as curves)
                this.colorSwatches = document.getElementById('colorSwatches');
                
                // Create motive container groups
                this.topMotiveGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.bottomMotiveGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.topMotiveGroup.setAttribute('class', 'motive-container');
                this.bottomMotiveGroup.setAttribute('class', 'motive-container');
                this.scoreTopEl.appendChild(this.topMotiveGroup);
                this.scoreBottomEl.appendChild(this.bottomMotiveGroup);
                
                // Draw button handler
                if (this.drawBtn) {
                    this.drawBtn.addEventListener('click', () => this.createMotive());
                }
                
                // Delete button handler
                if (this.deleteBtn) {
                    this.deleteBtn.addEventListener('click', () => this.deleteSelectedMotive());
                }
                
                // Input field handlers for editing selected motive
                if (this.startInput) {
                    this.startInput.addEventListener('change', () => this.updateSelectedFromInputs());
                }
                if (this.endInput) {
                    this.endInput.addEventListener('change', () => this.updateSelectedFromInputs());
                }
                
                // Click on score to deselect
                this.scoreTopEl.addEventListener('click', (e) => this.handleScoreClick(e));
                this.scoreBottomEl.addEventListener('click', (e) => this.handleScoreClick(e));
                
                // Re-render motives on window resize (debounced)
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.reloadFromDatabase();
                    }, 100);
                });
                
                console.debug('MotiveMaker (simplified) initialized');
            },
            
            createMotive() {
                const startSeconds = parseFloat(this.startInput.value) || 0;
                const endSeconds = parseFloat(this.endInput.value) || 1;
                const gTrack = CompositionPanel.getSelectedGTrack();
                
                // Ignore GA selection for motives - default to track 1
                const actualGTrack = gTrack === 'A' ? '1' : gTrack;
                
                // Get track dimensions
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const startActual = startSeconds + leadInSeconds;
                const endActual = endSeconds + leadInSeconds;
                const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                
                const section = startPage % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const motiveGroup = section === 'top' ? this.topMotiveGroup : this.bottomMotiveGroup;
                const scoreWidth = scoreEl.clientWidth;
                
                const trackDims = window.CompositionPanel ? 
                    CompositionPanel.getTrackDimensions(actualGTrack, scoreEl) : null;
                
                // Calculate X positions
                const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                const x1Pixel = (startXPercent / 100) * scoreWidth;
                const x2Pixel = (endXPercent / 100) * scoreWidth;
                
                // Get selected color from shared swatches
                const selectedSwatch = this.colorSwatches?.querySelector('.color-swatch.selected');
                const color = selectedSwatch?.dataset.color || 'brightOrange';
                
                // Create motive data
                const motiveDataObj = {
                    startSeconds,
                    endSeconds,
                    gTrack: actualGTrack,
                    color: color,
                    section,
                    page: startPage,
                    x1: x1Pixel,
                    x2: x2Pixel,
                    trackDims
                };
                
                // Add to database
                const motive = MotiveDatabase.add(motiveDataObj);
                
                // Mark score as dirty
                if (window.ScoreManager) ScoreManager.markDirty();
                
                // Render the motive
                this.renderMotive(motive, motiveGroup, scoreEl);
                
                // Add to motives array
                this.motives.push(motive);
                
                // Update visibility
                this.updateVisibility();
                
                // Auto-select the new motive
                this.selectMotive(motive);
                
                console.debug(`Motive created (ID: ${motive.id})`);
            },
            
            renderMotive(motive, motiveGroup, scoreEl) {
                const color = ColorMap[motive.color] || motive.color;
                const trackDims = motive.trackDims;
                
                // Create SVG group for this motive
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('data-motive-id', motive.id);
                group.setAttribute('class', 'motive-element');
                
                // Line Y position at top of track
                const lineY = trackDims ? trackDims.y + 5 : 10;
                
                // Create the line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', motive.x1);
                line.setAttribute('y1', lineY);
                line.setAttribute('x2', motive.x2);
                line.setAttribute('y2', lineY);
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-width', '3');
                line.setAttribute('stroke-linecap', 'round');
                line.style.cursor = 'pointer';
                group.appendChild(line);
                
                // Create invisible wider hit area for easier clicking
                const hitLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hitLine.setAttribute('x1', motive.x1);
                hitLine.setAttribute('y1', lineY);
                hitLine.setAttribute('x2', motive.x2);
                hitLine.setAttribute('y2', lineY);
                hitLine.setAttribute('stroke', 'transparent');
                hitLine.setAttribute('stroke-width', '15');
                hitLine.style.cursor = 'pointer';
                hitLine.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectMotive(motive);
                });
                group.appendChild(hitLine);
                
                // Create selection highlight (yellow glow, hidden by default)
                const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                highlight.setAttribute('x1', motive.x1);
                highlight.setAttribute('y1', lineY);
                highlight.setAttribute('x2', motive.x2);
                highlight.setAttribute('y2', lineY);
                highlight.setAttribute('stroke', 'yellow');
                highlight.setAttribute('stroke-width', '7');
                highlight.setAttribute('stroke-linecap', 'round');
                highlight.setAttribute('stroke-opacity', '0.5');
                highlight.style.display = 'none';
                group.insertBefore(highlight, line);
                
                // Store element references
                motive.elements = { group, line, hitLine, highlight, lineY };
                
                motiveGroup.appendChild(group);
            },
            
            selectMotive(motive) {
                // Deselect previous
                if (this.selectedMotive && this.selectedMotive.elements) {
                    if (this.selectedMotive.elements.highlight) {
                        this.selectedMotive.elements.highlight.style.display = 'none';
                    }
                }
                
                this.selectedMotive = motive;
                
                // Show selection highlight
                if (motive.elements && motive.elements.highlight) {
                    motive.elements.highlight.style.display = '';
                }
                
                // Update UI
                if (this.startInput) this.startInput.value = motive.startSeconds.toFixed(3);
                if (this.endInput) this.endInput.value = motive.endSeconds.toFixed(3);
                
                // Update shared color swatch selection to match motive's color
                if (this.colorSwatches) {
                    this.colorSwatches.querySelectorAll('.color-swatch').forEach(s => {
                        s.classList.remove('selected');
                        if (s.dataset.color === motive.color) {
                            s.classList.add('selected');
                        }
                    });
                }
            },
            
            deselectMotive() {
                if (this.selectedMotive && this.selectedMotive.elements) {
                    if (this.selectedMotive.elements.highlight) {
                        this.selectedMotive.elements.highlight.style.display = 'none';
                    }
                }
                this.selectedMotive = null;
            },
            
            handleScoreClick(e) {
                const target = e.target;
                const motiveGroup = target.closest('.motive-element');
                if (!motiveGroup) {
                    this.deselectMotive();
                }
            },
            
            deleteSelectedMotive() {
                if (!this.selectedMotive) return;
                
                const motive = this.selectedMotive;
                
                // Remove from DOM
                if (motive.elements && motive.elements.group) {
                    motive.elements.group.remove();
                }
                
                // Remove continuation segments if they exist
                if (motive.elements && motive.elements.continuationGroupTop) {
                    motive.elements.continuationGroupTop.remove();
                }
                if (motive.elements && motive.elements.continuationGroupBottom) {
                    motive.elements.continuationGroupBottom.remove();
                }
                
                // Remove from database
                MotiveDatabase.remove(motive.id);
                
                // Remove from local array
                const index = this.motives.findIndex(m => m.id === motive.id);
                if (index !== -1) {
                    this.motives.splice(index, 1);
                }
                
                // Mark score as dirty
                if (window.ScoreManager) ScoreManager.markDirty();
                
                this.deselectMotive();
                console.debug(`Motive deleted (ID: ${motive.id})`);
            },
            
            updateSelectedFromInputs() {
                if (!this.selectedMotive) return;
                
                const motive = this.selectedMotive;
                const newStart = parseFloat(this.startInput.value) || 0;
                const newEnd = parseFloat(this.endInput.value) || 1;
                
                // Update motive data
                motive.startSeconds = newStart;
                motive.endSeconds = newEnd;
                
                // Recalculate positions
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const startActual = newStart + leadInSeconds;
                const endActual = newEnd + leadInSeconds;
                const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                
                const section = startPage % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                
                const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                
                motive.x1 = (startXPercent / 100) * scoreWidth;
                motive.x2 = (endXPercent / 100) * scoreWidth;
                motive.page = startPage;
                motive.section = section;
                
                // Update rendering
                this.updateMotiveRendering(motive);
                this.syncMotiveToDatabase(motive);
                this.updateVisibility();
            },
            
            updateMotiveRendering(motive) {
                if (!motive.elements) return;
                
                const { line, hitLine, highlight } = motive.elements;
                const color = ColorMap[motive.color] || motive.color;
                const trackDims = motive.trackDims;
                const lineY = trackDims ? trackDims.y + 5 : 10;
                
                // Update line positions
                line.setAttribute('x1', motive.x1);
                line.setAttribute('x2', motive.x2);
                line.setAttribute('y1', lineY);
                line.setAttribute('y2', lineY);
                line.setAttribute('stroke', color);
                
                hitLine.setAttribute('x1', motive.x1);
                hitLine.setAttribute('x2', motive.x2);
                hitLine.setAttribute('y1', lineY);
                hitLine.setAttribute('y2', lineY);
                
                highlight.setAttribute('x1', motive.x1);
                highlight.setAttribute('x2', motive.x2);
                highlight.setAttribute('y1', lineY);
                highlight.setAttribute('y2', lineY);
                
                motive.elements.lineY = lineY;
            },
            
            syncMotiveToDatabase(motive) {
                if (window.ScoreManager) ScoreManager.markDirty();
                
                MotiveDatabase.update(motive.id, {
                    startSeconds: motive.startSeconds,
                    endSeconds: motive.endSeconds,
                    color: motive.color,
                    x1: motive.x1,
                    x2: motive.x2
                });
            },
            
            // Show/hide motives based on current page (supports multi-page motives)
            updateVisibility() {
                if (!window.GraphicTimeline) return;
                
                const topPage = GraphicTimeline.currentTopPage;
                const bottomPage = GraphicTimeline.currentBottomPage;
                const secondsPerPage = GraphicTimeline.getSecondsPerPage();
                const leadInSec = leadInSeconds;
                
                for (const motive of this.motives) {
                    if (!motive.elements || !motive.elements.group) continue;
                    
                    // Calculate which pages this motive spans
                    const startActual = motive.startSeconds + leadInSec;
                    const endActual = motive.endSeconds + leadInSec;
                    const motiveStartPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                    const motiveEndPage = Math.floor(Math.max(0, endActual) / secondsPerPage);
                    
                    // Check if motive overlaps with visible pages
                    const overlapsTop = motiveStartPage <= topPage && motiveEndPage >= topPage;
                    const overlapsBottom = motiveStartPage <= bottomPage && motiveEndPage >= bottomPage;
                    const visible = overlapsTop || overlapsBottom;
                    
                    const isMultiPage = motiveEndPage > motiveStartPage;
                    
                    if (!isMultiPage) {
                        // Single-page motive: simple show/hide
                        motive.elements.group.style.display = visible ? '' : 'none';
                        if (motive.elements.continuationGroupTop) {
                            motive.elements.continuationGroupTop.style.display = 'none';
                        }
                        if (motive.elements.continuationGroupBottom) {
                            motive.elements.continuationGroupBottom.style.display = 'none';
                        }
                    } else {
                        // Multi-page motive: show segments on each visible page
                        if (overlapsTop && topPage === motiveStartPage) {
                            motive.elements.group.style.display = '';
                            this.clipMotiveToPageEnd(motive, motiveStartPage, secondsPerPage, leadInSec);
                        } else if (overlapsBottom && bottomPage === motiveStartPage) {
                            motive.elements.group.style.display = '';
                            this.clipMotiveToPageEnd(motive, motiveStartPage, secondsPerPage, leadInSec);
                        } else {
                            motive.elements.group.style.display = 'none';
                        }
                        
                        // Continuation segments
                        const showContinuationOnTop = overlapsTop && topPage > motiveStartPage && topPage <= motiveEndPage;
                        const showContinuationOnBottom = overlapsBottom && bottomPage > motiveStartPage && bottomPage <= motiveEndPage;
                        
                        if (showContinuationOnTop) {
                            this.showContinuationSegment(motive, topPage, secondsPerPage, leadInSec, 'top');
                        } else if (motive.elements.continuationGroupTop) {
                            motive.elements.continuationGroupTop.style.display = 'none';
                        }
                        
                        if (showContinuationOnBottom) {
                            this.showContinuationSegment(motive, bottomPage, secondsPerPage, leadInSec, 'bottom');
                        } else if (motive.elements.continuationGroupBottom) {
                            motive.elements.continuationGroupBottom.style.display = 'none';
                        }
                    }
                }
            },
            
            clipMotiveToPageEnd(motive, page, secondsPerPage, leadInSec) {
                if (!motive.elements || !motive.elements.line) return;
                
                const endActual = motive.endSeconds + leadInSec;
                const pageEndTime = (page + 1) * secondsPerPage;
                
                if (endActual <= pageEndTime) return; // No clipping needed
                
                const section = page % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                
                // Clip x2 to page edge
                motive.elements.line.setAttribute('x2', scoreWidth);
                motive.elements.hitLine.setAttribute('x2', scoreWidth);
                motive.elements.highlight.setAttribute('x2', scoreWidth);
            },
            
            showContinuationSegment(motive, page, secondsPerPage, leadInSec, sectionHint) {
                const startActual = motive.startSeconds + leadInSec;
                const endActual = motive.endSeconds + leadInSec;
                const pageStartTime = page * secondsPerPage;
                const pageEndTime = (page + 1) * secondsPerPage;
                
                const clippedStartActual = Math.max(startActual, pageStartTime);
                const clippedEndActual = Math.min(endActual, pageEndTime);
                
                const section = sectionHint || (page % 2 === 0 ? 'top' : 'bottom');
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const targetContainer = section === 'top' ? this.topMotiveGroup : this.bottomMotiveGroup;
                const scoreWidth = scoreEl.clientWidth;
                
                // X positions within this page
                const startXPercent = ((clippedStartActual / secondsPerPage) - page) * 100;
                const endXPercent = ((clippedEndActual / secondsPerPage) - page) * 100;
                const x1Pixel = (startXPercent / 100) * scoreWidth;
                const x2Pixel = (endXPercent / 100) * scoreWidth;
                
                // Get track dimensions for this section
                let trackDims = motive.trackDims;
                if (motive.gTrack && window.CompositionPanel) {
                    trackDims = CompositionPanel.getTrackDimensions(motive.gTrack, scoreEl) || motive.trackDims;
                }
                const lineY = trackDims ? trackDims.y + 5 : 10;
                
                const groupKey = section === 'top' ? 'continuationGroupTop' : 'continuationGroupBottom';
                const lineKey = section === 'top' ? 'continuationLineTop' : 'continuationLineBottom';
                
                if (!motive.elements[groupKey]) {
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.classList.add('motive-continuation');
                    group.setAttribute('data-motive-id', motive.id);
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('stroke-width', '3');
                    line.setAttribute('stroke-linecap', 'round');
                    line.style.cursor = 'pointer';
                    line.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectMotive(motive);
                    });
                    group.appendChild(line);
                    
                    motive.elements[groupKey] = group;
                    motive.elements[lineKey] = line;
                }
                
                const color = ColorMap[motive.color] || motive.color;
                
                motive.elements[lineKey].setAttribute('x1', x1Pixel);
                motive.elements[lineKey].setAttribute('y1', lineY);
                motive.elements[lineKey].setAttribute('x2', x2Pixel);
                motive.elements[lineKey].setAttribute('y2', lineY);
                motive.elements[lineKey].setAttribute('stroke', color);
                
                motive.elements[groupKey].style.display = '';
                
                if (motive.elements[groupKey].parentNode !== targetContainer) {
                    targetContainer.appendChild(motive.elements[groupKey]);
                }
            },
            
            reloadFromDatabase() {
                // Clear existing motive elements
                if (this.topMotiveGroup) this.topMotiveGroup.innerHTML = '';
                if (this.bottomMotiveGroup) this.bottomMotiveGroup.innerHTML = '';
                this.motives = [];
                this.selectedMotive = null;
                
                // Recreate motives from database
                const dbMotives = MotiveDatabase.getAll();
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                for (const dbMotive of dbMotives) {
                    const motive = { ...dbMotive };
                    
                    // Recalculate positions
                    const startActual = motive.startSeconds + leadInSeconds;
                    const endActual = motive.endSeconds + leadInSeconds;
                    const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                    const section = startPage % 2 === 0 ? 'top' : 'bottom';
                    const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                    const motiveGroup = section === 'top' ? this.topMotiveGroup : this.bottomMotiveGroup;
                    const scoreWidth = scoreEl.clientWidth;
                    
                    const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                    const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                    motive.x1 = (startXPercent / 100) * scoreWidth;
                    motive.x2 = (endXPercent / 100) * scoreWidth;
                    motive.section = section;
                    motive.page = startPage;
                    
                    // Recalculate track dimensions
                    if (motive.gTrack && window.CompositionPanel) {
                        motive.trackDims = CompositionPanel.getTrackDimensions(motive.gTrack, scoreEl);
                    }
                    
                    // Render
                    this.renderMotive(motive, motiveGroup, scoreEl);
                    this.motives.push(motive);
                }
                
                console.debug(`MotiveMaker: Reloaded ${this.motives.length} motives from database`);
                this.updateVisibility();
            }
        };
        
        // Initialize Motive Maker
        MotiveMaker.init();
        window.MotiveMaker = MotiveMaker;
        
        // Bring SVG elements containers to front (after motives are initialized)
        if (window.SVGElementManager) {
            SVGElementManager.bringToFront();
        }
        
        /* DISABLED: Full MotiveMaker - entire system commented out (code kept for future reference)
        // ============================================
        // MOTIVE MAKER (FULL VERSION) - creates and manages motives with badges, notation, library
        // ============================================
        const MotiveMakerFull = {
            scoreTopEl: null,
            scoreBottomEl: null,
            topMotiveGroup: null,
            bottomMotiveGroup: null,
            
            // Rendered motives with elements
            motives: [],
            
            // UI elements
            nameDisplay: null,
            startInput: null,
            endInput: null,
            drawBtn: null,
            deleteBtn: null,
            saveBtn: null,
            descriptionInput: null,
            recallDropdown: null,
            recallSelected: null,
            recallOptions: null,
            recallSelect: null,
            insertBtn: null,
            colorSwatches: null,
            
            // Badge upload elements
            badgeUploadBtn: null,
            badgeClearBtn: null,
            badgeFileInput: null,
            badgePreview: null,
            currentBadgeData: null, // Base64 data URL for current badge
            
            // Notation upload elements
            notationUploadBtn: null,
            notationClearBtn: null,
            notationFileInput: null,
            notationPreview: null,
            currentNotationData: null, // Base64 data URL for current notation
            
            // Selected motive
            selectedMotive: null,
            selectedColor: 'neonMagenta',
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Get UI elements
                this.nameDisplay = document.getElementById('motiveNameDisplay');
                this.startInput = document.getElementById('motiveStartInput');
                this.endInput = document.getElementById('motiveEndInput');
                this.drawBtn = document.getElementById('motiveDrawBtn');
                this.deleteBtn = document.getElementById('motiveDeleteBtn');
                this.saveBtn = document.getElementById('motiveSaveBtn');
                this.descriptionInput = document.getElementById('motiveDescriptionInput');
                this.recallDropdown = document.getElementById('motiveRecallDropdown');
                this.recallSelected = document.getElementById('motiveRecallSelected');
                this.recallOptions = document.getElementById('motiveRecallOptions');
                this.recallSelect = document.getElementById('motiveRecallSelect');
                this.insertBtn = document.getElementById('motiveInsertBtn');
                this.colorSwatches = document.getElementById('motiveColorSwatches');
                
                // Badge upload elements
                this.badgeUploadBtn = document.getElementById('motiveBadgeUploadBtn');
                this.badgeClearBtn = document.getElementById('motiveBadgeClearBtn');
                this.badgeFileInput = document.getElementById('motiveBadgeFileInput');
                this.badgePreview = document.getElementById('motiveBadgePreview');
                
                // Notation upload elements
                this.notationUploadBtn = document.getElementById('motiveNotationUploadBtn');
                this.notationClearBtn = document.getElementById('motiveNotationClearBtn');
                this.notationFileInput = document.getElementById('motiveNotationFileInput');
                this.notationPreview = document.getElementById('motiveNotationPreview');
                
                // Create motive container groups
                this.topMotiveGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.bottomMotiveGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.topMotiveGroup.setAttribute('class', 'motive-container');
                this.bottomMotiveGroup.setAttribute('class', 'motive-container');
                this.scoreTopEl.appendChild(this.topMotiveGroup);
                this.scoreBottomEl.appendChild(this.bottomMotiveGroup);
                
                // Draw button handler
                if (this.drawBtn) {
                    this.drawBtn.addEventListener('click', () => this.createMotive());
                }
                
                // Delete button handler
                if (this.deleteBtn) {
                    this.deleteBtn.addEventListener('click', () => this.deleteSelectedMotive());
                }
                
                // Save button handler
                if (this.saveBtn) {
                    this.saveBtn.addEventListener('click', () => this.saveMotiveToLibrary());
                }
                
                // Insert button handler
                if (this.insertBtn) {
                    this.insertBtn.addEventListener('click', () => this.insertRecalledMotive());
                }
                
                // Custom dropdown toggle handler
                if (this.recallSelected) {
                    this.recallSelected.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = this.recallOptions.style.display !== 'none';
                        this.recallOptions.style.display = isOpen ? 'none' : 'block';
                    });
                }
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (this.recallOptions && !this.recallDropdown?.contains(e.target)) {
                        this.recallOptions.style.display = 'none';
                    }
                });
                
                // Color swatch handlers
                if (this.colorSwatches) {
                    this.colorSwatches.querySelectorAll('.motive-color-swatch').forEach(swatch => {
                        swatch.addEventListener('click', (e) => {
                            this.colorSwatches.querySelectorAll('.motive-color-swatch').forEach(s => {
                                s.classList.remove('selected');
                                s.style.outline = '';
                            });
                            e.target.classList.add('selected');
                            e.target.style.outline = '2px solid white';
                            this.selectedColor = e.target.dataset.color;
                            if (this.selectedMotive) {
                                this.selectedMotive.color = this.selectedColor;
                                this.updateMotiveRendering(this.selectedMotive);
                                this.syncMotiveToDatabase(this.selectedMotive);
                            }
                        });
                    });
                }
                
                // Badge upload handlers
                if (this.badgeUploadBtn) {
                    this.badgeUploadBtn.addEventListener('click', () => {
                        this.badgeFileInput?.click();
                    });
                }
                
                if (this.badgeFileInput) {
                    this.badgeFileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            this.handleBadgeUpload(file);
                        }
                    });
                }
                
                if (this.badgeClearBtn) {
                    this.badgeClearBtn.addEventListener('click', () => {
                        this.clearBadge();
                    });
                }
                
                // Notation upload handlers
                if (this.notationUploadBtn) {
                    this.notationUploadBtn.addEventListener('click', () => {
                        this.notationFileInput?.click();
                    });
                }
                
                if (this.notationFileInput) {
                    this.notationFileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            this.handleNotationUpload(file);
                        }
                    });
                }
                
                if (this.notationClearBtn) {
                    this.notationClearBtn.addEventListener('click', () => {
                        this.clearNotation();
                    });
                }
                
                // Input field handlers for editing selected motive
                if (this.startInput) {
                    this.startInput.addEventListener('change', () => this.updateSelectedFromInputs());
                }
                if (this.endInput) {
                    this.endInput.addEventListener('change', () => this.updateSelectedFromInputs());
                }
                
                // Click on score to deselect
                this.scoreTopEl.addEventListener('click', (e) => this.handleScoreClick(e, 'top'));
                this.scoreBottomEl.addEventListener('click', (e) => this.handleScoreClick(e, 'bottom'));
                
                // Re-render motives on window resize (debounced)
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.reloadFromDatabase();
                    }, 100);
                });
                
                // Load motive library
                this.loadMotiveLibrary();
                
                console.debug('MotiveMaker initialized');
            },
            
            // Create test motives for development
            createTestMotives() {
                const badgeSrc = '/SVG_graphics/walking on a carpet of twigs badge.png';
                const notationSrc1 = '/SVG_graphics/walking on a carpet of twigs motive.svg';
                const notationSrc2 = '/SVG_graphics/bartok pizz_b.svg';
                
                const testMotives = [
                    {
                        name: 'MOT_TEST_001',
                        startSeconds: 4.5,
                        endSeconds: 5.25,
                        gTrack: '1',
                        color: 'neonMagenta',
                        description: 'Test motive 4.5-5.25 seconds',
                        badgeSrc,
                        notationSrc: notationSrc1
                    },
                    {
                        name: 'MOT_TEST_002',
                        startSeconds: 10,
                        endSeconds: 14,
                        gTrack: '1',
                        color: 'neonMagenta',
                        description: 'Test motive 10-14 seconds',
                        badgeSrc,
                        notationSrc: notationSrc2
                    },
                    {
                        name: 'MOT_TEST_003',
                        startSeconds: 19,
                        endSeconds: 24,
                        gTrack: '1',
                        color: 'neonMagenta',
                        description: 'Test motive 19-24 seconds',
                        badgeSrc,
                        notationSrc: notationSrc1
                    },
                    {
                        name: 'MOT_TEST_004',
                        startSeconds: 28,
                        endSeconds: 34,
                        gTrack: '1',
                        color: 'neonMagenta',
                        description: 'Test motive 28-34 seconds',
                        badgeSrc,
                        notationSrc: notationSrc2
                    }
                ];
                
                for (const testMotiveData of testMotives) {
                    try {
                        // Calculate positions
                        const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                        const startActual = testMotiveData.startSeconds + leadInSeconds;
                        const endActual = testMotiveData.endSeconds + leadInSeconds;
                        const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                        const section = startPage % 2 === 0 ? 'top' : 'bottom';
                        const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                        const motiveGroup = section === 'top' ? this.topMotiveGroup : this.bottomMotiveGroup;
                        const scoreWidth = scoreEl.clientWidth;
                        
                        // Get track dimensions
                        const trackDims = window.CompositionPanel ? 
                            CompositionPanel.getTrackDimensions(testMotiveData.gTrack, scoreEl) : null;
                        
                        // Calculate X positions
                        const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                        const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                        const x1Pixel = (startXPercent / 100) * scoreWidth;
                        const x2Pixel = (endXPercent / 100) * scoreWidth;
                        
                        // Create full motive data
                        const motiveDataObj = {
                            ...testMotiveData,
                            section,
                            page: startPage,
                            x1: x1Pixel,
                            x2: x2Pixel,
                            trackDims
                        };
                        
                        // Generate motive data array (normalized progress values)
                        motiveDataObj.motiveData = this.generateMotiveDataArray(motiveDataObj);
                        
                        // Add to database
                        const motive = MotiveDatabase.add(motiveDataObj);
                        
                        // Render the motive
                        this.renderMotive(motive, motiveGroup, scoreEl);
                        
                        // Add to motives array
                        this.motives.push(motive);
                        
                        console.debug(`Test motive created: ${motive.name} (${motive.startSeconds}-${motive.endSeconds}s)`);
                    } catch (err) {
                        console.error('Error creating test motive:', err);
                    }
                }
                
                // Update visibility
                this.updateVisibility();
            },
            
            generateMotiveName() {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                return `MOT_${year}${month}${day}_${hours}${minutes}${seconds}`;
            },
            
            // Generate normalized pixel-by-pixel array of motive progress
            // At each X pixel, returns normalized value (0-1) of progress through the motive
            generateMotiveDataArray(motive) {
                const SAMPLE_INTERVAL = 0.01; // 10ms = 100 samples/second
                // Use display time (without lead-in) for time-based lookups
                const startTime = motive.startSeconds;
                const endTime = motive.endSeconds;
                const duration = endTime - startTime;
                
                if (duration <= 0) return { startTime, endTime, sampleInterval: SAMPLE_INTERVAL, samples: [], duration };
                
                const sampleCount = Math.ceil(duration / SAMPLE_INTERVAL) + 1;
                const samples = [];
                
                // For a straight line motive, the normalized value is simply the progress (0 to 1)
                for (let i = 0; i < sampleCount; i++) {
                    const progress = i / (sampleCount - 1);
                    samples.push(Math.max(0, Math.min(1, progress)));
                }
                
                return {
                    startTime,
                    endTime,
                    sampleInterval: SAMPLE_INTERVAL,
                    samples,
                    duration
                };
            },
            
            createMotive() {
                const startSeconds = parseFloat(this.startInput.value) || 0;
                const endSeconds = parseFloat(this.endInput.value) || 1;
                const gTrack = CompositionPanel.getSelectedGTrack();
                
                // Ignore GA selection for motives - default to track 1
                const actualGTrack = gTrack === 'A' ? '1' : gTrack;
                
                // Get track dimensions
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const startActual = startSeconds + leadInSeconds;
                const endActual = endSeconds + leadInSeconds;
                const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                
                const section = startPage % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const motiveGroup = section === 'top' ? this.topMotiveGroup : this.bottomMotiveGroup;
                const scoreWidth = scoreEl.clientWidth;
                
                const trackDims = window.CompositionPanel ? 
                    CompositionPanel.getTrackDimensions(actualGTrack, scoreEl) : null;
                
                // Calculate X positions
                const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                const x1Pixel = (startXPercent / 100) * scoreWidth;
                const x2Pixel = (endXPercent / 100) * scoreWidth;
                
                // Generate unique name
                const name = this.generateMotiveName();
                
                // Create motive data
                const motiveDataObj = {
                    name,
                    startSeconds,
                    endSeconds,
                    gTrack: actualGTrack,
                    color: this.selectedColor,
                    section,
                    page: startPage,
                    x1: x1Pixel,
                    x2: x2Pixel,
                    trackDims,
                    badgeSrc: this.currentBadgeData,
                    notationSrc: this.currentNotationData
                };
                
                // Generate motive data array
                motiveDataObj.motiveData = this.generateMotiveDataArray(motiveDataObj);
                
                // Add to database
                const motive = MotiveDatabase.add(motiveDataObj);
                
                // Mark score as dirty
                if (window.ScoreManager) ScoreManager.markDirty();
                
                // Render the motive
                this.renderMotive(motive, motiveGroup, scoreEl);
                
                // Add to motives array
                this.motives.push(motive);
                
                // Update visibility
                this.updateVisibility();
                
                // Auto-select the new motive
                this.selectMotive(motive);
                
                console.debug(`Motive created: ${motive.name} (ID: ${motive.id})`);
            },
            
            renderMotive(motive, motiveGroup, scoreEl) {
                const color = ColorMap[motive.color] || motive.color;
                const trackDims = motive.trackDims;
                
                // Create SVG group for this motive
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('data-motive-id', motive.id);
                group.setAttribute('class', 'motive-element');
                
                // Badge height is 30% of track height (if badge exists)
                const trackHeight = trackDims ? trackDims.height : 100;
                const badgeHeight = motive.badgeSrc ? Math.floor(trackHeight * 0.30) : 0;
                const badgeMargin = motive.badgeSrc ? 2 : 0;
                
                // Motive line is below the badge
                const lineY = trackDims ? trackDims.y + badgeHeight + badgeMargin + 2 : 10;
                
                // Create badge image if badge source exists
                let badge = null;
                if (motive.badgeSrc) {
                    badge = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    badge.setAttribute('href', motive.badgeSrc);
                    badge.setAttribute('x', motive.x1);
                    badge.setAttribute('y', trackDims ? trackDims.y + 2 : 2);
                    badge.setAttribute('height', badgeHeight);
                    // Width will be set by preserveAspectRatio
                    badge.setAttribute('preserveAspectRatio', 'xMinYMin meet');
                    badge.style.cursor = 'pointer';
                    badge.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectMotive(motive);
                    });
                    group.appendChild(badge);
                }
                
                // Create the line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', motive.x1);
                line.setAttribute('y1', lineY);
                line.setAttribute('x2', motive.x2);
                line.setAttribute('y2', lineY);
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-width', '3');
                line.setAttribute('stroke-linecap', 'round');
                line.style.cursor = 'pointer';
                group.appendChild(line);
                
                // Create invisible wider hit area for easier clicking
                const hitLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hitLine.setAttribute('x1', motive.x1);
                hitLine.setAttribute('y1', lineY);
                hitLine.setAttribute('x2', motive.x2);
                hitLine.setAttribute('y2', lineY);
                hitLine.setAttribute('stroke', 'transparent');
                hitLine.setAttribute('stroke-width', '15');
                hitLine.style.cursor = 'pointer';
                hitLine.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectMotive(motive);
                });
                group.appendChild(hitLine);
                
                // Create selection highlight (yellow glow, hidden by default)
                const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                highlight.setAttribute('x1', motive.x1);
                highlight.setAttribute('y1', lineY);
                highlight.setAttribute('x2', motive.x2);
                highlight.setAttribute('y2', lineY);
                highlight.setAttribute('stroke', 'yellow');
                highlight.setAttribute('stroke-width', '7');
                highlight.setAttribute('stroke-linecap', 'round');
                highlight.setAttribute('stroke-opacity', '0.5');
                highlight.style.display = 'none';
                group.insertBefore(highlight, line);
                
                // Store element references
                motive.elements = {
                    group,
                    line,
                    hitLine,
                    highlight,
                    badge,
                    lineY,
                    badgeHeight
                };
                
                motiveGroup.appendChild(group);
            },
            
            selectMotive(motive) {
                // Deselect previous
                if (this.selectedMotive && this.selectedMotive.elements) {
                    if (this.selectedMotive.elements.highlight) {
                        this.selectedMotive.elements.highlight.style.display = 'none';
                    }
                }
                
                this.selectedMotive = motive;
                
                // Show selection highlight (yellow glow like connector system)
                if (motive.elements && motive.elements.highlight) {
                    motive.elements.highlight.style.display = '';
                }
                
                // Update UI
                if (this.nameDisplay) this.nameDisplay.value = motive.name;
                if (this.startInput) this.startInput.value = motive.startSeconds.toFixed(3);
                if (this.endInput) this.endInput.value = motive.endSeconds.toFixed(3);
                if (this.descriptionInput) this.descriptionInput.value = motive.description || '';
                
                // Update color swatch selection
                if (this.colorSwatches) {
                    this.colorSwatches.querySelectorAll('.motive-color-swatch').forEach(s => {
                        s.classList.remove('selected');
                        s.style.outline = '';
                        if (s.dataset.color === motive.color) {
                            s.classList.add('selected');
                            s.style.outline = '2px solid white';
                        }
                    });
                }
                this.selectedColor = motive.color;
                
                // Update badge preview
                this.updateBadgePreview(motive.badgeSrc);
                
                // Update notation preview
                this.updateNotationPreview(motive.notationSrc);
            },
            
            deselectMotive() {
                if (this.selectedMotive && this.selectedMotive.elements) {
                    if (this.selectedMotive.elements.highlight) {
                        this.selectedMotive.elements.highlight.style.display = 'none';
                    }
                }
                this.selectedMotive = null;
                
                // Clear UI
                if (this.nameDisplay) this.nameDisplay.value = '';
                
                // Clear badge preview
                this.updateBadgePreview(null);
                
                // Clear notation preview
                this.updateNotationPreview(null);
            },
            
            handleScoreClick(e, section) {
                // Check if click was on a motive element
                const target = e.target;
                const motiveGroup = target.closest('.motive-element');
                if (!motiveGroup) {
                    this.deselectMotive();
                }
            },
            
            deleteSelectedMotive() {
                if (!this.selectedMotive) return;
                
                const motive = this.selectedMotive;
                
                // Remove from DOM
                if (motive.elements && motive.elements.group) {
                    motive.elements.group.remove();
                }
                
                // Remove continuation segments
                if (motive.elements && motive.elements.continuationGroupTop) {
                    motive.elements.continuationGroupTop.remove();
                }
                if (motive.elements && motive.elements.continuationGroupBottom) {
                    motive.elements.continuationGroupBottom.remove();
                }
                
                // Remove from database
                MotiveDatabase.remove(motive.id);
                
                // Remove from local array
                const index = this.motives.findIndex(m => m.id === motive.id);
                if (index !== -1) {
                    this.motives.splice(index, 1);
                }
                
                // Mark score as dirty
                if (window.ScoreManager) ScoreManager.markDirty();
                
                this.deselectMotive();
                console.debug(`Motive deleted: ${motive.name}`);
            },
            
            updateSelectedFromInputs() {
                if (!this.selectedMotive) return;
                
                const motive = this.selectedMotive;
                const newStart = parseFloat(this.startInput.value) || 0;
                const newEnd = parseFloat(this.endInput.value) || 1;
                
                // Update motive data
                motive.startSeconds = newStart;
                motive.endSeconds = newEnd;
                
                // Recalculate positions
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const startActual = newStart + leadInSeconds;
                const endActual = newEnd + leadInSeconds;
                const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                
                const section = startPage % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                
                const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                
                motive.x1 = (startXPercent / 100) * scoreWidth;
                motive.x2 = (endXPercent / 100) * scoreWidth;
                motive.page = startPage;
                motive.section = section;
                
                // Regenerate motive data array
                motive.motiveData = this.generateMotiveDataArray(motive);
                
                // Update rendering
                this.updateMotiveRendering(motive);
                this.syncMotiveToDatabase(motive);
                this.updateVisibility();
            },
            
            updateMotiveRendering(motive) {
                if (!motive.elements) return;
                
                const { line, hitLine, highlight, badge, group } = motive.elements;
                const color = ColorMap[motive.color] || motive.color;
                const trackDims = motive.trackDims;
                
                // Recalculate badge height and line Y position
                const trackHeight = trackDims ? trackDims.height : 100;
                const badgeHeight = motive.badgeSrc ? Math.floor(trackHeight * 0.30) : 0;
                const badgeMargin = motive.badgeSrc ? 2 : 0;
                const lineY = trackDims ? trackDims.y + badgeHeight + badgeMargin + 2 : 10;
                
                // Update line positions
                line.setAttribute('x1', motive.x1);
                line.setAttribute('x2', motive.x2);
                line.setAttribute('y1', lineY);
                line.setAttribute('y2', lineY);
                line.setAttribute('stroke', color);
                
                hitLine.setAttribute('x1', motive.x1);
                hitLine.setAttribute('x2', motive.x2);
                hitLine.setAttribute('y1', lineY);
                hitLine.setAttribute('y2', lineY);
                
                highlight.setAttribute('x1', motive.x1);
                highlight.setAttribute('x2', motive.x2);
                highlight.setAttribute('y1', lineY);
                highlight.setAttribute('y2', lineY);
                
                // Update or create/remove badge
                if (motive.badgeSrc) {
                    if (badge) {
                        // Update existing badge
                        badge.setAttribute('href', motive.badgeSrc);
                        badge.setAttribute('x', motive.x1);
                        badge.setAttribute('y', trackDims ? trackDims.y + 2 : 2);
                        badge.setAttribute('height', badgeHeight);
                        badge.style.display = '';
                    } else {
                        // Create new badge
                        const newBadge = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                        newBadge.setAttribute('href', motive.badgeSrc);
                        newBadge.setAttribute('x', motive.x1);
                        newBadge.setAttribute('y', trackDims ? trackDims.y + 2 : 2);
                        newBadge.setAttribute('height', badgeHeight);
                        newBadge.setAttribute('preserveAspectRatio', 'xMinYMin meet');
                        newBadge.style.cursor = 'pointer';
                        newBadge.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.selectMotive(motive);
                        });
                        group.insertBefore(newBadge, group.firstChild);
                        motive.elements.badge = newBadge;
                    }
                } else if (badge) {
                    // Remove badge if it exists but badgeSrc is null
                    badge.style.display = 'none';
                }
                
                // Store updated lineY
                motive.elements.lineY = lineY;
            },
            
            syncMotiveToDatabase(motive) {
                // Mark score as dirty
                if (window.ScoreManager) ScoreManager.markDirty();
                
                // Update in database
                MotiveDatabase.update(motive.id, {
                    startSeconds: motive.startSeconds,
                    endSeconds: motive.endSeconds,
                    color: motive.color,
                    x1: motive.x1,
                    x2: motive.x2,
                    motiveData: motive.motiveData,
                    badgeSrc: motive.badgeSrc,
                    notationSrc: motive.notationSrc
                });
            },
            
            handleBadgeUpload(file) {
                const validTypes = ['image/svg+xml', 'image/png', 'image/jpeg', 'image/jpg'];
                if (!validTypes.includes(file.type)) {
                    alert('Please upload an SVG, PNG, or JPEG image.');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    this.currentBadgeData = dataUrl;
                    
                    // Update preview
                    if (this.badgePreview) {
                        this.badgePreview.innerHTML = `<img src="${dataUrl}" style="max-height: 100%; max-width: 100%; object-fit: contain;">`;
                    }
                    
                    // If a motive is selected, update it with the badge
                    if (this.selectedMotive) {
                        this.selectedMotive.badgeSrc = dataUrl;
                        this.updateMotiveRendering(this.selectedMotive);
                        this.syncMotiveToDatabase(this.selectedMotive);
                        this.updateVisibility();
                    }
                };
                reader.readAsDataURL(file);
            },
            
            clearBadge() {
                this.currentBadgeData = null;
                
                // Reset preview
                if (this.badgePreview) {
                    this.badgePreview.innerHTML = '<span style="font-size: 9px; color: #666;">No badge</span>';
                }
                
                // If a motive is selected, remove its badge
                if (this.selectedMotive) {
                    this.selectedMotive.badgeSrc = null;
                    this.updateMotiveRendering(this.selectedMotive);
                    this.syncMotiveToDatabase(this.selectedMotive);
                    this.updateVisibility();
                }
                
                // Reset file input
                if (this.badgeFileInput) {
                    this.badgeFileInput.value = '';
                }
            },
            
            updateBadgePreview(badgeSrc) {
                if (this.badgePreview) {
                    if (badgeSrc) {
                        this.badgePreview.innerHTML = `<img src="${badgeSrc}" style="max-height: 100%; max-width: 100%; object-fit: contain;">`;
                        this.currentBadgeData = badgeSrc;
                    } else {
                        this.badgePreview.innerHTML = '<span style="font-size: 9px; color: #666;">No badge</span>';
                        this.currentBadgeData = null;
                    }
                }
            },
            
            handleNotationUpload(file) {
                const validTypes = ['image/svg+xml', 'image/png', 'image/jpeg', 'image/jpg'];
                if (!validTypes.includes(file.type)) {
                    alert('Please upload an SVG, PNG, or JPEG image.');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    this.currentNotationData = dataUrl;
                    
                    // Update preview
                    if (this.notationPreview) {
                        this.notationPreview.innerHTML = `<img src="${dataUrl}" style="max-height: 100%; max-width: 100%; object-fit: contain;">`;
                    }
                    
                    // If a motive is selected, update it with the notation
                    if (this.selectedMotive) {
                        this.selectedMotive.notationSrc = dataUrl;
                        this.syncMotiveToDatabase(this.selectedMotive);
                    }
                };
                reader.readAsDataURL(file);
            },
            
            clearNotation() {
                this.currentNotationData = null;
                
                // Reset preview
                if (this.notationPreview) {
                    this.notationPreview.innerHTML = '<span style="font-size: 9px; color: #666;">No notation</span>';
                }
                
                // If a motive is selected, remove its notation
                if (this.selectedMotive) {
                    this.selectedMotive.notationSrc = null;
                    this.syncMotiveToDatabase(this.selectedMotive);
                }
                
                // Reset file input
                if (this.notationFileInput) {
                    this.notationFileInput.value = '';
                }
            },
            
            updateNotationPreview(notationSrc) {
                if (this.notationPreview) {
                    if (notationSrc) {
                        this.notationPreview.innerHTML = `<img src="${notationSrc}" style="max-height: 100%; max-width: 100%; object-fit: contain;">`;
                        this.currentNotationData = notationSrc;
                    } else {
                        this.notationPreview.innerHTML = '<span style="font-size: 9px; color: #666;">No notation</span>';
                        this.currentNotationData = null;
                    }
                }
            },
            
            // Show/hide motives based on current page (supports multi-page motives)
            updateVisibility() {
                if (!window.GraphicTimeline) return;
                
                const topPage = GraphicTimeline.currentTopPage;
                const bottomPage = GraphicTimeline.currentBottomPage;
                const secondsPerPage = GraphicTimeline.getSecondsPerPage();
                const leadInSec = leadInSeconds;
                
                for (const motive of this.motives) {
                    if (!motive.elements || !motive.elements.group) continue;
                    
                    // Calculate which pages this motive spans
                    const startActual = motive.startSeconds + leadInSec;
                    const endActual = motive.endSeconds + leadInSec;
                    const motiveStartPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                    const motiveEndPage = Math.floor(Math.max(0, endActual) / secondsPerPage);
                    
                    // Check if motive overlaps with visible pages
                    const overlapsTop = motiveStartPage <= topPage && motiveEndPage >= topPage;
                    const overlapsBottom = motiveStartPage <= bottomPage && motiveEndPage >= bottomPage;
                    const visible = overlapsTop || overlapsBottom;
                    
                    const isMultiPage = motiveEndPage > motiveStartPage;
                    
                    if (!isMultiPage) {
                        // Single-page motive: simple show/hide
                        motive.elements.group.style.display = visible ? '' : 'none';
                        if (motive.elements.continuationGroupTop) {
                            motive.elements.continuationGroupTop.style.display = 'none';
                        }
                        if (motive.elements.continuationGroupBottom) {
                            motive.elements.continuationGroupBottom.style.display = 'none';
                        }
                    } else {
                        // Multi-page motive: show segments on each visible page
                        if (overlapsTop && topPage === motiveStartPage) {
                            motive.elements.group.style.display = '';
                            this.clipMotiveToPageEnd(motive, motiveStartPage, secondsPerPage, leadInSec);
                        } else if (overlapsBottom && bottomPage === motiveStartPage) {
                            motive.elements.group.style.display = '';
                            this.clipMotiveToPageEnd(motive, motiveStartPage, secondsPerPage, leadInSec);
                        } else {
                            motive.elements.group.style.display = 'none';
                        }
                        
                        // Continuation segments
                        const showContinuationOnTop = overlapsTop && topPage > motiveStartPage && topPage <= motiveEndPage;
                        const showContinuationOnBottom = overlapsBottom && bottomPage > motiveStartPage && bottomPage <= motiveEndPage;
                        
                        if (showContinuationOnTop) {
                            this.showContinuationSegment(motive, topPage, secondsPerPage, leadInSec, 'top');
                        } else if (motive.elements.continuationGroupTop) {
                            motive.elements.continuationGroupTop.style.display = 'none';
                        }
                        
                        if (showContinuationOnBottom) {
                            this.showContinuationSegment(motive, bottomPage, secondsPerPage, leadInSec, 'bottom');
                        } else if (motive.elements.continuationGroupBottom) {
                            motive.elements.continuationGroupBottom.style.display = 'none';
                        }
                    }
                }
            },
            
            clipMotiveToPageEnd(motive, page, secondsPerPage, leadInSec) {
                if (!motive.elements || !motive.elements.line) return;
                
                const endActual = motive.endSeconds + leadInSec;
                const pageEndTime = (page + 1) * secondsPerPage;
                
                if (endActual <= pageEndTime) return; // No clipping needed
                
                const section = page % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                
                // Clip x2 to page edge
                motive.elements.line.setAttribute('x2', scoreWidth);
                motive.elements.hitLine.setAttribute('x2', scoreWidth);
                motive.elements.highlight.setAttribute('x2', scoreWidth);
            },
            
            showContinuationSegment(motive, page, secondsPerPage, leadInSec, sectionHint) {
                const startActual = motive.startSeconds + leadInSec;
                const endActual = motive.endSeconds + leadInSec;
                const pageStartTime = page * secondsPerPage;
                const pageEndTime = (page + 1) * secondsPerPage;
                
                const clippedStartActual = Math.max(startActual, pageStartTime);
                const clippedEndActual = Math.min(endActual, pageEndTime);
                
                const section = sectionHint || (page % 2 === 0 ? 'top' : 'bottom');
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const targetContainer = section === 'top' ? this.topMotiveGroup : this.bottomMotiveGroup;
                const scoreWidth = scoreEl.clientWidth;
                
                // X positions within this page
                const startXPercent = ((clippedStartActual / secondsPerPage) - page) * 100;
                const endXPercent = ((clippedEndActual / secondsPerPage) - page) * 100;
                const x1Pixel = (startXPercent / 100) * scoreWidth;
                const x2Pixel = (endXPercent / 100) * scoreWidth;
                
                // Get track dimensions for this section
                let trackDims = motive.trackDims;
                if (motive.gTrack && window.CompositionPanel) {
                    trackDims = CompositionPanel.getTrackDimensions(motive.gTrack, scoreEl) || motive.trackDims;
                }
                // Badge height is 30% of track height (if badge exists)
                const trackHeight = trackDims ? trackDims.height : 100;
                const badgeHeight = motive.badgeSrc ? Math.floor(trackHeight * 0.30) : 0;
                const badgeMargin = motive.badgeSrc ? 2 : 0;
                const lineY = trackDims ? trackDims.y + badgeHeight + badgeMargin + 2 : 10;
                
                const groupKey = section === 'top' ? 'continuationGroupTop' : 'continuationGroupBottom';
                const lineKey = section === 'top' ? 'continuationLineTop' : 'continuationLineBottom';
                const badgeKey = section === 'top' ? 'continuationBadgeTop' : 'continuationBadgeBottom';
                
                if (!motive.elements[groupKey]) {
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.classList.add('motive-continuation');
                    group.setAttribute('data-motive-id', motive.id);
                    
                    // Create badge for continuation segment if badge exists
                    if (motive.badgeSrc) {
                        const contBadge = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                        contBadge.setAttribute('href', motive.badgeSrc);
                        contBadge.setAttribute('height', badgeHeight);
                        contBadge.setAttribute('preserveAspectRatio', 'xMinYMin meet');
                        contBadge.style.cursor = 'pointer';
                        contBadge.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.selectMotive(motive);
                        });
                        group.appendChild(contBadge);
                        motive.elements[badgeKey] = contBadge;
                    }
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('stroke-width', '3');
                    line.setAttribute('stroke-linecap', 'round');
                    line.style.cursor = 'pointer';
                    line.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectMotive(motive);
                    });
                    group.appendChild(line);
                    
                    motive.elements[groupKey] = group;
                    motive.elements[lineKey] = line;
                }
                
                const color = ColorMap[motive.color] || motive.color;
                
                // Update badge position (at start of this segment)
                if (motive.elements[badgeKey]) {
                    motive.elements[badgeKey].setAttribute('x', x1Pixel);
                    motive.elements[badgeKey].setAttribute('y', trackDims ? trackDims.y + 2 : 2);
                    motive.elements[badgeKey].setAttribute('height', badgeHeight);
                }
                
                motive.elements[lineKey].setAttribute('x1', x1Pixel);
                motive.elements[lineKey].setAttribute('y1', lineY);
                motive.elements[lineKey].setAttribute('x2', x2Pixel);
                motive.elements[lineKey].setAttribute('y2', lineY);
                motive.elements[lineKey].setAttribute('stroke', color);
                
                motive.elements[groupKey].style.display = '';
                
                if (motive.elements[groupKey].parentNode !== targetContainer) {
                    targetContainer.appendChild(motive.elements[groupKey]);
                }
            },
            
            reloadFromDatabase() {
                // Clear existing motive elements
                if (this.topMotiveGroup) this.topMotiveGroup.innerHTML = '';
                if (this.bottomMotiveGroup) this.bottomMotiveGroup.innerHTML = '';
                this.motives = [];
                this.selectedMotive = null;
                
                // Recreate motives from database
                const dbMotives = MotiveDatabase.getAll();
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                for (const dbMotive of dbMotives) {
                    const motive = { ...dbMotive };
                    
                    // Recalculate positions
                    const startActual = motive.startSeconds + leadInSeconds;
                    const endActual = motive.endSeconds + leadInSeconds;
                    const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                    const section = startPage % 2 === 0 ? 'top' : 'bottom';
                    const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                    const motiveGroup = section === 'top' ? this.topMotiveGroup : this.bottomMotiveGroup;
                    const scoreWidth = scoreEl.clientWidth;
                    
                    const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                    const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                    motive.x1 = (startXPercent / 100) * scoreWidth;
                    motive.x2 = (endXPercent / 100) * scoreWidth;
                    motive.section = section;
                    motive.page = startPage;
                    
                    // Recalculate track dimensions
                    if (motive.gTrack && window.CompositionPanel) {
                        motive.trackDims = CompositionPanel.getTrackDimensions(motive.gTrack, scoreEl);
                    }
                    
                    // Render
                    this.renderMotive(motive, motiveGroup, scoreEl);
                    this.motives.push(motive);
                }
                
                console.debug(`MotiveMaker: Reloaded ${this.motives.length} motives from database`);
                this.updateVisibility();
            },
            
            // Library operations
            async saveMotiveToLibrary() {
                if (!this.selectedMotive) {
                    alert('No motive selected. Select a motive to save.');
                    return;
                }
                
                const motive = this.selectedMotive;
                const description = this.descriptionInput?.value || '';
                
                const motiveData = {
                    name: motive.name,
                    description: description,
                    startSeconds: motive.startSeconds,
                    endSeconds: motive.endSeconds,
                    gTrack: motive.gTrack,
                    color: motive.color,
                    motiveData: motive.motiveData,
                    duration: motive.endSeconds - motive.startSeconds,
                    badgeSrc: motive.badgeSrc,
                    notationSrc: motive.notationSrc
                };
                
                try {
                    const response = await fetch('/api/motive-library/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ motiveData })
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        console.debug(`Motive saved to library: ${motive.name}`);
                        alert(`Motive "${motive.name}" saved to library.`);
                        this.loadMotiveLibrary();
                    } else {
                        alert(`Failed to save motive: ${result.error}`);
                    }
                } catch (err) {
                    console.error('Error saving motive:', err);
                    alert(`Error saving motive: ${err.message}`);
                }
            },
            
            async loadMotiveLibrary() {
                if (!this.recallOptions) return;
                
                try {
                    const response = await fetch('/api/motive-library/list');
                    const result = await response.json();
                    
                    if (result.success) {
                        this.recallOptions.innerHTML = '';
                        
                        if (this.recallSelect) this.recallSelect.value = '';
                        if (this.recallSelected) this.recallSelected.textContent = '-- Select Saved Motive --';
                        
                        // Placeholder option
                        const placeholder = document.createElement('div');
                        placeholder.className = 'custom-dropdown-option';
                        placeholder.style.cssText = 'padding: 6px 8px; cursor: pointer; font-size: 10px; color: #888; border-bottom: 1px solid #444;';
                        placeholder.textContent = '-- Select Saved Motive --';
                        placeholder.dataset.value = '';
                        placeholder.addEventListener('click', () => this.selectRecallOption('', '-- Select Saved Motive --'));
                        placeholder.addEventListener('mouseenter', () => placeholder.style.background = 'rgba(60,60,80,0.8)');
                        placeholder.addEventListener('mouseleave', () => placeholder.style.background = '');
                        this.recallOptions.appendChild(placeholder);
                        
                        for (const motive of result.motives) {
                            const option = document.createElement('div');
                            option.className = 'custom-dropdown-option';
                            option.style.cssText = 'padding: 6px 8px; cursor: pointer; border-bottom: 1px solid #333;';
                            option.dataset.value = motive.name;
                            
                            const nameLine = document.createElement('div');
                            nameLine.style.cssText = 'font-size: 10px; font-weight: bold; color: #ddd;';
                            const dur = motive.duration ? ` (${motive.duration.toFixed(1)}s)` : '';
                            nameLine.textContent = `${motive.name}${dur}`;
                            option.appendChild(nameLine);
                            
                            if (motive.description) {
                                const descLine = document.createElement('div');
                                descLine.style.cssText = 'font-size: 9px; color: #999; margin-top: 2px;';
                                descLine.textContent = motive.description;
                                option.appendChild(descLine);
                            }
                            
                            option.addEventListener('click', () => this.selectRecallOption(motive.name, `${motive.name}${dur}`));
                            option.addEventListener('mouseenter', () => option.style.background = 'rgba(60,60,80,0.8)');
                            option.addEventListener('mouseleave', () => option.style.background = '');
                            this.recallOptions.appendChild(option);
                        }
                        
                        console.debug(`Loaded ${result.motives.length} motives from library`);
                    }
                } catch (err) {
                    console.debug('Motive library not available yet');
                }
            },
            
            selectRecallOption(value, displayText) {
                if (this.recallSelect) this.recallSelect.value = value;
                if (this.recallSelected) this.recallSelected.textContent = displayText;
                if (this.recallOptions) this.recallOptions.style.display = 'none';
            },
            
            async insertRecalledMotive() {
                const selectedName = this.recallSelect?.value;
                if (!selectedName) {
                    alert('Select a motive from the library to insert.');
                    return;
                }
                
                let insertionSeconds = 0;
                if (window.EditCursor && typeof EditCursor.getPositionSeconds === 'function') {
                    insertionSeconds = EditCursor.getPositionSeconds();
                } else if (window.EditCursor) {
                    insertionSeconds = EditCursor.positionSeconds || 0;
                }
                
                const targetGTrack = window.CompositionPanel ? CompositionPanel.getSelectedGTrack() : '1';
                const actualGTrack = targetGTrack === 'A' ? '1' : targetGTrack;
                
                try {
                    const response = await fetch(`/api/motive-library/load/${encodeURIComponent(selectedName)}`);
                    const result = await response.json();
                    
                    if (!result.success) {
                        alert(`Failed to load motive: ${result.error}`);
                        return;
                    }
                    
                    const savedMotive = result.motiveData;
                    const duration = savedMotive.duration || (savedMotive.endSeconds - savedMotive.startSeconds);
                    
                    const newStartSeconds = insertionSeconds;
                    const newEndSeconds = insertionSeconds + duration;
                    
                    // Calculate positions
                    const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                    const startActual = newStartSeconds + leadInSeconds;
                    const endActual = newEndSeconds + leadInSeconds;
                    const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                    
                    const section = startPage % 2 === 0 ? 'top' : 'bottom';
                    const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                    const motiveGroup = section === 'top' ? this.topMotiveGroup : this.bottomMotiveGroup;
                    const scoreWidth = scoreEl.clientWidth;
                    
                    const trackDims = window.CompositionPanel ? 
                        CompositionPanel.getTrackDimensions(actualGTrack, scoreEl) : null;
                    
                    const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                    const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                    const x1Pixel = (startXPercent / 100) * scoreWidth;
                    const x2Pixel = (endXPercent / 100) * scoreWidth;
                    
                    const name = this.generateMotiveName();
                    
                    const motiveDataObj = {
                        name,
                        startSeconds: newStartSeconds,
                        endSeconds: newEndSeconds,
                        gTrack: actualGTrack,
                        color: savedMotive.color,
                        section,
                        page: startPage,
                        x1: x1Pixel,
                        x2: x2Pixel,
                        trackDims,
                        badgeSrc: savedMotive.badgeSrc,
                        notationSrc: savedMotive.notationSrc
                    };
                    
                    motiveDataObj.motiveData = this.generateMotiveDataArray(motiveDataObj);
                    
                    const motive = MotiveDatabase.add(motiveDataObj);
                    
                    if (window.ScoreManager) ScoreManager.markDirty();
                    
                    this.renderMotive(motive, motiveGroup, scoreEl);
                    this.motives.push(motive);
                    this.updateVisibility();
                    this.selectMotive(motive);
                    
                    console.debug(`Motive inserted: ${motive.name} at ${newStartSeconds}s`);
                    
                } catch (err) {
                    console.error('Error inserting motive:', err);
                    alert(`Error inserting motive: ${err.message}`);
                }
            },
            
            // Get motive progress value at a given time (for motive follower)
            getMotiveProgressAtTime(gTrack, timeSec) {
                for (const motive of this.motives) {
                    if (motive.gTrack !== gTrack) continue;
                    if (!motive.motiveData) continue;
                    
                    const { startTime, endTime, sampleInterval, samples } = motive.motiveData;
                    
                    if (timeSec >= startTime && timeSec <= endTime) {
                        const timeOffset = timeSec - startTime;
                        const sampleIndex = Math.floor(timeOffset / sampleInterval);
                        
                        if (sampleIndex >= 0 && sampleIndex < samples.length) {
                            return {
                                motive,
                                progress: samples[sampleIndex],
                                color: motive.color,
                                notationSrc: motive.notationSrc
                            };
                        }
                    }
                }
                return null;
            },
            
            // Get upcoming motive within lookahead seconds (for countdown dial)
            getUpcomingMotiveAtTime(gTrack, timeSec, lookaheadSeconds = 3) {
                for (const motive of this.motives) {
                    if (motive.gTrack !== gTrack) continue;
                    if (!motive.motiveData) continue;
                    
                    const { startTime } = motive.motiveData;
                    const timeUntilStart = startTime - timeSec;
                    
                    // Check if motive starts within lookahead window (but hasn't started yet)
                    if (timeUntilStart > 0 && timeUntilStart <= lookaheadSeconds) {
                        // Calculate countdown progress (0 = lookahead seconds before, 1 = about to start)
                        const countdownProgress = 1 - (timeUntilStart / lookaheadSeconds);
                        
                        return {
                            motive,
                            countdownProgress,
                            timeUntilStart,
                            color: motive.color,
                            notationSrc: motive.notationSrc
                        };
                    }
                }
                return null;
            },
            
            // Get the next upcoming motive (regardless of time distance)
            getNextUpcomingMotive(gTrack, timeSec) {
                let nextMotive = null;
                let minTimeUntilStart = Infinity;
                
                for (const motive of this.motives) {
                    if (motive.gTrack !== gTrack) continue;
                    if (!motive.motiveData) continue;
                    
                    const { startTime } = motive.motiveData;
                    const timeUntilStart = startTime - timeSec;
                    
                    // Find the next motive that hasn't started yet
                    if (timeUntilStart > 0 && timeUntilStart < minTimeUntilStart) {
                        minTimeUntilStart = timeUntilStart;
                        nextMotive = motive;
                    }
                }
                
                if (nextMotive) {
                    return {
                        motive: nextMotive,
                        timeUntilStart: minTimeUntilStart,
                        color: nextMotive.color,
                        notationSrc: nextMotive.notationSrc
                    };
                }
                return null;
            },
            
            // Get the next two motives for static windows from a given page start time
            // Returns: window2Motive (top slot - current/next), window1Motive (bottom slot - the one after)
            getNextTwoMotives(gTrack, pageStartTimeSec) {
                // Get all motives for this track that are active at or start after the page start time
                // A motive is relevant if: it ends after pageStartTimeSec (still active or upcoming)
                const relevantMotives = this.motives
                    .filter(m => m.gTrack === gTrack && m.motiveData)
                    .filter(m => {
                        const endTime = m.motiveData.startTime + m.motiveData.duration;
                        return endTime > pageStartTimeSec; // Motive ends after page starts
                    })
                    .sort((a, b) => a.motiveData.startTime - b.motiveData.startTime);
                
                let window2Motive = null; // Top slot: current or next upcoming
                let window1Motive = null; // Bottom slot: the one after window2
                
                // First motive is the current/next one (top slot)
                if (relevantMotives.length > 0) {
                    const m = relevantMotives[0];
                    const isActive = m.motiveData.startTime <= pageStartTimeSec && 
                                     (m.motiveData.startTime + m.motiveData.duration) > pageStartTimeSec;
                    window2Motive = {
                        motive: m,
                        notationSrc: m.notationSrc,
                        color: m.color,
                        isActive: isActive
                    };
                }
                
                // Second motive is the one after (bottom slot)
                if (relevantMotives.length > 1) {
                    const m = relevantMotives[1];
                    window1Motive = {
                        motive: m,
                        notationSrc: m.notationSrc,
                        color: m.color,
                        isActive: false
                    };
                }
                
                return { window1Motive, window2Motive };
            }
        };
        
        // Initialize Motive Maker
        MotiveMaker.init();
        window.MotiveMaker = MotiveMaker;
        
        // DISABLED: Test motives removed
        // MotiveMaker.createTestMotives();
        /* END OF DISABLED MotiveMaker */
        
        
        // Initialize Score Manager (after all other systems)
        ScoreManager.init();
        window.ScoreManager = ScoreManager;
        
        // Initialize Notation Manager and register with ScoreManager
        NotationManager.init();
        window.NotationManager = NotationManager;
        ScoreManager.registerNotationSource();
    </script>
</body>
</html>
