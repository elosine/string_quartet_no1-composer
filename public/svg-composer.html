<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Composer</title>
    <style>
        :root {
            --clr-brightOrange: rgba(240,75,0,255);
            --clr-brightBlue: rgba(56,126,211,255);
            --clr-mustard: rgba(244,182,0,255);
            --clr-brightRed: rgba(229,42,25,255);
            --clr-green: rgba(0,147,92,255);
            --clr-navyBlue: rgba(28,72,121,255);
            --clr-plum: rgba(82,44,85,255);
            --clr-lavander: rgba(162,126,198,255);
            --clr-lightGrey: #adadb7;
            --clr-blueGrey: #708090;
            --clr-yellow: rgba(254,213,0,255);
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            min-height: 100vh;
            color: #fff;
            display: flex;
            flex-direction: column;
        }
        
        /* Header Toolbar */
        #toolbar {
            background: #2a2a3e;
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #444;
            flex-wrap: wrap;
        }
        .toolbar-section {
            display: flex;
            gap: 8px;
            align-items: center;
            padding-right: 15px;
            border-right: 1px solid #444;
        }
        .toolbar-section:last-child {
            border-right: none;
        }
        .toolbar-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
        }
        .toolbar-btn {
            background: var(--clr-navyBlue);
            border: 1px solid #555;
            color: white;
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .toolbar-btn:hover {
            background: var(--clr-brightBlue);
        }
        .toolbar-btn.active {
            background: var(--clr-brightBlue);
            border-color: var(--clr-brightBlue);
        }
        .toolbar-btn.danger {
            background: var(--clr-brightRed);
        }
        .toolbar-btn.danger:hover {
            background: #c0392b;
        }
        .toolbar-input {
            background: #1a1a2e;
            border: 1px solid #555;
            color: white;
            padding: 5px 8px;
            font-size: 12px;
            border-radius: 4px;
            width: 80px;
        }
        .toolbar-input:focus {
            outline: none;
            border-color: var(--clr-brightBlue);
        }
        
        /* Main Content */
        #main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* Left Panel - LilyPond */
        #left-panel {
            width: 300px;
            background: #252538;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .panel-header {
            padding: 10px 15px;
            background: #2a2a3e;
            border-bottom: 1px solid #444;
            font-size: 13px;
            font-weight: bold;
            color: var(--clr-brightBlue);
        }
        .panel-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }
        #lilypond-code {
            width: 100%;
            height: 150px;
            background: #1a1a2e;
            border: 1px solid #444;
            color: #ddd;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            padding: 10px;
            resize: vertical;
            border-radius: 4px;
        }
        #lilypond-code:focus {
            outline: none;
            border-color: var(--clr-brightBlue);
        }
        .input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            align-items: center;
        }
        .input-row label {
            font-size: 11px;
            color: #888;
            min-width: 50px;
        }
        .input-row input {
            flex: 1;
            background: #1a1a2e;
            border: 1px solid #444;
            color: white;
            padding: 5px 8px;
            font-size: 12px;
            border-radius: 4px;
        }
        .input-row input:focus {
            outline: none;
            border-color: var(--clr-brightBlue);
        }
        .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .panel-btn {
            flex: 1;
            background: var(--clr-plum);
            border: none;
            color: white;
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        .panel-btn:hover {
            background: var(--clr-lavander);
        }
        .panel-btn.primary {
            background: var(--clr-brightBlue);
        }
        .panel-btn.primary:hover {
            background: #4a9eff;
        }
        #render-status {
            font-size: 10px;
            color: #888;
            margin-top: 8px;
        }
        
        /* Rendered SVGs List */
        #rendered-list {
            margin-top: 15px;
            border-top: 1px solid #444;
            padding-top: 15px;
        }
        .rendered-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: #1a1a2e;
            border-radius: 4px;
            margin-bottom: 6px;
            cursor: pointer;
            font-size: 11px;
        }
        .rendered-item:hover {
            background: #2a2a4e;
        }
        .rendered-item.selected {
            background: var(--clr-navyBlue);
        }
        .rendered-item-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .rendered-item-btn {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 14px;
        }
        .rendered-item-btn:hover {
            color: white;
        }
        
        /* Canvas Area */
        #canvas-container {
            flex: 1;
            background: #333;
            position: relative;
            overflow: auto;
        }
        #svg-canvas {
            background: white;
            display: block;
            margin: 20px auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        
        /* Right Panel - Properties */
        #right-panel {
            width: 250px;
            background: #252538;
            border-left: 1px solid #444;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .property-group {
            margin-bottom: 15px;
        }
        .property-group-title {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .property-row {
            display: flex;
            gap: 8px;
            margin-bottom: 6px;
            align-items: center;
        }
        .property-row label {
            font-size: 11px;
            color: #aaa;
            min-width: 40px;
        }
        .property-row input {
            flex: 1;
            background: #1a1a2e;
            border: 1px solid #444;
            color: white;
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 3px;
        }
        .property-row input:focus {
            outline: none;
            border-color: var(--clr-brightBlue);
        }
        
        /* Elements List */
        #elements-list {
            flex: 1;
            overflow-y: auto;
            border-top: 1px solid #444;
            padding: 10px;
        }
        .element-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 5px 8px;
            background: #1a1a2e;
            border-radius: 3px;
            margin-bottom: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .element-item:hover {
            background: #2a2a4e;
        }
        .element-item.selected {
            background: var(--clr-navyBlue);
            border: 1px solid var(--clr-brightBlue);
        }
        .element-item.group {
            border-left: 3px solid var(--clr-mustard);
        }
        .element-icon {
            font-size: 10px;
            color: #888;
        }
        .element-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Selection Box */
        .selection-box {
            fill: none;
            stroke: var(--clr-brightBlue);
            stroke-width: 1;
            stroke-dasharray: 4,2;
            pointer-events: none;
        }
        .selection-handle {
            fill: white;
            stroke: var(--clr-brightBlue);
            stroke-width: 1;
            cursor: nwse-resize;
        }
        .selection-handle.rotate {
            cursor: grab;
        }
        
        /* Hidden file inputs */
        .hidden-input {
            display: none;
        }
        
        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-overlay.show {
            display: flex;
        }
        .modal {
            background: #2a2a3e;
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
            max-width: 500px;
        }
        .modal-title {
            font-size: 16px;
            margin-bottom: 15px;
            color: var(--clr-brightBlue);
        }
        .modal-input {
            width: 100%;
            background: #1a1a2e;
            border: 1px solid #444;
            color: white;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        .modal-input:focus {
            outline: none;
            border-color: var(--clr-brightBlue);
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
    </style>
</head>
<body>
    <!-- Toolbar -->
    <div id="toolbar">
        <div class="toolbar-section">
            <span class="toolbar-label">File</span>
            <button class="toolbar-btn" id="btn-new">New</button>
            <button class="toolbar-btn" id="btn-save">Save</button>
            <button class="toolbar-btn" id="btn-load">Load</button>
            <button class="toolbar-btn" id="btn-export">Export SVG</button>
        </div>
        <div class="toolbar-section">
            <span class="toolbar-label">Import</span>
            <button class="toolbar-btn" id="btn-import-svg">Import SVG</button>
            <input type="file" id="import-svg-input" class="hidden-input" accept=".svg">
        </div>
        <div class="toolbar-section">
            <span class="toolbar-label">Edit</span>
            <button class="toolbar-btn" id="btn-group">Group</button>
            <button class="toolbar-btn" id="btn-ungroup">Ungroup</button>
            <button class="toolbar-btn danger" id="btn-delete">Delete</button>
        </div>
        <div class="toolbar-section">
            <span class="toolbar-label">Arrange</span>
            <button class="toolbar-btn" id="btn-bring-front">Front</button>
            <button class="toolbar-btn" id="btn-send-back">Back</button>
        </div>
        <div class="toolbar-section">
            <span class="toolbar-label">Canvas</span>
            <input type="number" class="toolbar-input" id="canvas-width" value="800" min="100">
            <span style="color:#888;">√ó</span>
            <input type="number" class="toolbar-input" id="canvas-height" value="600" min="100">
            <button class="toolbar-btn" id="btn-apply-canvas">Apply</button>
        </div>
        <div class="toolbar-section">
            <span class="toolbar-label">Zoom</span>
            <button class="toolbar-btn" id="btn-zoom-out">‚àí</button>
            <span id="zoom-level" style="min-width:40px;text-align:center;">100%</span>
            <button class="toolbar-btn" id="btn-zoom-in">+</button>
            <button class="toolbar-btn" id="btn-zoom-fit">Fit</button>
        </div>
    </div>
    
    <!-- Main Content -->
    <div id="main-content">
        <!-- Left Panel - LilyPond -->
        <div id="left-panel">
            <div class="panel-header">LilyPond Notation</div>
            <div class="panel-content">
                <div class="input-row">
                    <label>Name</label>
                    <input type="text" id="ly-name" value="notation">
                </div>
                <div class="input-row">
                    <label>Width</label>
                    <input type="number" id="ly-width" value="100" min="20" max="500">
                    <span style="font-size:10px;color:#888;">mm</span>
                </div>
                <textarea id="lilypond-code" placeholder="Enter LilyPond code...&#10;&#10;Examples:&#10;{ c'4 d' e' f' g'1 }&#10;&#10;\relative c' { c4 d e f | g2 g }"></textarea>
                <div class="btn-row">
                    <button class="panel-btn primary" id="btn-render-ly">Render</button>
                    <button class="panel-btn" id="btn-add-to-canvas">Add to Canvas</button>
                </div>
                <div id="render-status">Ready</div>
                
                <div id="rendered-list">
                    <div class="property-group-title">Rendered Notation</div>
                    <div id="rendered-items"></div>
                </div>
            </div>
        </div>
        
        <!-- Canvas Area -->
        <div id="canvas-container">
            <svg id="svg-canvas" width="800" height="600" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                        <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#eee" stroke-width="0.5"/>
                    </pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid)"/>
                <g id="canvas-content"></g>
                <g id="selection-overlay"></g>
            </svg>
        </div>
        
        <!-- Right Panel - Properties -->
        <div id="right-panel">
            <div class="panel-header">Properties</div>
            <div class="panel-content">
                <div class="property-group">
                    <div class="property-group-title">Transform</div>
                    <div class="property-row">
                        <label>X</label>
                        <input type="number" id="prop-x" value="0">
                    </div>
                    <div class="property-row">
                        <label>Y</label>
                        <input type="number" id="prop-y" value="0">
                    </div>
                    <div class="property-row">
                        <label>Scale</label>
                        <input type="number" id="prop-scale" value="1" step="0.1" min="0.1">
                    </div>
                    <div class="property-row">
                        <label>Rotate</label>
                        <input type="number" id="prop-rotate" value="0" step="1">
                    </div>
                </div>
                <div class="property-group">
                    <div class="property-group-title">Size (at scale)</div>
                    <div class="property-row">
                        <label>Width</label>
                        <span id="prop-width" style="color:#aaa;font-size:11px;">-</span>
                    </div>
                    <div class="property-row">
                        <label>Height</label>
                        <span id="prop-height" style="color:#aaa;font-size:11px;">-</span>
                    </div>
                </div>
                <div class="property-group">
                    <div class="property-group-title">Actions</div>
                    <div class="btn-row">
                        <button class="panel-btn" id="btn-save-selection">Save as SVG</button>
                    </div>
                    <div class="btn-row">
                        <button class="panel-btn" id="btn-duplicate">Duplicate</button>
                    </div>
                </div>
            </div>
            <div class="panel-header">Elements</div>
            <div id="elements-list"></div>
        </div>
    </div>
    
    <!-- Save Modal -->
    <div class="modal-overlay" id="save-modal">
        <div class="modal">
            <div class="modal-title">Save Composition</div>
            <input type="text" class="modal-input" id="save-filename" placeholder="filename">
            <div class="modal-buttons">
                <button class="toolbar-btn" id="btn-save-cancel">Cancel</button>
                <button class="toolbar-btn primary" id="btn-save-confirm">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Load Modal -->
    <div class="modal-overlay" id="load-modal">
        <div class="modal">
            <div class="modal-title">Load Composition</div>
            <select class="modal-input" id="load-select" size="8" style="height:auto;"></select>
            <div class="modal-buttons">
                <button class="toolbar-btn" id="btn-load-cancel">Cancel</button>
                <button class="toolbar-btn primary" id="btn-load-confirm">Load</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // SVG COMPOSER - Main Application
        // ============================================
        
        const canvas = document.getElementById('svg-canvas');
        const canvasContent = document.getElementById('canvas-content');
        const selectionOverlay = document.getElementById('selection-overlay');
        const elementsList = document.getElementById('elements-list');
        const renderedItems = document.getElementById('rendered-items');
        
        // State
        let elements = [];
        let selectedElements = [];
        let nextElementId = 1;
        let zoom = 1;
        let isDragging = false;
        let isResizing = false;
        let dragStart = { x: 0, y: 0 };
        let dragElementStart = { x: 0, y: 0 };
        let renderedNotations = [];
        let selectedRenderedNotation = null;
        
        // ============================================
        // ELEMENT MANAGEMENT
        // ============================================
        
        function createElement(svgContent, name, x = 50, y = 50, scale = 1) {
            const id = `elem-${nextElementId++}`;
            const element = {
                id,
                name: name || `Element ${nextElementId - 1}`,
                type: 'svg',
                x,
                y,
                scale,
                rotate: 0,
                svgContent,
                isGroup: false,
                children: []
            };
            elements.push(element);
            renderElements();
            selectElement(element);
            return element;
        }
        
        function createGroup(elementsToGroup) {
            if (elementsToGroup.length < 2) return null;
            
            const id = `group-${nextElementId++}`;
            
            // Calculate bounding box
            let minX = Infinity, minY = Infinity;
            elementsToGroup.forEach(el => {
                minX = Math.min(minX, el.x);
                minY = Math.min(minY, el.y);
            });
            
            // Create group with relative positions
            const group = {
                id,
                name: `Group ${nextElementId - 1}`,
                type: 'group',
                x: minX,
                y: minY,
                scale: 1,
                rotate: 0,
                isGroup: true,
                children: elementsToGroup.map(el => ({
                    ...el,
                    x: el.x - minX,
                    y: el.y - minY
                }))
            };
            
            // Remove grouped elements from main list
            elementsToGroup.forEach(el => {
                const idx = elements.indexOf(el);
                if (idx > -1) elements.splice(idx, 1);
            });
            
            elements.push(group);
            renderElements();
            selectElement(group);
            return group;
        }
        
        function ungroupElement(group) {
            if (!group.isGroup) return;
            
            const idx = elements.indexOf(group);
            if (idx === -1) return;
            
            // Restore children with absolute positions
            const restoredElements = group.children.map(child => ({
                ...child,
                id: `elem-${nextElementId++}`,
                x: group.x + child.x * group.scale,
                y: group.y + child.y * group.scale,
                scale: child.scale * group.scale
            }));
            
            elements.splice(idx, 1, ...restoredElements);
            selectedElements = restoredElements;
            renderElements();
            updateSelectionUI();
        }
        
        function deleteElements(elementsToDelete) {
            elementsToDelete.forEach(el => {
                const idx = elements.indexOf(el);
                if (idx > -1) elements.splice(idx, 1);
            });
            selectedElements = [];
            renderElements();
            updateSelectionUI();
        }
        
        function duplicateElement(element) {
            const newElement = JSON.parse(JSON.stringify(element));
            newElement.id = `elem-${nextElementId++}`;
            newElement.name = element.name + ' (copy)';
            newElement.x += 20;
            newElement.y += 20;
            elements.push(newElement);
            renderElements();
            selectElement(newElement);
        }
        
        // ============================================
        // RENDERING
        // ============================================
        
        function renderElements() {
            canvasContent.innerHTML = '';
            
            elements.forEach(element => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('data-id', element.id);
                g.setAttribute('transform', `translate(${element.x}, ${element.y}) scale(${element.scale}) rotate(${element.rotate})`);
                g.style.cursor = 'move';
                
                if (element.isGroup) {
                    element.children.forEach(child => {
                        const childG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        childG.setAttribute('transform', `translate(${child.x}, ${child.y}) scale(${child.scale}) rotate(${child.rotate || 0})`);
                        childG.innerHTML = child.svgContent || '';
                        g.appendChild(childG);
                    });
                } else {
                    g.innerHTML = element.svgContent || '';
                }
                
                // Add event listeners
                g.addEventListener('mousedown', (e) => handleElementMouseDown(e, element));
                
                canvasContent.appendChild(g);
            });
            
            updateElementsList();
            updateSelectionOverlay();
        }
        
        function updateElementsList() {
            elementsList.innerHTML = '';
            
            elements.forEach(element => {
                const div = document.createElement('div');
                div.className = 'element-item' + 
                    (selectedElements.includes(element) ? ' selected' : '') +
                    (element.isGroup ? ' group' : '');
                div.innerHTML = `
                    <span class="element-icon">${element.isGroup ? 'üìÅ' : 'üìÑ'}</span>
                    <span class="element-name">${element.name}</span>
                `;
                div.addEventListener('click', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        toggleElementSelection(element);
                    } else {
                        selectElement(element);
                    }
                });
                elementsList.appendChild(div);
            });
        }
        
        function updateSelectionOverlay() {
            selectionOverlay.innerHTML = '';
            
            if (selectedElements.length === 0) return;
            
            selectedElements.forEach(element => {
                const g = canvasContent.querySelector(`[data-id="${element.id}"]`);
                if (!g) return;
                
                const bbox = g.getBBox();
                const transform = g.getCTM();
                const canvasTransform = canvas.getCTM();
                
                // Create selection rectangle
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', element.x - 2);
                rect.setAttribute('y', element.y - 2);
                rect.setAttribute('width', bbox.width * element.scale + 4);
                rect.setAttribute('height', bbox.height * element.scale + 4);
                rect.setAttribute('class', 'selection-box');
                selectionOverlay.appendChild(rect);
                
                // Add resize handles for single selection
                if (selectedElements.length === 1) {
                    const handleSize = 8;
                    const corners = [
                        { x: element.x - 2, y: element.y - 2, cursor: 'nw-resize' },
                        { x: element.x + bbox.width * element.scale - 2, y: element.y - 2, cursor: 'ne-resize' },
                        { x: element.x - 2, y: element.y + bbox.height * element.scale - 2, cursor: 'sw-resize' },
                        { x: element.x + bbox.width * element.scale - 2, y: element.y + bbox.height * element.scale - 2, cursor: 'se-resize' }
                    ];
                    
                    corners.forEach((corner, idx) => {
                        const handle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        handle.setAttribute('x', corner.x - handleSize/2);
                        handle.setAttribute('y', corner.y - handleSize/2);
                        handle.setAttribute('width', handleSize);
                        handle.setAttribute('height', handleSize);
                        handle.setAttribute('class', 'selection-handle');
                        handle.style.cursor = corner.cursor;
                        handle.addEventListener('mousedown', (e) => handleResizeStart(e, element, idx));
                        selectionOverlay.appendChild(handle);
                    });
                }
            });
        }
        
        // ============================================
        // SELECTION
        // ============================================
        
        function selectElement(element) {
            selectedElements = [element];
            updateSelectionUI();
        }
        
        function toggleElementSelection(element) {
            const idx = selectedElements.indexOf(element);
            if (idx > -1) {
                selectedElements.splice(idx, 1);
            } else {
                selectedElements.push(element);
            }
            updateSelectionUI();
        }
        
        function clearSelection() {
            selectedElements = [];
            updateSelectionUI();
        }
        
        function updateSelectionUI() {
            updateElementsList();
            updateSelectionOverlay();
            updatePropertiesPanel();
        }
        
        function updatePropertiesPanel() {
            if (selectedElements.length === 1) {
                const el = selectedElements[0];
                document.getElementById('prop-x').value = Math.round(el.x);
                document.getElementById('prop-y').value = Math.round(el.y);
                document.getElementById('prop-scale').value = el.scale;
                document.getElementById('prop-rotate').value = el.rotate;
                
                // Calculate scaled dimensions from bounding box
                const g = canvasContent.querySelector(`[data-id="${el.id}"]`);
                if (g) {
                    const bbox = g.getBBox();
                    const scaledWidth = (bbox.width * el.scale).toFixed(1);
                    const scaledHeight = (bbox.height * el.scale).toFixed(1);
                    document.getElementById('prop-width').textContent = `${scaledWidth} px`;
                    document.getElementById('prop-height').textContent = `${scaledHeight} px`;
                } else {
                    document.getElementById('prop-width').textContent = '-';
                    document.getElementById('prop-height').textContent = '-';
                }
            } else {
                document.getElementById('prop-x').value = '';
                document.getElementById('prop-y').value = '';
                document.getElementById('prop-scale').value = '';
                document.getElementById('prop-rotate').value = '';
                document.getElementById('prop-width').textContent = '-';
                document.getElementById('prop-height').textContent = '-';
            }
        }
        
        // ============================================
        // MOUSE INTERACTIONS
        // ============================================
        
        function handleElementMouseDown(e, element) {
            e.stopPropagation();
            
            if (!selectedElements.includes(element)) {
                if (e.ctrlKey || e.metaKey) {
                    toggleElementSelection(element);
                } else {
                    selectElement(element);
                }
            }
            
            isDragging = true;
            dragStart = { x: e.clientX, y: e.clientY };
            dragElementStart = { x: element.x, y: element.y };
            
            // Store start positions for all selected elements
            selectedElements.forEach(el => {
                el._dragStartX = el.x;
                el._dragStartY = el.y;
            });
        }
        
        function handleResizeStart(e, element, cornerIdx) {
            e.stopPropagation();
            isResizing = true;
            dragStart = { x: e.clientX, y: e.clientY };
            element._startScale = element.scale;
        }
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.target === canvas || e.target.tagName === 'rect' && e.target.getAttribute('fill') === 'url(#grid)') {
                clearSelection();
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging && selectedElements.length > 0) {
                const dx = (e.clientX - dragStart.x) / zoom;
                const dy = (e.clientY - dragStart.y) / zoom;
                
                selectedElements.forEach(el => {
                    el.x = el._dragStartX + dx;
                    el.y = el._dragStartY + dy;
                });
                
                renderElements();
                updatePropertiesPanel();
            }
            
            if (isResizing && selectedElements.length === 1) {
                const el = selectedElements[0];
                const dx = e.clientX - dragStart.x;
                const scaleDelta = 1 + dx / 100;
                el.scale = Math.max(0.1, el._startScale * scaleDelta);
                renderElements();
                updatePropertiesPanel();
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
            isResizing = false;
        });
        
        // ============================================
        // PROPERTY INPUTS
        // ============================================
        
        ['prop-x', 'prop-y', 'prop-scale', 'prop-rotate'].forEach(id => {
            document.getElementById(id).addEventListener('change', (e) => {
                if (selectedElements.length !== 1) return;
                const el = selectedElements[0];
                const value = parseFloat(e.target.value);
                if (isNaN(value)) return;
                
                switch(id) {
                    case 'prop-x': el.x = value; break;
                    case 'prop-y': el.y = value; break;
                    case 'prop-scale': el.scale = Math.max(0.1, value); break;
                    case 'prop-rotate': el.rotate = value; break;
                }
                renderElements();
            });
        });
        
        // ============================================
        // TOOLBAR ACTIONS
        // ============================================
        
        document.getElementById('btn-group').addEventListener('click', () => {
            if (selectedElements.length >= 2) {
                createGroup([...selectedElements]);
            }
        });
        
        document.getElementById('btn-ungroup').addEventListener('click', () => {
            if (selectedElements.length === 1 && selectedElements[0].isGroup) {
                ungroupElement(selectedElements[0]);
            }
        });
        
        document.getElementById('btn-delete').addEventListener('click', () => {
            if (selectedElements.length > 0) {
                deleteElements([...selectedElements]);
            }
        });
        
        document.getElementById('btn-duplicate').addEventListener('click', () => {
            if (selectedElements.length === 1) {
                duplicateElement(selectedElements[0]);
            }
        });
        
        document.getElementById('btn-bring-front').addEventListener('click', () => {
            selectedElements.forEach(el => {
                const idx = elements.indexOf(el);
                if (idx > -1) {
                    elements.splice(idx, 1);
                    elements.push(el);
                }
            });
            renderElements();
        });
        
        document.getElementById('btn-send-back').addEventListener('click', () => {
            selectedElements.forEach(el => {
                const idx = elements.indexOf(el);
                if (idx > -1) {
                    elements.splice(idx, 1);
                    elements.unshift(el);
                }
            });
            renderElements();
        });
        
        // Canvas size
        document.getElementById('btn-apply-canvas').addEventListener('click', () => {
            const width = parseInt(document.getElementById('canvas-width').value) || 800;
            const height = parseInt(document.getElementById('canvas-height').value) || 600;
            canvas.setAttribute('width', width);
            canvas.setAttribute('height', height);
        });
        
        // Zoom
        document.getElementById('btn-zoom-in').addEventListener('click', () => {
            zoom = Math.min(3, zoom + 0.1);
            updateZoom();
        });
        
        document.getElementById('btn-zoom-out').addEventListener('click', () => {
            zoom = Math.max(0.25, zoom - 0.1);
            updateZoom();
        });
        
        document.getElementById('btn-zoom-fit').addEventListener('click', () => {
            zoom = 1;
            updateZoom();
        });
        
        function updateZoom() {
            canvas.style.transform = `scale(${zoom})`;
            canvas.style.transformOrigin = 'top left';
            document.getElementById('zoom-level').textContent = Math.round(zoom * 100) + '%';
        }
        
        // ============================================
        // LILYPOND INTEGRATION
        // ============================================
        
        document.getElementById('btn-render-ly').addEventListener('click', async () => {
            const code = document.getElementById('lilypond-code').value.trim();
            const name = document.getElementById('ly-name').value.trim() || 'notation';
            const lineWidth = parseInt(document.getElementById('ly-width').value) || 100;
            
            if (!code) {
                document.getElementById('render-status').textContent = 'Error: No code entered';
                return;
            }
            
            document.getElementById('render-status').textContent = 'Rendering...';
            
            try {
                const response = await fetch('/api/lilypond/render', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code, name, lineWidth })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    document.getElementById('render-status').textContent = 'Rendered: ' + result.filename;
                    
                    // Add to rendered list
                    renderedNotations.push({
                        filename: result.filename,
                        path: result.path,
                        svg: result.svg,
                        name
                    });
                    updateRenderedList();
                    
                    // Select the new notation
                    selectedRenderedNotation = renderedNotations[renderedNotations.length - 1];
                } else {
                    document.getElementById('render-status').textContent = 'Error: ' + result.error;
                }
            } catch (err) {
                document.getElementById('render-status').textContent = 'Error: ' + err.message;
            }
        });
        
        document.getElementById('btn-add-to-canvas').addEventListener('click', () => {
            if (!selectedRenderedNotation) {
                document.getElementById('render-status').textContent = 'Select a rendered notation first';
                return;
            }
            
            // Extract SVG content (remove outer svg tags)
            let svgContent = selectedRenderedNotation.svg;
            const match = svgContent.match(/<svg[^>]*>([\s\S]*)<\/svg>/i);
            if (match) {
                svgContent = match[1];
            }
            
            createElement(svgContent, selectedRenderedNotation.name);
            document.getElementById('render-status').textContent = 'Added to canvas';
        });
        
        function updateRenderedList() {
            renderedItems.innerHTML = '';
            renderedNotations.forEach((notation, idx) => {
                const div = document.createElement('div');
                div.className = 'rendered-item' + (notation === selectedRenderedNotation ? ' selected' : '');
                div.innerHTML = `
                    <span class="rendered-item-name">${notation.name}</span>
                    <button class="rendered-item-btn" data-action="add" title="Add to canvas">+</button>
                `;
                div.addEventListener('click', (e) => {
                    if (e.target.dataset.action === 'add') {
                        selectedRenderedNotation = notation;
                        document.getElementById('btn-add-to-canvas').click();
                    } else {
                        selectedRenderedNotation = notation;
                        updateRenderedList();
                    }
                });
                renderedItems.appendChild(div);
            });
        }
        
        // Load existing rendered notations
        async function loadRenderedNotations() {
            try {
                const response = await fetch('/api/lilypond/list');
                const files = await response.json();
                
                for (const file of files.slice(0, 20)) { // Limit to 20 most recent
                    try {
                        const svgResponse = await fetch(file.path);
                        const svg = await svgResponse.text();
                        renderedNotations.push({
                            filename: file.filename,
                            path: file.path,
                            svg,
                            name: file.filename.replace('.svg', '')
                        });
                    } catch (e) {
                        console.warn('Could not load', file.path);
                    }
                }
                updateRenderedList();
            } catch (err) {
                console.error('Could not load rendered notations:', err);
            }
        }
        
        // ============================================
        // IMPORT/EXPORT SVG
        // ============================================
        
        document.getElementById('btn-import-svg').addEventListener('click', () => {
            document.getElementById('import-svg-input').click();
        });
        
        document.getElementById('import-svg-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const text = await file.text();
            
            // Parse the SVG to get viewBox dimensions for proper scaling
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(text, 'image/svg+xml');
            const svgEl = svgDoc.querySelector('svg');
            
            let scale = 1;
            let viewBox = null;
            if (svgEl) {
                viewBox = svgEl.getAttribute('viewBox');
                // Get width in mm and convert to pixels (approx 3.78 px/mm)
                const widthAttr = svgEl.getAttribute('width');
                if (widthAttr && widthAttr.includes('mm')) {
                    const mmWidth = parseFloat(widthAttr);
                    scale = (mmWidth * 3.78) / 10; // Scale up for visibility
                }
            }
            
            // Extract content from SVG and wrap in a group with color set
            let svgContent = text;
            const match = text.match(/<svg[^>]*>([\s\S]*)<\/svg>/i);
            if (match) {
                svgContent = match[1];
            }
            
            // Replace currentColor with black for visibility
            svgContent = svgContent.replace(/currentColor/g, '#000000');
            
            // Wrap content to handle viewBox offset
            if (viewBox) {
                const vbParts = viewBox.split(/\s+/).map(parseFloat);
                if (vbParts.length === 4) {
                    svgContent = `<g transform="translate(${-vbParts[0]}, ${-vbParts[1]})">${svgContent}</g>`;
                }
            }
            
            createElement(svgContent, file.name.replace('.svg', ''), 50, 50, scale);
            e.target.value = '';
        });
        
        document.getElementById('btn-export').addEventListener('click', () => {
            const svgClone = canvas.cloneNode(true);
            // Remove grid and selection overlay
            const grid = svgClone.querySelector('rect[fill="url(#grid)"]');
            if (grid) grid.remove();
            const overlay = svgClone.querySelector('#selection-overlay');
            if (overlay) overlay.innerHTML = '';
            
            const svgData = new XMLSerializer().serializeToString(svgClone);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'composition.svg';
            a.click();
            URL.revokeObjectURL(url);
        });
        
        document.getElementById('btn-save-selection').addEventListener('click', () => {
            if (selectedElements.length === 0) return;
            
            // Create SVG from selection
            const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            tempSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            
            // Calculate bounding box
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            selectedElements.forEach(el => {
                const g = canvasContent.querySelector(`[data-id="${el.id}"]`);
                if (g) {
                    const bbox = g.getBBox();
                    minX = Math.min(minX, el.x);
                    minY = Math.min(minY, el.y);
                    maxX = Math.max(maxX, el.x + bbox.width * el.scale);
                    maxY = Math.max(maxY, el.y + bbox.height * el.scale);
                    
                    const clone = g.cloneNode(true);
                    clone.removeAttribute('data-id');
                    tempSvg.appendChild(clone);
                }
            });
            
            // Adjust viewBox
            tempSvg.setAttribute('width', maxX - minX);
            tempSvg.setAttribute('height', maxY - minY);
            tempSvg.setAttribute('viewBox', `${minX} ${minY} ${maxX - minX} ${maxY - minY}`);
            
            const svgData = new XMLSerializer().serializeToString(tempSvg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = (selectedElements.length === 1 ? selectedElements[0].name : 'selection') + '.svg';
            a.click();
            URL.revokeObjectURL(url);
        });
        
        // ============================================
        // SAVE/LOAD COMPOSITIONS
        // ============================================
        
        document.getElementById('btn-new').addEventListener('click', () => {
            if (confirm('Create new composition? Unsaved changes will be lost.')) {
                elements = [];
                selectedElements = [];
                nextElementId = 1;
                renderElements();
            }
        });
        
        document.getElementById('btn-save').addEventListener('click', () => {
            document.getElementById('save-modal').classList.add('show');
            document.getElementById('save-filename').focus();
        });
        
        document.getElementById('btn-save-cancel').addEventListener('click', () => {
            document.getElementById('save-modal').classList.remove('show');
        });
        
        document.getElementById('btn-save-confirm').addEventListener('click', async () => {
            const filename = document.getElementById('save-filename').value.trim();
            if (!filename) return;
            
            const data = {
                version: '1.0',
                canvasWidth: parseInt(canvas.getAttribute('width')),
                canvasHeight: parseInt(canvas.getAttribute('height')),
                elements,
                nextElementId
            };
            
            try {
                const response = await fetch('/api/svg-composer/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: filename, data })
                });
                
                const result = await response.json();
                if (result.success) {
                    document.getElementById('save-modal').classList.remove('show');
                    alert('Saved successfully!');
                } else {
                    alert('Save failed: ' + result.error);
                }
            } catch (err) {
                alert('Save failed: ' + err.message);
            }
        });
        
        document.getElementById('btn-load').addEventListener('click', async () => {
            try {
                const response = await fetch('/api/svg-composer/list');
                const files = await response.json();
                
                const select = document.getElementById('load-select');
                select.innerHTML = '';
                files.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.name;
                    option.textContent = file.name;
                    select.appendChild(option);
                });
                
                document.getElementById('load-modal').classList.add('show');
            } catch (err) {
                alert('Could not load file list: ' + err.message);
            }
        });
        
        document.getElementById('btn-load-cancel').addEventListener('click', () => {
            document.getElementById('load-modal').classList.remove('show');
        });
        
        document.getElementById('btn-load-confirm').addEventListener('click', async () => {
            const filename = document.getElementById('load-select').value;
            if (!filename) return;
            
            try {
                const response = await fetch(`/api/svg-composer/load/${filename}`);
                const result = await response.json();
                
                if (result.success) {
                    const data = result.data;
                    elements = data.elements || [];
                    nextElementId = data.nextElementId || 1;
                    
                    if (data.canvasWidth) {
                        canvas.setAttribute('width', data.canvasWidth);
                        document.getElementById('canvas-width').value = data.canvasWidth;
                    }
                    if (data.canvasHeight) {
                        canvas.setAttribute('height', data.canvasHeight);
                        document.getElementById('canvas-height').value = data.canvasHeight;
                    }
                    
                    selectedElements = [];
                    renderElements();
                    document.getElementById('load-modal').classList.remove('show');
                } else {
                    alert('Load failed: ' + result.error);
                }
            } catch (err) {
                alert('Load failed: ' + err.message);
            }
        });
        
        // ============================================
        // KEYBOARD SHORTCUTS
        // ============================================
        
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedElements.length > 0) {
                    deleteElements([...selectedElements]);
                }
            }
            
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'g') {
                    e.preventDefault();
                    document.getElementById('btn-group').click();
                }
                if (e.key === 'G') {
                    e.preventDefault();
                    document.getElementById('btn-ungroup').click();
                }
                if (e.key === 'd') {
                    e.preventDefault();
                    if (selectedElements.length === 1) {
                        duplicateElement(selectedElements[0]);
                    }
                }
                if (e.key === 's') {
                    e.preventDefault();
                    document.getElementById('btn-save').click();
                }
            }
        });
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        loadRenderedNotations();
    </script>
</body>
</html>
