<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Quartet No.1 Composer</title>
    <style>
        :root {
            --clr-brightOrange: rgba(240,75,0,255);
            --clr-brightOrange2: #ea4607;
            --clr-brightBlue: rgba(56,126,211,255);
            --clr-mustard: rgba(244,182,0,255);
            --clr-brightRed: rgba(229,42,25,255);
            --clr-brightRed2: #dc3f3d;
            --clr-darkRed2: #9a0504;
            --clr-darkRed: #a60701;
            --clr-green: rgba(0,147,92,255);
            --clr-limeGreen: rgb(153,255,0);
            --clr-brightGreen: #31d196;
            --clr-navyBlue: rgba(28,72,121,255);
            --clr-plum: rgba(82,44,85,255);
            --clr-lavander: rgba(162,126,198,255);
            --clr-lightGrey: #adadb7;
            --clr-blueGrey: #708090;
            --clr-lightGreen: #85b068;
            --clr-yellow: rgba(254,213,0,255);
            --clr-neonMagenta: rgb(255, 21, 160);
            
            /* Cursor Colors */
            --cursor-staff1-color: var(--clr-limeGreen);
            --cursor-staff2-color: var(--clr-neonMagenta);
            --cursor-staff3-color: var(--clr-brightBlue);
            --cursor-staff4-color: var(--clr-brightOrange);
            
            /* Staff Dimensions - staves start below timeline area and divide remaining space into 4 equal parts */
            /* Timeline area: ~16px for seconds ticks/labels + beat ticks/labels */
            --timeline-height: 16px;
            
            /* ScoreTop Staff Y positions - start after timeline */
            --scoreTop-staff1-y: 0%;
            --scoreTop-staff2-y: 25%;
            --scoreTop-staff3-y: 50%;
            --scoreTop-staff4-y: 75%;
            
            /* ScoreBottom Staff Y positions - start after timeline */
            --scoreBottom-staff1-y: 0%;
            --scoreBottom-staff2-y: 25%;
            --scoreBottom-staff3-y: 50%;
            --scoreBottom-staff4-y: 75%;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: black;
            min-height: 100vh;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px;
        }
        #ScoreContainer {
            background: var(--clr-blueGrey);
            width: 100%;
            height: 100%;
            max-width: calc((100vh - 10px) * 4 / 3);
            max-height: calc((100vw - 10px) * 3 / 4);
            aspect-ratio: 4 / 3;
            display: flex;
            flex-direction: column;
        }
        #ScoreTop {
            background: white;
            width: 100%;
            flex: 1;
            margin-top: 5px;
            margin-bottom: 5px;
            border: none;
            position: relative;
        }
        #ScoreBottom {
            background: white;
            width: 100%;
            flex: 1;
            margin-top: 5px;
            margin-bottom: 5px;
            border: none;
            position: relative;
        }
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #00d4ff, #7b2ff7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
        }
        p {
            color: #a0a0a0;
            font-size: 1.1rem;
        }
        
        /* Control Menu Styles */
        #controlMenu {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            width: 250px;
            background: rgba(30, 30, 40, 0.95);
            transform: translateX(-245px);
            transition: transform 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: row;
        }
        #controlMenu.open {
            transform: translateX(0);
        }
        #menuContent {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }
        #menuToggle {
            width: 25px;
            background: var(--clr-navyBlue);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 12px;
            color: white;
            user-select: none;
        }
        #menuToggle:hover {
            background: var(--clr-brightBlue);
        }
        .menu-section {
            margin-bottom: 20px;
        }
        .menu-section h3 {
            color: var(--clr-brightBlue);
            font-size: 14px;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--clr-blueGrey);
            padding-bottom: 5px;
        }
        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .control-row label {
            font-size: 12px;
            color: var(--clr-lightGrey);
            width: 80px;
            flex-shrink: 0;
        }
        .control-row input[type="range"] {
            flex: 1;
            margin-right: 10px;
            accent-color: var(--clr-brightBlue);
        }
        .control-row input[type="number"] {
            width: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--clr-blueGrey);
            color: white;
            padding: 3px 5px;
            font-size: 12px;
            border-radius: 3px;
        }
        .control-row input[type="number"]:focus {
            outline: none;
            border-color: var(--clr-brightBlue);
        }
        .frame-rate-display {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--clr-blueGrey);
            color: var(--clr-brightGreen);
            padding: 3px 8px;
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', monospace;
            border-radius: 3px;
            min-width: 60px;
            text-align: center;
        }
        
        /* Playback-MIDI Menu (Right Side) */
        #cursorMenu {
            position: fixed;
            right: 0;
            top: 0;
            height: 100vh;
            width: 280px;
            background: rgba(30, 30, 40, 0.95);
            transform: translateX(255px);
            transition: transform 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: row;
        }
        #cursorMenu.open {
            transform: translateX(0);
        }
        #cursorMenuToggle {
            width: 25px;
            background: var(--clr-navyBlue);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 11px;
            color: white;
            user-select: none;
        }
        #cursorMenuToggle:hover {
            background: var(--clr-brightBlue);
        }
        #cursorMenuContent {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }
        
        /* Track Radio Buttons (T1-T4) */
        .track-radio-group {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            gap: 4px;
        }
        .track-radio-group input[type="radio"] {
            display: none;
        }
        .track-radio-group label {
            flex: 1;
            text-align: center;
            padding: 6px 4px;
            background: rgba(40, 40, 50, 0.6);
            border: 1px solid #555;
            border-radius: 3px;
            color: #aaa;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .track-radio-group label:hover {
            background: rgba(60, 60, 80, 0.6);
            border-color: #777;
        }
        .track-radio-group input[type="radio"]:checked + label {
            background: var(--clr-brightBlue);
            border-color: var(--clr-brightBlue);
            color: #fff;
        }
        
        /* MIDI Select Dropdowns */
        .midi-select {
            flex: 1;
            background: #2a2a3a;
            border: 1px solid var(--clr-blueGrey);
            color: white;
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 3px;
            max-width: 140px;
        }
        .midi-select:focus {
            outline: none;
            border-color: var(--clr-brightBlue);
        }
        
        /* MIDI Filename Display */
        .midi-filename {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--clr-blueGrey);
            color: var(--clr-lightGrey);
            padding: 4px 8px;
            font-size: 10px;
            border-radius: 3px;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Small Timecode Display */
        .timecode-display-small {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--clr-blueGrey);
            color: var(--clr-brightGreen);
            padding: 4px 8px;
            font-size: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            border-radius: 3px;
            min-width: 70px;
            text-align: center;
        }
        
        /* Track Enable Toggles */
        .track-enable-group {
            margin-top: 10px;
        }
        .track-enable-label {
            font-size: 11px;
            color: var(--clr-lightGrey);
            display: block;
            margin-bottom: 6px;
        }
        .track-toggles {
            display: flex;
            gap: 4px;
        }
        .track-toggles input[type="checkbox"] {
            display: none;
        }
        .track-toggles label {
            flex: 1;
            text-align: center;
            padding: 6px 4px;
            background: rgba(40, 40, 50, 0.6);
            border: 1px solid #555;
            border-radius: 3px;
            color: #666;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .track-toggles label:hover {
            background: rgba(60, 60, 80, 0.6);
            border-color: #777;
        }
        .track-toggles input[type="checkbox"]:checked + label {
            background: var(--clr-brightGreen);
            border-color: var(--clr-brightGreen);
            color: #000;
        }
        
        /* Display Toggles */
        .display-toggles {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .display-toggles input[type="checkbox"] {
            display: none;
        }
        .display-toggles label {
            display: block;
            padding: 6px 10px;
            background: rgba(40, 40, 50, 0.6);
            border: 1px solid #555;
            border-radius: 3px;
            color: #666;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .display-toggles label:hover {
            background: rgba(60, 60, 80, 0.6);
            border-color: #777;
        }
        .display-toggles input[type="checkbox"]:checked + label {
            background: var(--clr-brightBlue);
            border-color: var(--clr-brightBlue);
            color: #fff;
        }
        .control-btn {
            width: 100%;
            padding: 8px 12px;
            background: var(--clr-navyBlue);
            border: 1px solid var(--clr-blueGrey);
            color: white;
            font-size: 12px;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .control-btn:hover {
            background: var(--clr-brightBlue);
        }
        .control-btn.active {
            background: var(--clr-brightRed);
        }
        
        /* Transport Controls */
        .transport-controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .transport-btn {
            width: 32px !important;
            height: 32px;
            padding: 0 !important;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .timecode-display {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--clr-blueGrey);
            color: var(--clr-brightGreen);
            padding: 6px 12px;
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', monospace;
            border-radius: 3px;
            min-width: 120px;
            text-align: center;
        }
        .file-input-hidden {
            display: none;
        }
        
        /* Composition Panel (Left Side) */
        #compositionPanel {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            width: 280px;
            background: rgba(30, 30, 40, 0.95);
            transform: translateX(-255px);
            transition: transform 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: row;
        }
        #compositionPanel.open {
            transform: translateX(0);
        }
        #compositionPanelToggle {
            width: 25px;
            background: var(--clr-plum);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 12px;
            color: white;
            user-select: none;
        }
        #compositionPanelToggle:hover {
            background: var(--clr-lavander);
        }
        #compositionPanelContent {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }
        .edit-cursor-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--clr-yellow);
            color: var(--clr-yellow);
            padding: 8px 12px;
            font-size: 16px;
            font-family: 'Consolas', 'Monaco', monospace;
            border-radius: 4px;
            text-align: center;
        }
        .edit-cursor-input:focus {
            outline: none;
            border-color: var(--clr-limeGreen);
        }
        
        /* G Track Radio Buttons */
        .gtrack-radio-group {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            gap: 4px;
            margin-top: 10px;
        }
        .gtrack-radio-group input[type="radio"] {
            display: none;
        }
        .gtrack-radio-group label {
            flex: 1;
            text-align: center;
            padding: 6px 4px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            border-radius: 4px;
            color: #aaa;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .gtrack-radio-group label:hover {
            background: rgba(60, 60, 80, 0.6);
            border-color: #777;
        }
        .gtrack-radio-group input[type="radio"]:checked + label {
            background: var(--clr-yellow);
            border-color: var(--clr-yellow);
            color: #000;
        }
        
        /* Curve Maker Styles */
        .curve-input-row {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            align-items: center;
        }
        .curve-input-row label {
            font-size: 10px;
            color: #aaa;
            min-width: 35px;
        }
        .curve-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #555;
            color: #fff;
            padding: 4px 6px;
            font-size: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            border-radius: 3px;
            text-align: center;
            width: 60px;
        }
        .curve-input:focus {
            outline: none;
            border-color: var(--clr-yellow);
        }
        .curve-draw-btn {
            background: var(--clr-plum);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            margin-top: 8px;
            width: 100%;
        }
        .curve-draw-btn:hover {
            background: var(--clr-lavander);
        }
        .curve-fill-toggle {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }
        .curve-fill-toggle input[type="radio"] {
            display: none;
        }
        .curve-fill-toggle label {
            flex: 1;
            text-align: center;
            padding: 4px 2px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            border-radius: 3px;
            color: #aaa;
            font-size: 9px;
            cursor: pointer;
        }
        .curve-fill-toggle input[type="radio"]:checked + label {
            background: var(--clr-lavander);
            border-color: var(--clr-lavander);
            color: #000;
        }
        .color-swatches {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
        }
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid transparent;
            cursor: pointer;
        }
        .color-swatch:hover {
            border-color: #fff;
        }
        .color-swatch.selected {
            border-color: #fff;
            box-shadow: 0 0 4px rgba(255,255,255,0.5);
        }
        .section-divider {
            border-top: 1px solid #444;
            margin: 12px 0 8px 0;
            padding-top: 8px;
        }
        .section-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }
        
        /* Curve Selection Bounding Box */
        .curve-bounding-box {
            fill-opacity: 0.1;
            stroke-width: 2;
            stroke-dasharray: 6,3;
            cursor: pointer;
        }
        
        /* Edit Cursor Styles */
        .edit-cursor-line {
            stroke: rgba(254, 254, 0, 0.8);
            stroke-width: 5;
            cursor: ew-resize;
        }
        .edit-cursor-handle {
            fill: rgba(254, 254, 0, 0.8);
            cursor: ew-resize;
        }
        
        /* SVG Element Manager Styles */
        .svg-element-wrapper {
            cursor: move;
        }
        .svg-element-wrapper.selected {
            outline: 2px dashed var(--clr-brightBlue);
            outline-offset: 2px;
        }
        .svg-resize-handle {
            fill: var(--clr-brightBlue);
            stroke: white;
            stroke-width: 1;
            cursor: nwse-resize;
        }
        .svg-resize-handle.corner-nw { cursor: nwse-resize; }
        .svg-resize-handle.corner-ne { cursor: nesw-resize; }
        .svg-resize-handle.corner-sw { cursor: nesw-resize; }
        .svg-resize-handle.corner-se { cursor: nwse-resize; }
        .svg-element-list {
            max-height: 100px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border: 1px solid #444;
            border-radius: 3px;
            margin-top: 5px;
        }
        .svg-element-item {
            padding: 4px 8px;
            font-size: 10px;
            color: #aaa;
            cursor: pointer;
            border-bottom: 1px solid #333;
        }
        .svg-element-item:hover {
            background: rgba(60,60,80,0.6);
        }
        .svg-element-item.selected {
            background: var(--clr-brightBlue);
            color: white;
        }
        
        /* Flowchart Connector Styles */
        .flowchart-connector {
            pointer-events: stroke;
        }
        .flowchart-connector-path {
            fill: none;
            stroke-width: 2;
            pointer-events: stroke;
            cursor: pointer;
        }
        .flowchart-connector.selected .flowchart-connector-path {
            stroke-width: 3;
            filter: drop-shadow(0 0 3px yellow);
        }
        .flowchart-connector-hitarea {
            fill: none;
            stroke: transparent;
            stroke-width: 12;
            pointer-events: stroke;
            cursor: pointer;
        }
        .flowchart-node {
            fill: var(--clr-brightBlue);
            stroke: white;
            stroke-width: 2;
            cursor: crosshair;
        }
        .flowchart-node:hover {
            fill: var(--clr-neonYellow);
        }
        .connector-list {
            max-height: 80px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border: 1px solid #444;
            border-radius: 3px;
            margin-top: 5px;
        }
        .connector-item {
            padding: 4px 8px;
            font-size: 10px;
            color: #aaa;
            cursor: pointer;
            border-bottom: 1px solid #333;
        }
        .connector-item:hover {
            background: rgba(60,60,80,0.6);
        }
        .connector-item.selected {
            background: var(--clr-plum);
            color: white;
        }
    </style>
</head>
<body>
    <!-- Composition Panel (Left) -->
    <div id="compositionPanel">
        <div id="compositionPanelContent">
            <div class="menu-section">
                <div class="control-row">
                    <input type="text" id="editCursorSecondsInput" class="edit-cursor-input" value="0.000">
                </div>
                <div class="gtrack-radio-group">
                    <input type="radio" id="gtrackG1" name="gtrack" value="1">
                    <label for="gtrackG1">G1</label>
                    <input type="radio" id="gtrackG2" name="gtrack" value="2">
                    <label for="gtrackG2">G2</label>
                    <input type="radio" id="gtrackG3" name="gtrack" value="3">
                    <label for="gtrackG3">G3</label>
                    <input type="radio" id="gtrackG4" name="gtrack" value="4">
                    <label for="gtrackG4">G4</label>
                    <input type="radio" id="gtrackGA" name="gtrack" value="A" checked>
                    <label for="gtrackGA">GA</label>
                </div>
                
                <div class="section-divider"></div>
                <div class="section-label">Curve Maker</div>
                
                <div class="curve-input-row">
                    <label>Name</label>
                    <input type="text" id="curveNameDisplay" class="curve-input" value="" readonly style="background: rgba(40,40,50,0.8); color: #aaa;">
                </div>
                <div class="curve-input-row">
                    <label>Start</label>
                    <input type="text" id="curveStartInput" class="curve-input" value="0.000">
                </div>
                <div class="curve-input-row">
                    <label>End</label>
                    <input type="text" id="curveEndInput" class="curve-input" value="1.000">
                </div>
                <div class="curve-input-row">
                    <label>Y1</label>
                    <input type="text" id="curveY1Input" class="curve-input" value="0.0">
                </div>
                <div class="curve-input-row">
                    <label>Y2</label>
                    <input type="text" id="curveY2Input" class="curve-input" value="10.0">
                </div>
                
                <button id="curveDrawBtn" class="curve-draw-btn">Draw</button>
                
                <div class="curve-fill-toggle">
                    <input type="radio" id="curveFillLine" name="curveFill" value="line" checked>
                    <label for="curveFillLine">Line</label>
                    <input type="radio" id="curveFillBottom" name="curveFill" value="bottom">
                    <label for="curveFillBottom">Fill ↓</label>
                    <input type="radio" id="curveFillTop" name="curveFill" value="top">
                    <label for="curveFillTop">Fill ↑</label>
                </div>
                
                <div class="section-label" style="margin-top: 10px;">Color</div>
                <div class="color-swatches" id="colorSwatches">
                    <div class="color-swatch selected" data-color="brightOrange" style="background: var(--clr-brightOrange);"></div>
                    <div class="color-swatch" data-color="brightBlue" style="background: var(--clr-brightBlue);"></div>
                    <div class="color-swatch" data-color="mustard" style="background: var(--clr-mustard);"></div>
                    <div class="color-swatch" data-color="brightRed" style="background: var(--clr-brightRed);"></div>
                    <div class="color-swatch" data-color="green" style="background: var(--clr-green);"></div>
                    <div class="color-swatch" data-color="limeGreen" style="background: var(--clr-limeGreen);"></div>
                    <div class="color-swatch" data-color="brightGreen" style="background: var(--clr-brightGreen);"></div>
                    <div class="color-swatch" data-color="navyBlue" style="background: var(--clr-navyBlue);"></div>
                    <div class="color-swatch" data-color="plum" style="background: var(--clr-plum);"></div>
                    <div class="color-swatch" data-color="lavander" style="background: var(--clr-lavander);"></div>
                    <div class="color-swatch" data-color="yellow" style="background: var(--clr-yellow);"></div>
                    <div class="color-swatch" data-color="neonMagenta" style="background: var(--clr-neonMagenta);"></div>
                </div>
                
                <div class="section-divider"></div>
                <div class="section-label">SVG Elements</div>
                
                <div class="control-row">
                    <button id="svgInsertBtn" class="control-btn" style="font-size: 10px;">Insert SVG</button>
                    <input type="file" id="svgFileInput" class="file-input-hidden" accept=".svg">
                </div>
                <div class="svg-element-list" id="svgElementList">
                    <!-- SVG elements will be listed here -->
                </div>
                <div class="curve-input-row">
                    <label>X</label>
                    <input type="number" id="svgPosX" class="curve-input" value="0" step="1">
                    <label>Y</label>
                    <input type="number" id="svgPosY" class="curve-input" value="0" step="1">
                </div>
                <div class="curve-input-row">
                    <label>Scale</label>
                    <input type="range" id="svgScaleSlider" min="0.1" max="5" step="0.05" value="1" style="width: 80px;">
                    <span id="svgScaleValue" style="font-size: 10px;">1.00</span>
                </div>
                <div class="curve-input-row">
                    <label>Track</label>
                    <select id="svgTrackSelect" style="font-size: 10px; padding: 2px;">
                        <option value="1">Track 1</option>
                        <option value="2">Track 2</option>
                        <option value="3">Track 3</option>
                        <option value="4">Track 4</option>
                    </select>
                </div>
                <div class="control-row" style="margin-top: 5px;">
                    <button id="svgDeleteBtn" class="control-btn" style="font-size: 10px; background: var(--clr-darkRed);">Delete</button>
                </div>
                
                <div class="section-divider"></div>
                <div class="section-label">Notation (LilyPond)</div>
                
                <div class="curve-input-row">
                    <label>Name</label>
                    <input type="text" id="notationNameInput" class="curve-input" value="snippet" style="width: 80px;">
                </div>
                <div class="curve-input-row">
                    <label>Width</label>
                    <input type="number" id="notationWidthInput" class="curve-input" value="100" min="20" max="500" style="width: 50px;">
                    <span style="font-size: 10px; color: #888;">mm</span>
                </div>
                <textarea id="lilypondCodeInput" placeholder="Enter LilyPond code...&#10;e.g.: { c'4 d' e' f' }" style="width: 100%; height: 60px; font-family: monospace; font-size: 10px; background: rgba(30,30,40,0.9); color: #ddd; border: 1px solid #444; resize: vertical;"></textarea>
                <div class="control-row" style="margin-top: 5px;">
                    <button id="notationRenderBtn" class="control-btn" style="font-size: 10px;">Render SVG</button>
                    <button id="notationPlaceBtn" class="control-btn" style="font-size: 10px;">Place</button>
                </div>
                <div class="control-row">
                    <select id="notationListSelect" style="font-size: 10px; width: 100%; padding: 2px;">
                        <option value="">-- Rendered Notation --</option>
                    </select>
                </div>
                <div class="control-row">
                    <label style="font-size: 10px;">Scale:</label>
                    <input type="range" id="notationScaleSlider" min="0.2" max="3" step="0.1" value="1" style="width: 80px;">
                    <span id="notationScaleValue" style="font-size: 10px;">1.0</span>
                </div>
                <div id="notationStatus" style="font-size: 9px; color: #888; margin-top: 3px;">Ready</div>
            </div>
            
            <div class="menu-section">
                <div class="section-label">Connectors</div>
                <div class="control-row">
                    <button id="connectorModeBtn" class="control-btn" style="font-size: 10px;">Connect Mode: OFF</button>
                </div>
                <div class="connector-list" id="connectorList"></div>
                <div class="curve-input-row">
                    <label>Arrows</label>
                    <select id="connectorArrowSelect" style="font-size: 10px; padding: 2px;">
                        <option value="end">End →</option>
                        <option value="start">← Start</option>
                        <option value="both">← Both →</option>
                        <option value="none">None</option>
                    </select>
                </div>
                <div class="curve-input-row">
                    <label>Arrow Style</label>
                    <select id="connectorArrowStyleSelect" style="font-size: 10px; padding: 2px;">
                        <option value="triangle">Triangle</option>
                        <option value="stealth">Stealth</option>
                        <option value="diamond">Diamond</option>
                        <option value="circle">Circle</option>
                    </select>
                </div>
                <div class="curve-input-row">
                    <label>Arrow Size</label>
                    <input type="range" id="connectorArrowSizeSlider" min="3" max="12" value="6" style="width: 60px;">
                    <span id="connectorArrowSizeValue" style="font-size: 10px;">6</span>
                </div>
                <div class="curve-input-row">
                    <label>Line Color</label>
                    <select id="connectorLineColorSelect" style="font-size: 10px; padding: 2px;">
                        <option value="black">Black</option>
                        <option value="lightGrey">Grey</option>
                        <option value="white">White</option>
                        <option value="limeGreen">Lime</option>
                        <option value="neonMagenta">Magenta</option>
                        <option value="brightBlue">Blue</option>
                        <option value="brightOrange">Orange</option>
                        <option value="neonYellow">Yellow</option>
                    </select>
                </div>
                <div class="curve-input-row">
                    <label>Arrow Color</label>
                    <select id="connectorArrowColorSelect" style="font-size: 10px; padding: 2px;">
                        <option value="black">Black</option>
                        <option value="lightGrey">Grey</option>
                        <option value="white">White</option>
                        <option value="limeGreen">Lime</option>
                        <option value="neonMagenta">Magenta</option>
                        <option value="brightBlue">Blue</option>
                        <option value="brightOrange">Orange</option>
                        <option value="neonYellow">Yellow</option>
                    </select>
                </div>
                <div class="curve-input-row">
                    <label>Routing</label>
                    <select id="connectorRoutingSelect" style="font-size: 10px; padding: 2px;">
                        <option value="auto">Auto</option>
                        <option value="horizontal-first">Horizontal First</option>
                        <option value="vertical-first">Vertical First</option>
                        <option value="direct">Direct (diagonal)</option>
                    </select>
                </div>
                <div class="control-row" style="margin-top: 5px;">
                    <button id="connectorDeleteBtn" class="control-btn" style="font-size: 10px; background: var(--clr-darkRed);">Delete</button>
                </div>
            </div>
        </div>
        <div id="compositionPanelToggle">◀ Composition</div>
    </div>
    
    <!-- Playback-MIDI Menu (Right) -->
    <div id="cursorMenu">
        <div id="cursorMenuToggle">Playback-MIDI ▶</div>
        <div id="cursorMenuContent">
            <div class="menu-section">
                <h3>Playback</h3>
                <div class="control-row">
                    <span id="midiTimecode" class="timecode-display">00:00:00.000</span>
                </div>
                <div class="track-enable-group">
                    <label class="track-enable-label">Enable Tracks:</label>
                    <div class="track-toggles">
                        <input type="checkbox" id="midiEnableT1" checked>
                        <label for="midiEnableT1">T1</label>
                        <input type="checkbox" id="midiEnableT2" checked>
                        <label for="midiEnableT2">T2</label>
                        <input type="checkbox" id="midiEnableT3" checked>
                        <label for="midiEnableT3">T3</label>
                        <input type="checkbox" id="midiEnableT4" checked>
                        <label for="midiEnableT4">T4</label>
                    </div>
                </div>
                <div class="control-row">
                    <span id="midiEventCount" style="font-size: 11px; color: var(--clr-lightGrey);">Events: 0</span>
                </div>
                <div class="control-row" style="margin-top: 10px;">
                    <button id="goStopBtn" class="control-btn" onclick="if(window.CursorControls) CursorControls.toggleGoStop();">Go</button>
                </div>
            </div>
            <div class="menu-section">
                <h3>Jump To</h3>
                <div class="control-row">
                    <label>Second</label>
                    <input type="number" id="gotoSecondInput" step="0.01" value="0">
                </div>
                <div class="control-row">
                    <button id="gotoBtn" class="control-btn">Go</button>
                </div>
            </div>
            <div class="menu-section">
                <h3>Lead-In</h3>
                <div class="control-row">
                    <label>Seconds</label>
                    <input type="number" id="leadInSecondsInput" min="0" step="0.5" value="2">
                </div>
            </div>
            
            <div class="menu-section">
                <h3>MIDI Devices</h3>
                <div class="control-row">
                    <label>Input</label>
                    <select id="midiInputSelect" class="midi-select">
                        <option value="">-- Select Input --</option>
                    </select>
                </div>
                <div class="control-row">
                    <label>Output</label>
                    <select id="midiOutputSelect" class="midi-select">
                        <option value="">-- Select Output --</option>
                    </select>
                </div>
                <div class="control-row">
                    <button id="midiRefreshBtn" class="control-btn">Refresh Devices</button>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>MIDI File</h3>
                <div class="track-radio-group">
                    <input type="radio" id="midiTrackT1" name="midiTrack" value="1" checked>
                    <label for="midiTrackT1">T1</label>
                    <input type="radio" id="midiTrackT2" name="midiTrack" value="2">
                    <label for="midiTrackT2">T2</label>
                    <input type="radio" id="midiTrackT3" name="midiTrack" value="3">
                    <label for="midiTrackT3">T3</label>
                    <input type="radio" id="midiTrackT4" name="midiTrack" value="4">
                    <label for="midiTrackT4">T4</label>
                </div>
                <div class="control-row" style="margin-top: 10px;">
                    <button id="midiLoadBtn" class="control-btn">Load MIDI</button>
                    <input type="file" id="midiFileInput" class="file-input-hidden" accept=".mid,.midi">
                </div>
                <div class="control-row">
                    <span id="midiFileName" class="midi-filename">No file loaded</span>
                </div>
                <div class="control-row" style="margin-top: 10px;">
                    <button id="midiInsertBtn" class="control-btn">Insert</button>
                    <span id="midiInsertTime" class="timecode-display-small">0.000</span>
                </div>
                <div class="control-row" style="margin-top: 10px;">
                    <button id="midiDownloadBtn" class="control-btn">Download MIDI</button>
                </div>
                <div class="control-row">
                    <button id="midiExportCsvBtn" class="control-btn">Export CSV</button>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>Display</h3>
                <div class="control-row">
                    <label style="font-size: 11px;">Zoom:</label>
                    <input type="range" id="scoreZoomSlider" min="50" max="500" step="5" value="100" style="width: 80px;">
                    <span id="scoreZoomValue" style="font-size: 11px; min-width: 35px;">100%</span>
                    <button id="zoomResetBtn" style="font-size: 9px; padding: 2px 5px; margin-left: 5px;" title="Reset to 100% (Double-click slider or press 0)">100%</button>
                </div>
                <div class="display-toggles">
                    <input type="checkbox" id="showGraphicItems" checked>
                    <label for="showGraphicItems">Graphic Items</label>
                    <input type="checkbox" id="showMidiDisplay" checked>
                    <label for="showMidiDisplay">MIDI Display</label>
                </div>
                <div class="control-row" style="margin-top: 8px;">
                    <label for="ccDisplaySelect" style="font-size: 11px;">CC Display:</label>
                    <select id="ccDisplaySelect" style="font-size: 11px; padding: 2px 4px;">
                        <option value="0">CC0 - Bank Select</option>
                        <option value="1">CC1 - Modulation</option>
                        <option value="5">CC5 - Portamento Time</option>
                        <option value="7" selected>CC7 - Main Volume</option>
                        <option value="10">CC10 - Pan</option>
                        <option value="11">CC11 - Expression</option>
                        <option value="120">CC120 - All Sound Off</option>
                        <option value="123">CC123 - All Notes Off</option>
                    </select>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>Score File</h3>
                <div class="control-row">
                    <label style="font-size: 11px;">Name:</label>
                    <input type="text" id="scoreNameInput" value="untitled" style="width: 100px; font-size: 11px;">
                </div>
                <div class="control-row">
                    <button id="scoreSaveBtn" class="control-btn">Save</button>
                    <button id="scoreLoadBtn" class="control-btn">Load</button>
                </div>
                <div class="control-row">
                    <button id="scoreBroadcastLoadBtn" class="control-btn" style="font-size: 10px; background: var(--clr-plum);">Load & Sync All</button>
                </div>
                <div class="control-row">
                    <select id="scoreListSelect" style="font-size: 11px; width: 100%; padding: 2px;">
                        <option value="">-- Select Score --</option>
                    </select>
                </div>
                <div class="control-row">
                    <select id="versionListSelect" style="font-size: 11px; width: 100%; padding: 2px;">
                        <option value="">-- Versions --</option>
                    </select>
                </div>
                <div class="control-row">
                    <button id="loadVersionBtn" class="control-btn" style="font-size: 10px;">Load Version</button>
                </div>
                <div class="control-row">
                    <span id="scoreStatus" style="font-size: 10px; color: var(--clr-lightGrey);">Not saved</span>
                </div>
            </div>
        </div>
    </div>
    
    <div id="ScoreContainer">
        <svg id="ScoreTop"></svg>
        <svg id="ScoreBottom"></svg>
    </div>
    
    
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Clock Sync System
        const ClockSync = {
            socket: null,
            clockOffset: 0,           // Difference between server and client time
            roundTripTime: 0,         // Network latency (round trip)
            syncSamples: [],          // Store recent sync samples for averaging
            maxSamples: 10,           // Number of samples to average
            
            // Initialize the clock sync system
            init() {
                this.socket = io();
                
                this.socket.on('connect', () => {
                    console.log('Connected to server');
                    this.requestPing(); // Initial ping to calculate RTT
                });
                
                // Handle clock sync broadcasts from server
                this.socket.on('clockSync', (data) => {
                    const clientReceiveTime = Date.now();
                    this.updateOffset(data.serverTime, clientReceiveTime);
                });
                
                // Handle pong response for RTT calculation
                this.socket.on('pongResponse', (data) => {
                    const clientReceiveTime = Date.now();
                    this.calculateSync(data.serverTime, data.clientSendTime, clientReceiveTime);
                });
                
                // Periodically request ping for RTT updates
                setInterval(() => this.requestPing(), 5000);
            },
            
            // Request a ping to calculate round-trip time
            requestPing() {
                this.socket.emit('pingRequest', { clientSendTime: Date.now() });
            },
            
            // Calculate sync using ping/pong for accurate RTT
            calculateSync(serverTime, clientSendTime, clientReceiveTime) {
                this.roundTripTime = clientReceiveTime - clientSendTime;
                const oneWayLatency = this.roundTripTime / 2;
                
                // Server time when we received = serverTime + oneWayLatency
                const estimatedServerTimeNow = serverTime + oneWayLatency;
                const offset = estimatedServerTimeNow - clientReceiveTime;
                
                // Add to samples and keep only recent ones
                this.syncSamples.push(offset);
                if (this.syncSamples.length > this.maxSamples) {
                    this.syncSamples.shift();
                }
                
                // Average the samples for stability
                this.clockOffset = this.syncSamples.reduce((a, b) => a + b, 0) / this.syncSamples.length;
                
                console.log(`Clock sync - Offset: ${this.clockOffset.toFixed(2)}ms, RTT: ${this.roundTripTime}ms`);
            },
            
            // Simple offset update from broadcast (less accurate but frequent)
            updateOffset(serverTime, clientReceiveTime) {
                // Only use if we don't have RTT samples yet
                if (this.syncSamples.length === 0) {
                    this.clockOffset = serverTime - clientReceiveTime;
                }
            },
            
            // Get the current synchronized time (server time)
            now() {
                return Date.now() + this.clockOffset;
            },
            
            // Get the clock offset
            getOffset() {
                return this.clockOffset;
            },
            
            // Get the round-trip time
            getRTT() {
                return this.roundTripTime;
            }
        };
        
        // Initialize clock sync when page loads
        ClockSync.init();
        
        // Expose globally for use in other scripts
        window.ClockSync = ClockSync;
        
        // Score Time System - tracks score time relative to clock sync
        // Score time is independent of clock time - can be stopped/started
        const ScoreTime = {
            isPlaying: false,           // Whether score is currently playing
            currentScoreTimeMs: 0,      // Frozen score time when stopped (in ms)
            scoreTimeOffset: 0,         // When playing: scoreTime = clockTime - scoreTimeOffset
            
            // Get current score time in ms
            now() {
                if (this.isPlaying) {
                    return ClockSync.now() - this.scoreTimeOffset;
                } else {
                    return this.currentScoreTimeMs;
                }
            },
            
            // Get current score time in seconds
            nowSeconds() {
                return this.now() / 1000;
            }
        };
        window.ScoreTime = ScoreTime;
        
        // Tempo history - uses score time, not clock time
        let serverTempoHistory = [{ scoreTimeMs: 0, bpm: 60, beatsPerPage: 8 }];
        
        // Animation Engine - Frame rate engine synced to ClockSync timecode
        const AnimationEngine = {
            FRAMERATE: 60,
            MS_PER_FRAME: 1000 / 60,
            
            running: false,
            startTime: 0,              // Synchronized start time (server time)
            currentFrame: 0,           // Current frame number based on sync time
            lastProcessedFrame: -1,    // Last frame that was processed
            
            // Callbacks
            onUpdate: null,            // Called each frame with (frameNumber, deltaTime)
            onDraw: null,              // Called each frame for rendering
            
            // Start the animation engine at a specific server time
            start(serverStartTime = null) {
                this.startTime = serverStartTime || ClockSync.now();
                this.running = true;
                this.lastProcessedFrame = -1;
                console.log(`Animation started at server time: ${this.startTime}`);
                requestAnimationFrame((timestamp) => this.loop(timestamp));
            },
            
            // Stop the animation engine
            stop() {
                this.running = false;
                console.log('Animation stopped');
            },
            
            // Main animation loop
            loop(timestamp) {
                if (!this.running) return;
                
                // Calculate current frame based on synchronized time
                const syncedTime = ClockSync.now();
                const elapsedMs = syncedTime - this.startTime;
                
                // Calculate which frame we should be on based on elapsed synced time
                this.currentFrame = Math.floor(elapsedMs / this.MS_PER_FRAME);
                
                // Only process if we're on a new frame
                if (this.currentFrame > this.lastProcessedFrame) {
                    // Handle frame skip - process missed frames if needed
                    const framesToProcess = this.currentFrame - this.lastProcessedFrame;
                    
                    if (framesToProcess > 1) {
                        console.log(`Skipped ${framesToProcess - 1} frames`);
                    }
                    
                    // Calculate delta time
                    const deltaTime = this.MS_PER_FRAME;
                    
                    // Call update callback
                    if (this.onUpdate) {
                        this.onUpdate(this.currentFrame, deltaTime, elapsedMs);
                    }
                    
                    // Call draw callback
                    if (this.onDraw) {
                        this.onDraw(this.currentFrame, elapsedMs);
                    }
                    
                    this.lastProcessedFrame = this.currentFrame;
                }
                
                // Continue the loop
                requestAnimationFrame((timestamp) => this.loop(timestamp));
            },
            
            // Get current frame number
            getFrame() {
                return this.currentFrame;
            },
            
            // Get elapsed time in ms since start
            getElapsedTime() {
                return ClockSync.now() - this.startTime;
            },
            
            // Get elapsed time in seconds
            getElapsedSeconds() {
                return this.getElapsedTime() / 1000;
            },
            
            // Set the start time (for syncing multiple clients to same timeline)
            setStartTime(serverStartTime) {
                this.startTime = serverStartTime;
            },
            
            // Set frame rate
            setFrameRate(fps) {
                this.FRAMERATE = fps;
                this.MS_PER_FRAME = 1000 / fps;
            }
        };
        
        // Expose globally
        window.AnimationEngine = AnimationEngine;
        
        // Tempo variables - fixed at 16 beats per page and 60 BPM
        let beatsPerPage = 8;
        let beatsPerMinute = 60;
        
        // Lead-in time - negative time before score starts at 0
        let leadInSeconds = 2;
        
        // Cursor Control Menu functionality (Right side)
        const CursorControls = {
            menuEl: null,
            toggleEl: null,
            goStopBtn: null,
            gotoSecondInput: null,
            gotoBtn: null,
            leadInSecondsInput: null,
            isOpen: false,
            
            init() {
                this.menuEl = document.getElementById('cursorMenu');
                this.toggleEl = document.getElementById('cursorMenuToggle');
                this.goStopBtn = document.getElementById('goStopBtn');
                this.gotoSecondInput = document.getElementById('gotoSecondInput');
                this.gotoBtn = document.getElementById('gotoBtn');
                this.leadInSecondsInput = document.getElementById('leadInSecondsInput');
                
                // Toggle menu open/close
                this.toggleEl.addEventListener('click', () => this.toggle());
                
                // Lead-in seconds input
                this.leadInSecondsInput.addEventListener('change', (e) => {
                    leadInSeconds = parseFloat(e.target.value) || 0;
                    // Update min values for jump inputs to allow negative lead-in time
                    this.updateJumpInputLimits();
                    // Re-render graphic timeline with new lead-in
                    if (window.GraphicTimeline) GraphicTimeline.renderTicks();
                    // Update staff headers position
                    if (window.StaffCursors) StaffCursors.updateStaffHeaders();
                });
                
                // Set initial min values based on default lead-in
                this.updateJumpInputLimits();
                
                // Go/Stop toggle button
                this.goStopBtn.addEventListener('click', () => this.toggleGoStop());
                
                // Go to button - stops, jumps, stays stopped
                this.gotoBtn.addEventListener('click', () => this.gotoPosition());
                
                // Enter key on second input triggers goto
                this.gotoSecondInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.gotoPosition();
                });
                
                // Listen for score control events from server
                ClockSync.socket.on('scoreGo', (data) => {
                    this.onScoreGo(data);
                });
                
                ClockSync.socket.on('scoreStop', (data) => {
                    this.onScoreStop(data);
                });
                
                ClockSync.socket.on('scoreGoto', (data) => {
                    this.onScoreGoto(data);
                });
            },
            
            // Convert seconds to beats using current BPM
            secondsToBeats(seconds) {
                return seconds * (beatsPerMinute / 60);
            },
            
            // Convert beats to seconds using current BPM
            beatsToSeconds(beats) {
                return beats * (60 / beatsPerMinute);
            },
            
            // Update min value for jump input based on lead-in time
            updateJumpInputLimits() {
                const minSeconds = -leadInSeconds;
                this.gotoSecondInput.setAttribute('min', minSeconds);
            },
            
            toggle() {
                this.isOpen = !this.isOpen;
                this.menuEl.classList.toggle('open', this.isOpen);
                this.toggleEl.textContent = this.isOpen ? '◀ Playback-MIDI' : 'Playback-MIDI ▶';
            },
            
            toggleGoStop() {
                if (ScoreTime.isPlaying) {
                    ClockSync.socket.emit('scoreStop');
                } else {
                    ClockSync.socket.emit('scoreGo');
                }
            },
            
            gotoPosition() {
                // Use the seconds value (which is kept in sync with beats)
                // Add leadInSeconds offset so input 0 jumps to tick mark 0
                const displaySeconds = parseFloat(this.gotoSecondInput.value) || 0;
                const actualSeconds = displaySeconds + leadInSeconds;
                ClockSync.socket.emit('scoreGoto', { seconds: actualSeconds });
            },
            
            onScoreGo(data) {
                ScoreTime.isPlaying = true;
                ScoreTime.scoreTimeOffset = data.scoreTimeOffset;
                ScoreTime.currentScoreTimeMs = data.currentScoreTimeMs;
                this.goStopBtn.textContent = 'Stop';
                this.goStopBtn.classList.add('active');
                console.log(`Score GO - playing from ${data.currentScoreTimeMs}ms`);
                
                // Debug: Check curve state
                if (window.CurveMaker) {
                    console.log(`[onScoreGo] CurveMaker.curves.length=${CurveMaker.curves.length}`);
                    CurveMaker.curves.forEach((c, i) => {
                        console.log(`[onScoreGo] Curve ${i}: ${c.name}, group in DOM: ${c.elements?.group?.parentNode ? 'yes' : 'no'}, display: ${c.elements?.group?.style?.display}`);
                    });
                }
            },
            
            onScoreStop(data) {
                ScoreTime.isPlaying = false;
                ScoreTime.currentScoreTimeMs = data.currentScoreTimeMs;
                this.goStopBtn.textContent = 'Go';
                this.goStopBtn.classList.remove('active');
                console.log(`Score STOP - frozen at ${data.currentScoreTimeMs}ms`);
            },
            
            onScoreGoto(data) {
                ScoreTime.isPlaying = false;
                ScoreTime.currentScoreTimeMs = data.currentScoreTimeMs;
                serverTempoHistory = data.tempoHistory;
                this.goStopBtn.textContent = 'Go';
                this.goStopBtn.classList.remove('active');
                // Update input to reflect the new position (convert from actual to display time)
                const displaySeconds = data.targetSeconds - leadInSeconds;
                this.gotoSecondInput.value = displaySeconds.toFixed(2);
                // Update graphic timeline for new position
                if (window.GraphicTimeline) {
                    GraphicTimeline.onGoto(data.targetSeconds);
                }
                // Update track system for new position
                if (window.TrackSystem) {
                    TrackSystem.onGoto(data.targetSeconds);
                }
                // Reset MIDI playback indices to match new position
                if (window.MidiController) {
                    MidiController.resetPlaybackToTime(displaySeconds * 1000);
                }
                console.log(`Score GOTO ${data.targetSeconds}s (display: ${displaySeconds}s) - frozen at ${data.currentScoreTimeMs}ms`);
            }
        };
        
        // Initialize cursor controls after DOM is ready
        CursorControls.init();
        window.CursorControls = CursorControls;
        
        // SVG Element Manager - Insert, resize, move SVG elements on the score
        const SVGElementManager = {
            elements: [],      // Array of inserted SVG elements
            selectedElement: null,
            nextId: 1,
            isDragging: false,
            isResizing: false,
            resizeCorner: null,
            dragStartX: 0,
            dragStartY: 0,
            elementStartX: 0,
            elementStartY: 0,
            elementStartScale: 1,
            resizeHandles: [],
            
            init() {
                // UI elements
                this.insertBtn = document.getElementById('svgInsertBtn');
                this.fileInput = document.getElementById('svgFileInput');
                this.elementList = document.getElementById('svgElementList');
                this.posXInput = document.getElementById('svgPosX');
                this.posYInput = document.getElementById('svgPosY');
                this.scaleSlider = document.getElementById('svgScaleSlider');
                this.scaleValue = document.getElementById('svgScaleValue');
                this.trackSelect = document.getElementById('svgTrackSelect');
                this.deleteBtn = document.getElementById('svgDeleteBtn');
                
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Create container group for SVG elements
                this.containerTop = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.containerTop.setAttribute('id', 'svg-elements-container');
                this.scoreTopEl.appendChild(this.containerTop);
                
                // Event listeners
                this.insertBtn.addEventListener('click', () => this.fileInput.click());
                this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                this.deleteBtn.addEventListener('click', () => this.deleteSelected());
                
                this.posXInput.addEventListener('change', () => this.updateSelectedPosition());
                this.posYInput.addEventListener('change', () => this.updateSelectedPosition());
                this.scaleSlider.addEventListener('input', () => this.updateSelectedScale());
                this.trackSelect.addEventListener('change', () => this.updateSelectedTrack());
                
                // Click on score to deselect
                this.scoreTopEl.addEventListener('click', (e) => {
                    if (e.target === this.scoreTopEl || e.target.tagName === 'svg') {
                        this.deselectAll();
                    }
                });
                
                // Global mouse events for drag/resize
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                console.log('SVGElementManager initialized');
            },
            
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    this.insertSVG(event.target.result, file.name);
                };
                reader.readAsText(file);
                e.target.value = ''; // Reset input
            },
            
            insertSVG(svgContent, filename) {
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
                const svgEl = svgDoc.documentElement;
                
                // Get original dimensions
                let width = parseFloat(svgEl.getAttribute('width')) || 100;
                let height = parseFloat(svgEl.getAttribute('height')) || 100;
                
                // Handle mm units
                const widthStr = svgEl.getAttribute('width') || '';
                const heightStr = svgEl.getAttribute('height') || '';
                if (widthStr.includes('mm')) width = parseFloat(widthStr) * 3.78;
                if (heightStr.includes('mm')) height = parseFloat(heightStr) * 3.78;
                
                // Get viewBox if present
                const viewBox = svgEl.getAttribute('viewBox');
                
                // Create wrapper group
                const wrapper = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                const id = this.nextId++;
                wrapper.setAttribute('id', `svg-element-${id}`);
                wrapper.setAttribute('class', 'svg-element-wrapper');
                
                // Create the image element
                const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                
                // Convert SVG to data URL, replacing currentColor with black
                let svgString = new XMLSerializer().serializeToString(svgEl);
                svgString = svgString.replace(/currentColor/g, '#000000');
                const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString)));
                
                image.setAttribute('href', dataUrl);
                image.setAttribute('width', width);
                image.setAttribute('height', height);
                
                wrapper.appendChild(image);
                
                // Calculate initial position (center of current track)
                const track = parseInt(this.trackSelect.value) || 1;
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                const timelineHeight = 16;
                const availableHeight = scoreHeight - timelineHeight;
                const staffHeight = availableHeight / 4;
                const trackY = timelineHeight + ((track - 1) * staffHeight) + (staffHeight / 2) - (height / 2);
                const trackX = scoreWidth * 0.2; // Start at 20% from left
                
                // Get current page from GraphicTimeline
                const currentPage = window.GraphicTimeline ? GraphicTimeline.currentTopPage : 0;
                const section = 'top'; // SVGs are always added to top section initially
                
                // Store element data
                const elementData = {
                    id: id,
                    name: filename.replace('.svg', ''),
                    wrapper: wrapper,
                    image: image,
                    x: trackX,
                    y: trackY,
                    width: width,
                    height: height,
                    scale: 1,
                    track: track,
                    page: currentPage,
                    section: section
                };
                
                this.elements.push(elementData);
                
                // Apply initial transform
                this.updateElementTransform(elementData);
                
                // Add to container
                this.containerTop.appendChild(wrapper);
                
                // Add drag handlers
                wrapper.addEventListener('mousedown', (e) => this.handleElementMouseDown(e, elementData));
                
                // Update list and select
                this.updateElementList();
                this.selectElement(elementData);
            },
            
            updateElementTransform(el) {
                const scaledWidth = el.width * el.scale;
                const scaledHeight = el.height * el.scale;
                el.wrapper.setAttribute('transform', `translate(${el.x}, ${el.y}) scale(${el.scale})`);
                el.image.setAttribute('width', el.width);
                el.image.setAttribute('height', el.height);
                
                // Update resize handles if this is the selected element
                if (el === this.selectedElement) {
                    this.updateResizeHandles();
                }
            },
            
            createResizeHandles() {
                // Remove existing handles
                this.removeResizeHandles();
                
                if (!this.selectedElement) return;
                
                const handleSize = 8;
                const corners = ['se']; // Just SE corner for proportional resize
                
                corners.forEach(corner => {
                    const handle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    handle.setAttribute('width', handleSize);
                    handle.setAttribute('height', handleSize);
                    handle.setAttribute('class', `svg-resize-handle corner-${corner}`);
                    handle.setAttribute('data-corner', corner);
                    handle.style.cursor = 'nwse-resize';
                    
                    handle.addEventListener('mousedown', (e) => this.handleResizeMouseDown(e, corner));
                    
                    this.containerTop.appendChild(handle);
                    this.resizeHandles.push(handle);
                });
                
                this.updateResizeHandles();
            },
            
            updateResizeHandles() {
                if (!this.selectedElement || this.resizeHandles.length === 0) return;
                
                const el = this.selectedElement;
                const scaledWidth = el.width * el.scale;
                const scaledHeight = el.height * el.scale;
                const handleSize = 8;
                
                this.resizeHandles.forEach(handle => {
                    const corner = handle.getAttribute('data-corner');
                    let hx, hy;
                    
                    if (corner === 'se') {
                        hx = el.x + scaledWidth - handleSize / 2;
                        hy = el.y + scaledHeight - handleSize / 2;
                    }
                    
                    handle.setAttribute('x', hx);
                    handle.setAttribute('y', hy);
                });
            },
            
            removeResizeHandles() {
                this.resizeHandles.forEach(handle => handle.remove());
                this.resizeHandles = [];
            },
            
            handleResizeMouseDown(e, corner) {
                e.stopPropagation();
                e.preventDefault();
                
                this.isResizing = true;
                this.resizeCorner = corner;
                this.dragStartX = e.clientX;
                this.dragStartY = e.clientY;
                this.elementStartScale = this.selectedElement.scale;
                this.elementStartX = this.selectedElement.x;
                this.elementStartY = this.selectedElement.y;
            },
            
            handleElementMouseDown(e, elementData) {
                // Don't start dragging if clicking on a flowchart node
                if (e.target.classList.contains('flowchart-node')) {
                    return;
                }
                
                e.stopPropagation();
                this.selectElement(elementData);
                
                // Start dragging
                this.isDragging = true;
                this.dragStartX = e.clientX;
                this.dragStartY = e.clientY;
                this.elementStartX = elementData.x;
                this.elementStartY = elementData.y;
            },
            
            handleMouseMove(e) {
                // Get zoom scale factor
                const zoomScale = window.ScoreZoom ? ScoreZoom.getZoom() : 1;
                
                if (this.isResizing && this.selectedElement) {
                    const dx = (e.clientX - this.dragStartX) / zoomScale;
                    const dy = (e.clientY - this.dragStartY) / zoomScale;
                    
                    // Use diagonal distance for proportional scaling
                    const diagonal = (dx + dy) / 2;
                    const baseSize = this.selectedElement.width * this.elementStartScale;
                    const scaleFactor = (baseSize + diagonal) / baseSize;
                    
                    const newScale = Math.max(0.1, Math.min(5, this.elementStartScale * scaleFactor));
                    this.selectedElement.scale = newScale;
                    
                    this.updateElementTransform(this.selectedElement);
                    this.updateUIFromSelected();
                    // Update connectors when element is resized
                    if (window.FlowchartConnector) FlowchartConnector.updateAllConnectors();
                    return;
                }
                
                if (!this.isDragging || !this.selectedElement) return;
                
                const dx = (e.clientX - this.dragStartX) / zoomScale;
                const dy = (e.clientY - this.dragStartY) / zoomScale;
                
                this.selectedElement.x = this.elementStartX + dx;
                this.selectedElement.y = this.elementStartY + dy;
                
                this.updateElementTransform(this.selectedElement);
                this.updateUIFromSelected();
                // Update connectors when element is moved
                if (window.FlowchartConnector) FlowchartConnector.updateAllConnectors();
            },
            
            handleMouseUp(e) {
                this.isDragging = false;
                this.isResizing = false;
                this.resizeCorner = null;
            },
            
            selectElement(elementData) {
                this.deselectAll();
                this.selectedElement = elementData;
                elementData.wrapper.classList.add('selected');
                
                // Create resize handles
                this.createResizeHandles();
                
                // Update UI
                this.updateUIFromSelected();
                this.updateElementList();
            },
            
            deselectAll() {
                if (this.selectedElement) {
                    this.selectedElement.wrapper.classList.remove('selected');
                }
                this.selectedElement = null;
                this.removeResizeHandles();
                this.updateElementList();
            },
            
            updateUIFromSelected() {
                if (!this.selectedElement) return;
                this.posXInput.value = Math.round(this.selectedElement.x);
                this.posYInput.value = Math.round(this.selectedElement.y);
                this.scaleSlider.value = this.selectedElement.scale;
                this.scaleValue.textContent = this.selectedElement.scale.toFixed(2);
                this.trackSelect.value = this.selectedElement.track;
            },
            
            updateSelectedPosition() {
                if (!this.selectedElement) return;
                this.selectedElement.x = parseFloat(this.posXInput.value) || 0;
                this.selectedElement.y = parseFloat(this.posYInput.value) || 0;
                this.updateElementTransform(this.selectedElement);
            },
            
            updateSelectedScale() {
                if (!this.selectedElement) return;
                this.selectedElement.scale = parseFloat(this.scaleSlider.value) || 1;
                this.scaleValue.textContent = this.selectedElement.scale.toFixed(2);
                this.updateElementTransform(this.selectedElement);
            },
            
            updateSelectedTrack() {
                if (!this.selectedElement) return;
                const track = parseInt(this.trackSelect.value) || 1;
                this.selectedElement.track = track;
                
                // Reposition Y to center in new track
                const scoreHeight = this.scoreTopEl.clientHeight;
                const timelineHeight = 16;
                const availableHeight = scoreHeight - timelineHeight;
                const staffHeight = availableHeight / 4;
                const scaledHeight = this.selectedElement.height * this.selectedElement.scale;
                this.selectedElement.y = timelineHeight + ((track - 1) * staffHeight) + (staffHeight / 2) - (scaledHeight / 2);
                
                this.updateElementTransform(this.selectedElement);
                this.updateUIFromSelected();
            },
            
            deleteSelected() {
                if (!this.selectedElement) return;
                
                // Remove from DOM
                this.selectedElement.wrapper.remove();
                
                // Remove from array
                const idx = this.elements.indexOf(this.selectedElement);
                if (idx > -1) this.elements.splice(idx, 1);
                
                this.selectedElement = null;
                this.updateElementList();
            },
            
            updateElementList() {
                this.elementList.innerHTML = '';
                this.elements.forEach(el => {
                    const item = document.createElement('div');
                    item.className = 'svg-element-item' + (el === this.selectedElement ? ' selected' : '');
                    item.textContent = el.name;
                    item.addEventListener('click', () => this.selectElement(el));
                    this.elementList.appendChild(item);
                });
            },
            
            // Determine track based on Y position
            getTrackFromY(y) {
                const scoreHeight = this.scoreTopEl.clientHeight;
                const timelineHeight = 16;
                const availableHeight = scoreHeight - timelineHeight;
                const staffHeight = availableHeight / 4;
                
                const relativeY = y - timelineHeight;
                const track = Math.floor(relativeY / staffHeight) + 1;
                return Math.max(1, Math.min(4, track));
            },
            
            // Show/hide elements based on current page
            updateVisibility() {
                if (!window.GraphicTimeline) return;
                
                const topPage = GraphicTimeline.currentTopPage;
                const bottomPage = GraphicTimeline.currentBottomPage;
                
                this.elements.forEach(el => {
                    // Show element if its page matches the current top page (all SVGs are in top section)
                    const visible = el.page === topPage;
                    el.wrapper.style.display = visible ? '' : 'none';
                });
            },
            
            // Export data for saving
            exportData() {
                return this.elements.map(el => ({
                    id: el.id,
                    name: el.name,
                    x: el.x,
                    y: el.y,
                    width: el.width,
                    height: el.height,
                    scale: el.scale,
                    track: this.getTrackFromY(el.y),
                    page: el.page || 0,
                    section: el.section || 'top',
                    svgDataUrl: el.image.getAttribute('href')
                }));
            },
            
            // Import data from saved score
            importData(data) {
                if (!data || !Array.isArray(data)) return;
                
                // Clear existing elements
                this.elements.forEach(el => el.wrapper.remove());
                this.elements = [];
                this.removeResizeHandles();
                this.selectedElement = null;
                
                // Recreate elements
                data.forEach(elData => {
                    const wrapper = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    wrapper.setAttribute('id', `svg-element-${elData.id}`);
                    wrapper.setAttribute('class', 'svg-element-wrapper');
                    
                    const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    image.setAttribute('href', elData.svgDataUrl);
                    image.setAttribute('width', elData.width);
                    image.setAttribute('height', elData.height);
                    
                    wrapper.appendChild(image);
                    
                    const elementData = {
                        id: elData.id,
                        name: elData.name,
                        wrapper: wrapper,
                        image: image,
                        x: elData.x,
                        y: elData.y,
                        width: elData.width,
                        height: elData.height,
                        scale: elData.scale,
                        track: elData.track,
                        page: elData.page || 0,
                        section: elData.section || 'top'
                    };
                    
                    this.elements.push(elementData);
                    this.updateElementTransform(elementData);
                    this.containerTop.appendChild(wrapper);
                    
                    // Add drag handlers
                    wrapper.addEventListener('mousedown', (e) => this.handleElementMouseDown(e, elementData));
                    
                    // Update nextId
                    if (elData.id >= this.nextId) {
                        this.nextId = elData.id + 1;
                    }
                });
                
                this.updateElementList();
                console.log(`SVGElementManager: Imported ${this.elements.length} elements`);
            }
        };
        
        // Flowchart Connector System - Right-angle connectors between objects
        const FlowchartConnector = {
            connectors: [],
            selectedConnector: null,
            nextId: 1,
            connectMode: false,
            isDrawing: false,
            drawStartPoint: null,
            drawStartElement: null,
            drawStartObjectType: null,
            tempLine: null,
            
            colorMap: {
                black: '#000',
                lightGrey: '#aaa',
                white: '#fff',
                limeGreen: 'rgb(153,255,0)',
                neonMagenta: 'rgb(255,21,160)',
                brightBlue: 'rgba(56,126,211,255)',
                brightOrange: 'rgba(240,75,0,255)',
                neonYellow: 'rgb(255,255,0)'
            },
            
            arrowShapes: {
                triangle: { end: 'M 0 0 L 10 5 L 0 10 z', start: 'M 10 0 L 0 5 L 10 10 z' },
                stealth: { end: 'M 0 0 L 10 5 L 0 10 L 3 5 z', start: 'M 10 0 L 0 5 L 10 10 L 7 5 z' },
                diamond: { end: 'M 0 5 L 5 0 L 10 5 L 5 10 z', start: 'M 0 5 L 5 0 L 10 5 L 5 10 z' },
                circle: { end: 'M 5 0 A 5 5 0 1 1 5 10 A 5 5 0 1 1 5 0', start: 'M 5 0 A 5 5 0 1 1 5 10 A 5 5 0 1 1 5 0' }
            },
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                this.modeBtn = document.getElementById('connectorModeBtn');
                this.connectorList = document.getElementById('connectorList');
                this.arrowSelect = document.getElementById('connectorArrowSelect');
                this.arrowStyleSelect = document.getElementById('connectorArrowStyleSelect');
                this.arrowSizeSlider = document.getElementById('connectorArrowSizeSlider');
                this.arrowSizeValue = document.getElementById('connectorArrowSizeValue');
                this.lineColorSelect = document.getElementById('connectorLineColorSelect');
                this.arrowColorSelect = document.getElementById('connectorArrowColorSelect');
                this.routingSelect = document.getElementById('connectorRoutingSelect');
                this.deleteBtn = document.getElementById('connectorDeleteBtn');
                
                // Create connector groups in SVG
                this.topConnectorGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.topConnectorGroup.setAttribute('id', 'topConnectorGroup');
                this.scoreTopEl.appendChild(this.topConnectorGroup);
                
                this.bottomConnectorGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.bottomConnectorGroup.setAttribute('id', 'bottomConnectorGroup');
                this.scoreBottomEl.appendChild(this.bottomConnectorGroup);
                
                // Create arrow markers
                this.createArrowMarkers();
                
                // Event listeners
                if (this.modeBtn) {
                    this.modeBtn.addEventListener('click', () => this.toggleConnectMode());
                }
                if (this.deleteBtn) {
                    this.deleteBtn.addEventListener('click', () => this.deleteSelected());
                }
                if (this.arrowSelect) {
                    this.arrowSelect.addEventListener('change', () => this.updateSelectedProperty('arrowType', this.arrowSelect.value));
                }
                if (this.arrowStyleSelect) {
                    this.arrowStyleSelect.addEventListener('change', () => this.updateSelectedProperty('arrowStyle', this.arrowStyleSelect.value));
                }
                if (this.arrowSizeSlider) {
                    this.arrowSizeSlider.addEventListener('input', () => {
                        this.arrowSizeValue.textContent = this.arrowSizeSlider.value;
                        this.updateSelectedProperty('arrowSize', parseInt(this.arrowSizeSlider.value));
                    });
                }
                if (this.lineColorSelect) {
                    this.lineColorSelect.addEventListener('change', () => this.updateSelectedProperty('lineColor', this.lineColorSelect.value));
                }
                if (this.arrowColorSelect) {
                    this.arrowColorSelect.addEventListener('change', () => this.updateSelectedProperty('arrowColor', this.arrowColorSelect.value));
                }
                if (this.routingSelect) {
                    this.routingSelect.addEventListener('change', () => this.updateSelectedProperty('routing', this.routingSelect.value));
                }
                
                // Mouse events for drawing
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                // Click on SVG background to deselect connectors
                this.scoreTopEl.addEventListener('click', (e) => {
                    if (e.target === this.scoreTopEl || e.target.tagName === 'svg') {
                        this.deselectAll();
                    }
                });
                this.scoreBottomEl.addEventListener('click', (e) => {
                    if (e.target === this.scoreBottomEl || e.target.tagName === 'svg') {
                        this.deselectAll();
                    }
                });
                
                console.log('FlowchartConnector initialized');
            },
            
            createArrowMarkers() {
                [this.scoreTopEl, this.scoreBottomEl].forEach(svg => {
                    let defs = svg.querySelector('defs');
                    if (!defs) {
                        defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        svg.insertBefore(defs, svg.firstChild);
                    }
                    
                    // Create markers for each color, style, and size combination
                    Object.entries(this.colorMap).forEach(([colorName, colorValue]) => {
                        Object.entries(this.arrowShapes).forEach(([styleName, paths]) => {
                            for (let size = 3; size <= 12; size++) {
                                // End marker
                                const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                                endMarker.setAttribute('id', `arrow-end-${colorName}-${styleName}-${size}`);
                                endMarker.setAttribute('viewBox', '0 0 10 10');
                                endMarker.setAttribute('refX', styleName === 'circle' ? '5' : '9');
                                endMarker.setAttribute('refY', '5');
                                endMarker.setAttribute('markerWidth', size);
                                endMarker.setAttribute('markerHeight', size);
                                endMarker.setAttribute('orient', 'auto-start-reverse');
                                const endPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                endPath.setAttribute('d', paths.end);
                                endPath.setAttribute('fill', colorValue);
                                endMarker.appendChild(endPath);
                                defs.appendChild(endMarker);
                                
                                // Start marker
                                const startMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                                startMarker.setAttribute('id', `arrow-start-${colorName}-${styleName}-${size}`);
                                startMarker.setAttribute('viewBox', '0 0 10 10');
                                startMarker.setAttribute('refX', styleName === 'circle' ? '5' : '1');
                                startMarker.setAttribute('refY', '5');
                                startMarker.setAttribute('markerWidth', size);
                                startMarker.setAttribute('markerHeight', size);
                                startMarker.setAttribute('orient', 'auto-start-reverse');
                                const startPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                startPath.setAttribute('d', paths.start);
                                startPath.setAttribute('fill', colorValue);
                                startMarker.appendChild(startPath);
                                defs.appendChild(startMarker);
                            }
                        });
                    });
                });
            },
            
            toggleConnectMode() {
                this.connectMode = !this.connectMode;
                this.modeBtn.textContent = `Connect Mode: ${this.connectMode ? 'ON' : 'OFF'}`;
                this.modeBtn.style.background = this.connectMode ? 'var(--clr-limeGreen)' : '';
                this.modeBtn.style.color = this.connectMode ? '#000' : '';
                
                // Show/hide connection nodes
                this.updateConnectionNodes();
            },
            
            updateConnectionNodes() {
                // Add/remove connection nodes on SVG elements
                if (window.SVGElementManager) {
                    SVGElementManager.elements.forEach(el => {
                        this.addNodesTo(el, 'svg');
                    });
                }
                
                // Add/remove connection nodes on curves
                if (window.CurveMaker && CurveMaker.curves) {
                    CurveMaker.curves.forEach(curve => {
                        this.addNodesToCurve(curve);
                    });
                }
            },
            
            addNodesTo(el, objectType) {
                const existingNodes = el.wrapper.querySelectorAll('.flowchart-node');
                existingNodes.forEach(n => n.remove());
                
                if (this.connectMode) {
                    const w = el.width * el.scale;
                    const h = el.height * el.scale;
                    // 8 nodes: 4 sides + 4 corners
                    const nodePositions = [
                        { x: w/2, y: 0, side: 'top' },
                        { x: w, y: 0, side: 'top-right' },
                        { x: w, y: h/2, side: 'right' },
                        { x: w, y: h, side: 'bottom-right' },
                        { x: w/2, y: h, side: 'bottom' },
                        { x: 0, y: h, side: 'bottom-left' },
                        { x: 0, y: h/2, side: 'left' },
                        { x: 0, y: 0, side: 'top-left' }
                    ];
                    
                    nodePositions.forEach(pos => {
                        const node = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        node.setAttribute('cx', pos.x);
                        node.setAttribute('cy', pos.y);
                        node.setAttribute('r', '6');
                        node.setAttribute('class', 'flowchart-node');
                        node.setAttribute('data-side', pos.side);
                        node.setAttribute('data-element-id', el.id);
                        node.setAttribute('data-object-type', objectType);
                        node.style.pointerEvents = 'all';
                        
                        node.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.startDrawing(el, pos.side, objectType, e);
                        });
                        
                        el.wrapper.appendChild(node);
                    });
                }
            },
            
            addNodesToCurve(curve) {
                if (!curve.elements || !curve.elements.group) return;
                
                const existingNodes = curve.elements.group.querySelectorAll('.flowchart-node');
                existingNodes.forEach(n => n.remove());
                
                if (this.connectMode) {
                    // Calculate bounding box of curve
                    const minX = Math.min(curve.x1, curve.x2);
                    const maxX = Math.max(curve.x1, curve.x2);
                    const minY = Math.min(curve.y1Pixel, curve.y2Pixel);
                    const maxY = Math.max(curve.y1Pixel, curve.y2Pixel);
                    const midX = (minX + maxX) / 2;
                    const midY = (minY + maxY) / 2;
                    
                    // 8 nodes: 4 sides + 4 corners (same as SVG elements)
                    const nodePositions = [
                        { x: midX, y: minY, side: 'top' },
                        { x: maxX, y: minY, side: 'top-right' },
                        { x: maxX, y: midY, side: 'right' },
                        { x: maxX, y: maxY, side: 'bottom-right' },
                        { x: midX, y: maxY, side: 'bottom' },
                        { x: minX, y: maxY, side: 'bottom-left' },
                        { x: minX, y: midY, side: 'left' },
                        { x: minX, y: minY, side: 'top-left' }
                    ];
                    
                    nodePositions.forEach(pos => {
                        const node = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        node.setAttribute('cx', pos.x);
                        node.setAttribute('cy', pos.y);
                        node.setAttribute('r', '6');
                        node.setAttribute('class', 'flowchart-node');
                        node.setAttribute('data-side', pos.side);
                        node.setAttribute('data-curve-id', curve.id);
                        node.setAttribute('data-object-type', 'curve');
                        node.style.pointerEvents = 'all';
                        
                        node.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.startDrawingFromCurve(curve, pos.side, e);
                        });
                        
                        curve.elements.group.appendChild(node);
                    });
                }
            },
            
            startDrawing(element, side, objectType, e) {
                const section = this.scoreTopEl.contains(element.wrapper) ? 'top' : 'bottom';
                
                this.isDrawing = true;
                this.drawStartElement = element;
                this.drawStartSide = side;
                this.drawStartObjectType = objectType;
                this.drawSection = section;
                this.drawStartPoint = this.getNodePosition(element, side, objectType);
                
                this.createTempLine(section);
            },
            
            startDrawingFromCurve(curve, side, e) {
                const section = curve.section || 'top';
                
                this.isDrawing = true;
                this.drawStartElement = curve;
                this.drawStartSide = side;
                this.drawStartObjectType = 'curve';
                this.drawSection = section;
                this.drawStartPoint = this.getCurveNodePosition(curve, side);
                
                this.createTempLine(section);
            },
            
            createTempLine(section) {
                const group = section === 'top' ? this.topConnectorGroup : this.bottomConnectorGroup;
                this.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.tempLine.setAttribute('stroke', '#888');
                this.tempLine.setAttribute('stroke-width', '2');
                this.tempLine.setAttribute('stroke-dasharray', '5,5');
                this.tempLine.setAttribute('fill', 'none');
                this.tempLine.style.pointerEvents = 'none';
                group.appendChild(this.tempLine);
            },
            
            handleMouseMove(e) {
                if (!this.isDrawing || !this.tempLine) return;
                
                const svg = this.drawSection === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const rect = svg.getBoundingClientRect();
                // Account for zoom scale
                const zoomScale = window.ScoreZoom ? ScoreZoom.getZoom() : 1;
                const x = (e.clientX - rect.left) / zoomScale;
                const y = (e.clientY - rect.top) / zoomScale;
                
                const routing = this.routingSelect?.value || 'auto';
                const path = this.calculatePath(
                    this.drawStartPoint.x, this.drawStartPoint.y,
                    x, y,
                    this.drawStartSide, null, routing
                );
                this.tempLine.setAttribute('d', path);
            },
            
            handleMouseUp(e) {
                if (!this.isDrawing) return;
                
                const node = e.target.closest('.flowchart-node');
                if (node) {
                    const objectType = node.getAttribute('data-object-type');
                    
                    if (objectType === 'curve') {
                        const curveId = parseInt(node.getAttribute('data-curve-id'));
                        if (curveId !== this.drawStartElement.id || this.drawStartObjectType !== 'curve') {
                            const endCurve = CurveMaker.curves.find(c => c.id === curveId);
                            const endSide = node.getAttribute('data-side');
                            if (endCurve) {
                                this.createConnectorGeneric(
                                    this.drawStartElement, this.drawStartSide, this.drawStartObjectType,
                                    endCurve, endSide, 'curve',
                                    this.drawSection
                                );
                            }
                        }
                    } else {
                        const elementId = parseInt(node.getAttribute('data-element-id'));
                        if (elementId !== this.drawStartElement.id || this.drawStartObjectType !== 'svg') {
                            const endElement = SVGElementManager.elements.find(el => el.id === elementId);
                            const endSide = node.getAttribute('data-side');
                            if (endElement) {
                                this.createConnectorGeneric(
                                    this.drawStartElement, this.drawStartSide, this.drawStartObjectType,
                                    endElement, endSide, 'svg',
                                    this.drawSection
                                );
                            }
                        }
                    }
                }
                
                // Clean up
                if (this.tempLine) {
                    this.tempLine.remove();
                    this.tempLine = null;
                }
                this.isDrawing = false;
                this.drawStartElement = null;
                this.drawStartPoint = null;
                this.drawStartObjectType = null;
            },
            
            getNodePosition(element, side, objectType) {
                if (objectType === 'curve') {
                    return this.getCurveNodePosition(element, side);
                }
                
                const w = element.width * element.scale;
                const h = element.height * element.scale;
                let x = element.x;
                let y = element.y;
                
                switch (side) {
                    case 'top': x += w/2; break;
                    case 'top-right': x += w; break;
                    case 'right': x += w; y += h/2; break;
                    case 'bottom-right': x += w; y += h; break;
                    case 'bottom': x += w/2; y += h; break;
                    case 'bottom-left': y += h; break;
                    case 'left': y += h/2; break;
                    case 'top-left': break;
                }
                return { x, y };
            },
            
            getCurveNodePosition(curve, side) {
                // Calculate bounding box of curve
                const minX = Math.min(curve.x1, curve.x2);
                const maxX = Math.max(curve.x1, curve.x2);
                const minY = Math.min(curve.y1Pixel, curve.y2Pixel);
                const maxY = Math.max(curve.y1Pixel, curve.y2Pixel);
                const midX = (minX + maxX) / 2;
                const midY = (minY + maxY) / 2;
                
                switch (side) {
                    case 'top': return { x: midX, y: minY };
                    case 'top-right': return { x: maxX, y: minY };
                    case 'right': return { x: maxX, y: midY };
                    case 'bottom-right': return { x: maxX, y: maxY };
                    case 'bottom': return { x: midX, y: maxY };
                    case 'bottom-left': return { x: minX, y: maxY };
                    case 'left': return { x: minX, y: midY };
                    case 'top-left': return { x: minX, y: minY };
                    // Legacy support for old 'start'/'end' sides
                    case 'start': return { x: curve.x1, y: curve.y1Pixel };
                    case 'end': return { x: curve.x2, y: curve.y2Pixel };
                    default: return { x: midX, y: midY };
                }
            },
            
            calculatePath(x1, y1, x2, y2, startSide, endSide, routing) {
                if (routing === 'direct') {
                    return `M ${x1} ${y1} L ${x2} ${y2}`;
                }
                
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                
                let path;
                
                if (routing === 'horizontal-first') {
                    path = `M ${x1} ${y1} H ${x2} V ${y2}`;
                } else if (routing === 'vertical-first') {
                    path = `M ${x1} ${y1} V ${y2} H ${x2}`;
                } else {
                    // Auto routing based on start side
                    const isHorizontalStart = startSide === 'left' || startSide === 'right' || 
                                              startSide === 'top-left' || startSide === 'top-right' ||
                                              startSide === 'bottom-left' || startSide === 'bottom-right';
                    
                    if (isHorizontalStart) {
                        path = `M ${x1} ${y1} H ${midX} V ${y2} H ${x2}`;
                    } else {
                        path = `M ${x1} ${y1} V ${midY} H ${x2} V ${y2}`;
                    }
                }
                
                return path;
            },
            
            createConnectorGeneric(startObj, startSide, startType, endObj, endSide, endType, section) {
                const id = this.nextId++;
                const lineColor = this.lineColorSelect?.value || 'lightGrey';
                const arrowColor = this.arrowColorSelect?.value || 'lightGrey';
                const arrowType = this.arrowSelect?.value || 'end';
                const arrowStyle = this.arrowStyleSelect?.value || 'triangle';
                const arrowSize = parseInt(this.arrowSizeSlider?.value) || 6;
                const routing = this.routingSelect?.value || 'auto';
                
                const connector = {
                    id,
                    startId: startObj.id,
                    startSide,
                    startType,
                    endId: endObj.id,
                    endSide,
                    endType,
                    section,
                    lineColor,
                    arrowColor,
                    arrowType,
                    arrowStyle,
                    arrowSize,
                    routing,
                    elements: {}
                };
                
                // Create SVG elements
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'flowchart-connector');
                group.setAttribute('data-connector-id', id);
                
                const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                hitArea.setAttribute('class', 'flowchart-connector-hitarea');
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'flowchart-connector-path');
                
                group.appendChild(hitArea);
                group.appendChild(path);
                
                const containerGroup = section === 'top' ? this.topConnectorGroup : this.bottomConnectorGroup;
                containerGroup.appendChild(group);
                
                connector.elements = { group, path, hitArea };
                this.connectors.push(connector);
                
                // Update rendering
                this.updateConnectorRendering(connector);
                
                // Add click handler
                hitArea.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    this.selectConnector(connector);
                });
                path.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    this.selectConnector(connector);
                });
                
                this.updateConnectorList();
                
                if (window.ScoreManager) ScoreManager.markDirty();
                
                console.log(`Connector created: ${id}`);
                return connector;
            },
            
            getObjectById(id, type) {
                if (type === 'svg') {
                    return SVGElementManager.elements.find(el => el.id === id);
                } else if (type === 'curve') {
                    return CurveMaker.curves.find(c => c.id === id);
                }
                return null;
            },
            
            updateConnectorRendering(connector) {
                const startObj = this.getObjectById(connector.startId, connector.startType);
                const endObj = this.getObjectById(connector.endId, connector.endType);
                
                if (!startObj || !endObj) return;
                
                const startPoint = this.getNodePosition(startObj, connector.startSide, connector.startType);
                const endPoint = this.getNodePosition(endObj, connector.endSide, connector.endType);
                
                const pathD = this.calculatePath(
                    startPoint.x, startPoint.y,
                    endPoint.x, endPoint.y,
                    connector.startSide, connector.endSide, connector.routing
                );
                
                connector.elements.path.setAttribute('d', pathD);
                connector.elements.hitArea.setAttribute('d', pathD);
                
                // Apply line color
                connector.elements.path.setAttribute('stroke', this.colorMap[connector.lineColor] || '#aaa');
                
                // Apply arrow markers
                this.applyArrowMarkers(connector);
            },
            
            applyArrowMarkers(connector) {
                const path = connector.elements.path;
                const { arrowColor, arrowStyle, arrowSize, arrowType } = connector;
                
                path.removeAttribute('marker-start');
                path.removeAttribute('marker-end');
                
                const markerBase = `arrow-${arrowColor}-${arrowStyle}-${arrowSize}`;
                
                switch (arrowType) {
                    case 'end':
                        path.setAttribute('marker-end', `url(#arrow-end-${arrowColor}-${arrowStyle}-${arrowSize})`);
                        break;
                    case 'start':
                        path.setAttribute('marker-start', `url(#arrow-start-${arrowColor}-${arrowStyle}-${arrowSize})`);
                        break;
                    case 'both':
                        path.setAttribute('marker-start', `url(#arrow-start-${arrowColor}-${arrowStyle}-${arrowSize})`);
                        path.setAttribute('marker-end', `url(#arrow-end-${arrowColor}-${arrowStyle}-${arrowSize})`);
                        break;
                    case 'none':
                        break;
                }
            },
            
            selectConnector(connector) {
                this.deselectAll();
                this.selectedConnector = connector;
                connector.elements.group.classList.add('selected');
                
                // Update UI
                if (this.arrowSelect) this.arrowSelect.value = connector.arrowType;
                if (this.arrowStyleSelect) this.arrowStyleSelect.value = connector.arrowStyle;
                if (this.arrowSizeSlider) {
                    this.arrowSizeSlider.value = connector.arrowSize;
                    this.arrowSizeValue.textContent = connector.arrowSize;
                }
                if (this.lineColorSelect) this.lineColorSelect.value = connector.lineColor;
                if (this.arrowColorSelect) this.arrowColorSelect.value = connector.arrowColor;
                if (this.routingSelect) this.routingSelect.value = connector.routing;
                
                this.updateConnectorList();
            },
            
            deselectAll() {
                if (this.selectedConnector) {
                    this.selectedConnector.elements.group.classList.remove('selected');
                }
                this.selectedConnector = null;
                this.updateConnectorList();
            },
            
            updateSelectedProperty(prop, value) {
                if (!this.selectedConnector) return;
                this.selectedConnector[prop] = value;
                this.updateConnectorRendering(this.selectedConnector);
                if (window.ScoreManager) ScoreManager.markDirty();
            },
            
            deleteSelected() {
                if (!this.selectedConnector) return;
                
                this.selectedConnector.elements.group.remove();
                const idx = this.connectors.indexOf(this.selectedConnector);
                if (idx > -1) this.connectors.splice(idx, 1);
                
                this.selectedConnector = null;
                this.updateConnectorList();
                if (window.ScoreManager) ScoreManager.markDirty();
            },
            
            updateConnectorList() {
                if (!this.connectorList) return;
                this.connectorList.innerHTML = '';
                
                this.connectors.forEach(conn => {
                    const item = document.createElement('div');
                    item.className = 'connector-item' + (conn === this.selectedConnector ? ' selected' : '');
                    item.textContent = `Connector ${conn.id}`;
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectConnector(conn);
                    });
                    this.connectorList.appendChild(item);
                });
            },
            
            updateAllConnectors() {
                this.connectors.forEach(conn => this.updateConnectorRendering(conn));
                // Also refresh connection nodes if in connect mode
                if (this.connectMode) {
                    this.updateConnectionNodes();
                }
            },
            
            // Show/hide connectors based on current page
            updateVisibility() {
                if (!window.GraphicTimeline) return;
                
                const topPage = GraphicTimeline.currentTopPage;
                const bottomPage = GraphicTimeline.currentBottomPage;
                
                this.connectors.forEach(conn => {
                    if (!conn.elements || !conn.elements.group) return;
                    
                    // Get the page of the connector's start object
                    const startObj = this.getObjectById(conn.startId, conn.startType);
                    if (!startObj) {
                        conn.elements.group.style.display = 'none';
                        return;
                    }
                    
                    const objPage = startObj.page || 0;
                    const objSection = startObj.section || conn.section || 'top';
                    
                    // Check if connector's page matches current visible pages
                    const visible = (objSection === 'top' && objPage === topPage) ||
                                   (objSection === 'bottom' && objPage === bottomPage);
                    conn.elements.group.style.display = visible ? '' : 'none';
                });
            },
            
            exportData() {
                return this.connectors.map(conn => ({
                    id: conn.id,
                    startId: conn.startId,
                    startSide: conn.startSide,
                    startType: conn.startType,
                    endId: conn.endId,
                    endSide: conn.endSide,
                    endType: conn.endType,
                    section: conn.section,
                    lineColor: conn.lineColor,
                    arrowColor: conn.arrowColor,
                    arrowType: conn.arrowType,
                    arrowStyle: conn.arrowStyle,
                    arrowSize: conn.arrowSize,
                    routing: conn.routing
                }));
            },
            
            importData(data) {
                if (!data || !Array.isArray(data)) return;
                
                // Clear existing
                this.connectors.forEach(conn => conn.elements.group.remove());
                this.connectors = [];
                this.selectedConnector = null;
                
                // Recreate connectors
                data.forEach(connData => {
                    // Handle legacy data format
                    const startType = connData.startType || 'svg';
                    const endType = connData.endType || 'svg';
                    const startId = connData.startId !== undefined ? connData.startId : connData.startElementId;
                    const endId = connData.endId !== undefined ? connData.endId : connData.endElementId;
                    
                    const startObj = this.getObjectById(startId, startType);
                    const endObj = this.getObjectById(endId, endType);
                    
                    if (!startObj || !endObj) return;
                    
                    const connector = {
                        id: connData.id,
                        startId: startId,
                        startSide: connData.startSide,
                        startType: startType,
                        endId: endId,
                        endSide: connData.endSide,
                        endType: endType,
                        section: connData.section,
                        lineColor: connData.lineColor || connData.color || 'lightGrey',
                        arrowColor: connData.arrowColor || connData.color || 'lightGrey',
                        arrowType: connData.arrowType || 'end',
                        arrowStyle: connData.arrowStyle || 'triangle',
                        arrowSize: connData.arrowSize || 6,
                        routing: connData.routing || 'auto',
                        elements: {}
                    };
                    
                    // Create SVG elements
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.setAttribute('class', 'flowchart-connector');
                    group.setAttribute('data-connector-id', connector.id);
                    
                    const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    hitArea.setAttribute('class', 'flowchart-connector-hitarea');
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('class', 'flowchart-connector-path');
                    
                    group.appendChild(hitArea);
                    group.appendChild(path);
                    
                    const containerGroup = connector.section === 'top' ? this.topConnectorGroup : this.bottomConnectorGroup;
                    containerGroup.appendChild(group);
                    
                    connector.elements = { group, path, hitArea };
                    this.connectors.push(connector);
                    
                    // Update rendering
                    this.updateConnectorRendering(connector);
                    
                    // Add click handler
                    hitArea.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        this.selectConnector(connector);
                    });
                    path.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        this.selectConnector(connector);
                    });
                    
                    if (connData.id >= this.nextId) {
                        this.nextId = connData.id + 1;
                    }
                });
                
                this.updateConnectorList();
                console.log(`FlowchartConnector: Imported ${this.connectors.length} connectors`);
            }
        };
        
        // Staff Cursors System - Animated vertical lines for each staff
        // Uses server-synced animation timeline for exact pixel sync across all clients
        const StaffCursors = {
            cursors: [],           // Array of cursor objects for each staff
            staffDividers: [],     // Array of horizontal staff divider line objects
            staffHeaders: [],      // Array of staff header SVG elements
            staffLabels: [],       // Array of staff label text elements
            staffConnector: null,  // Vertical line connecting all staff headers
            staffHeaderGroup: null, // Group containing all staff header elements
            scoreTopEl: null,
            scoreBottomEl: null,
            initialized: false,
            
            // Cursor colors matching the CSS variables
            colors: [
                'rgb(153,255,0)',      // Staff 1: Lime Green
                'rgb(255, 21, 160)',   // Staff 2: Neon Magenta
                'rgba(56,126,211,255)', // Staff 3: Bright Blue
                'rgba(240,75,0,255)'   // Staff 4: Bright Orange
            ],
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Create horizontal staff dividers (3 lines dividing into 4 sections)
                this.createStaffDividers();
                
                // Create cursors for each of the 4 staves
                for (let i = 0; i < 4; i++) {
                    const cursor = this.createCursor(i);
                    this.cursors.push(cursor);
                }
                
                // Create staff headers (clefs, labels, connector line)
                this.createStaffHeaders();
                
                // Listen for score state from server
                ClockSync.socket.on('scoreState', (data) => {
                    this.onScoreState(data);
                });
                
                // Hook into AnimationEngine
                const originalOnDraw = AnimationEngine.onDraw;
                AnimationEngine.onDraw = (frameNumber, elapsedMs) => {
                    if (originalOnDraw) originalOnDraw(frameNumber, elapsedMs);
                    this.update();
                };
                
                // Update cursor dimensions on window resize
                window.addEventListener('resize', () => {
                    this.updateCursorDimensions();
                    this.updateStaffHeaders();
                });
                
                // Log initial dimensions
                this.updateCursorDimensions();
                
                this.initialized = true;
            },
            
            // Called when we receive score state from server
            onScoreState(data) {
                ScoreTime.isPlaying = data.isPlaying;
                ScoreTime.currentScoreTimeMs = data.currentScoreTimeMs;
                ScoreTime.scoreTimeOffset = data.scoreTimeOffset;
                serverTempoHistory = data.tempoHistory;
                
                // Update local tempo variables to match server
                if (serverTempoHistory.length > 0) {
                    const latestTempo = serverTempoHistory[serverTempoHistory.length - 1];
                    beatsPerMinute = latestTempo.bpm;
                    beatsPerPage = latestTempo.beatsPerPage;
                }
                
                // Redraw graphic timeline when tempo/beatsPerPage changes
                if (window.GraphicTimeline) {
                    GraphicTimeline.renderTicks();
                }
                
                // Update UI button state
                if (window.CursorControls && CursorControls.goStopBtn) {
                    CursorControls.goStopBtn.textContent = ScoreTime.isPlaying ? 'Stop' : 'Go';
                    CursorControls.goStopBtn.classList.toggle('active', ScoreTime.isPlaying);
                }
                
                // Start animation engine if not running (always runs for rendering)
                if (!AnimationEngine.running) {
                    AnimationEngine.start(ClockSync.now());
                }
                
                console.log(`Score state received - Playing: ${data.isPlaying}, ScoreTime: ${data.currentScoreTimeMs}ms`);
            },
            
            // Called when tempo changes - adds to local tempo history copy
            onTempoChange(newBpm, newBeatsPerPage, scoreTimeMs) {
                // Add to local tempo history with score time
                serverTempoHistory.push({
                    scoreTimeMs: scoreTimeMs,
                    bpm: newBpm,
                    beatsPerPage: newBeatsPerPage
                });
            },
            
            // Calculate total pages traveled from tempo history using score time
            // Returns a value where 1.0 = one full page width (100%)
            calculateTotalPages(scoreTimeMs) {
                if (serverTempoHistory.length === 0) {
                    return 0;
                }
                
                let totalPages = 0;
                
                for (let i = 0; i < serverTempoHistory.length; i++) {
                    const segment = serverTempoHistory[i];
                    const segmentStart = segment.scoreTimeMs;
                    
                    // Determine segment end time
                    let segmentEnd;
                    if (i < serverTempoHistory.length - 1) {
                        segmentEnd = serverTempoHistory[i + 1].scoreTimeMs;
                    } else {
                        segmentEnd = scoreTimeMs;
                    }
                    
                    // Calculate duration of this segment
                    const segmentDuration = segmentEnd - segmentStart;
                    
                    if (segmentDuration > 0) {
                        // Calculate pages per ms for this segment
                        // pagesPerMs = beatsPerMs / beatsPerPage = bpm / (60000 * beatsPerPage)
                        const pagesPerMs = segment.bpm / (60000 * segment.beatsPerPage);
                        
                        // Add pages traveled in this segment
                        totalPages += segmentDuration * pagesPerMs;
                    }
                }
                
                return totalPages;
            },
            
            // Timeline height in pixels - staves start below this
            timelineHeight: 8,
            
            // Create 3 horizontal staff dividers to divide page into 4 vertical sections
            createStaffDividers() {
                const scoreHeight = this.scoreTopEl.clientHeight;
                const availableHeight = scoreHeight - this.timelineHeight;
                const sectionHeight = availableHeight / 4;
                
                // Create 3 staff dividers (at bottom of sections 1, 2, and 3)
                for (let i = 1; i <= 3; i++) {
                    const yPosition = this.timelineHeight + (i * sectionHeight);
                    
                    // Create line for ScoreTop
                    const lineTop = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    lineTop.setAttribute('x1', '0');
                    lineTop.setAttribute('y1', yPosition);
                    lineTop.setAttribute('x2', '100%');
                    lineTop.setAttribute('y2', yPosition);
                    lineTop.setAttribute('stroke', '#999');
                    lineTop.setAttribute('stroke-width', '1');
                    
                    // Create line for ScoreBottom
                    const lineBottom = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    lineBottom.setAttribute('x1', '0');
                    lineBottom.setAttribute('y1', yPosition);
                    lineBottom.setAttribute('x2', '100%');
                    lineBottom.setAttribute('y2', yPosition);
                    lineBottom.setAttribute('stroke', '#999');
                    lineBottom.setAttribute('stroke-width', '1');
                    
                    // Add to SVG elements
                    this.scoreTopEl.appendChild(lineTop);
                    this.scoreBottomEl.appendChild(lineBottom);
                    
                    this.staffDividers.push({
                        sectionIndex: i,
                        topEl: lineTop,
                        bottomEl: lineBottom
                    });
                }
            },
            
            // Update staff divider positions on resize
            updateStaffDividers() {
                const scoreHeight = this.scoreTopEl.clientHeight;
                const availableHeight = scoreHeight - this.timelineHeight;
                const sectionHeight = availableHeight / 4;
                
                this.staffDividers.forEach((line) => {
                    const yPosition = this.timelineHeight + (line.sectionIndex * sectionHeight);
                    [line.topEl, line.bottomEl].forEach(el => {
                        el.setAttribute('y1', yPosition);
                        el.setAttribute('y2', yPosition);
                    });
                });
            },
            
            createCursor(staffIndex) {
                // Create SVG rect elements for both ScoreTop and ScoreBottom
                const cursorTop = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const cursorBottom = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                
                // Get the score height to calculate cursor dimensions
                // Each cursor is on its own horizontal stripe (1/4 of available height)
                const scoreHeight = this.scoreTopEl.clientHeight;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                const yPosition = this.timelineHeight + (staffIndex * staffHeight);
                
                // Configure cursor appearance - 3 pixels wide, full staff height
                [cursorTop, cursorBottom].forEach(cursor => {
                    cursor.setAttribute('width', '3');
                    cursor.setAttribute('y', yPosition);
                    cursor.setAttribute('height', staffHeight);
                    cursor.setAttribute('fill', this.colors[staffIndex]);
                    cursor.setAttribute('x', '0');
                });
                
                // Create meter outline rectangles (empty outline that appears when curve is encountered)
                const meterOutlineTop = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const meterOutlineBottom = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                
                [meterOutlineTop, meterOutlineBottom].forEach(outline => {
                    outline.setAttribute('width', '8');
                    outline.setAttribute('y', yPosition);
                    outline.setAttribute('height', staffHeight);
                    outline.setAttribute('fill', 'none');
                    outline.setAttribute('stroke', this.colors[staffIndex]);
                    outline.setAttribute('stroke-width', '1.5');
                    outline.setAttribute('opacity', '0.8');
                    outline.setAttribute('x', '-11');
                    outline.style.display = 'none';
                });
                
                // Create curve-following rectangles (fill inside the meter)
                const curveFollowerTop = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const curveFollowerBottom = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                
                [curveFollowerTop, curveFollowerBottom].forEach(follower => {
                    follower.setAttribute('width', '8');
                    follower.setAttribute('y', yPosition);
                    follower.setAttribute('height', staffHeight);
                    follower.setAttribute('fill', this.colors[staffIndex]);
                    follower.setAttribute('stroke', 'none');
                    follower.setAttribute('opacity', '0.65');
                    follower.setAttribute('x', '-11'); // 8px width + 3px gap left of cursor
                    follower.style.display = 'none';
                });
                
                // Add to SVG elements (outline first, then fill on top)
                this.scoreTopEl.appendChild(meterOutlineTop);
                this.scoreBottomEl.appendChild(meterOutlineBottom);
                this.scoreTopEl.appendChild(cursorTop);
                this.scoreBottomEl.appendChild(cursorBottom);
                this.scoreTopEl.appendChild(curveFollowerTop);
                this.scoreBottomEl.appendChild(curveFollowerBottom);
                
                return {
                    staffIndex: staffIndex,
                    topEl: cursorTop,
                    bottomEl: cursorBottom,
                    curveFollowerTop: curveFollowerTop,
                    curveFollowerBottom: curveFollowerBottom,
                    meterOutlineTop: meterOutlineTop,
                    meterOutlineBottom: meterOutlineBottom,
                    currentSection: 'top',  // 'top' or 'bottom'
                    xPosition: 0,           // Current x position in pixels
                    currentCurveValue: null // Current normalized Y value from curve
                };
            },
            
            // Update cursor dimensions on resize
            updateCursorDimensions() {
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                
                console.log(`ScoreTop dimensions: ${scoreWidth}px x ${scoreHeight}px, Staff cursor height: ${staffHeight.toFixed(1)}px`);
                
                this.cursors.forEach((cursor, staffIndex) => {
                    const yPosition = this.timelineHeight + (staffIndex * staffHeight);
                    [cursor.topEl, cursor.bottomEl].forEach(el => {
                        el.setAttribute('y', yPosition);
                        el.setAttribute('height', staffHeight);
                    });
                    // Update curve followers and meter outlines too
                    [cursor.curveFollowerTop, cursor.curveFollowerBottom].forEach(el => {
                        el.setAttribute('y', yPosition);
                        el.setAttribute('height', staffHeight);
                    });
                    [cursor.meterOutlineTop, cursor.meterOutlineBottom].forEach(el => {
                        el.setAttribute('y', yPosition);
                        el.setAttribute('height', staffHeight);
                    });
                });
                
                // Also update staff dividers on resize
                this.updateStaffDividers();
            },
            
            // Staff header SVG paths
            staffHeaderPaths: [
                '/lilypond_code/violin1_staff_label.cropped.svg',
                '/lilypond_code/violin2_staff_header.cropped.svg',
                '/lilypond_code/viola_staff_header.cropped.svg',
                '/lilypond_code/cello_staff_header.cropped.svg'
            ],
            staffLabelTexts: ['violin I', 'violin II', 'viola', 'cello'],
            
            // Create staff headers with clefs, labels, and connector line
            createStaffHeaders() {
                // Create a group to hold all staff header elements
                this.staffHeaderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.staffHeaderGroup.setAttribute('id', 'staff-headers-group');
                this.scoreTopEl.appendChild(this.staffHeaderGroup);
                
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                
                // Calculate X position: lead-in percentage of page width
                // Timeline 0 is at leadInPixels from left edge
                const secondsPerPage = (60 / beatsPerMinute) * beatsPerPage;
                const leadInFraction = leadInSeconds / secondsPerPage;
                const leadInPixels = leadInFraction * scoreWidth;
                
                // SVG header dimensions (1/3 of staff height)
                const headerHeight = staffHeight / 3;
                // SVG viewBox: width=5.8450, height=7.2360 => aspect ratio ~0.808
                // Staff lines in SVG: x1=0.0250, viewBox starts at x=-0.7500
                // So staff line start is at 0.0250 - (-0.7500) = 0.775 from SVG left edge
                // As fraction of viewBox width: 0.775 / 5.8450 = 0.1326
                const svgAspectRatio = 5.8450 / 7.2360;
                const headerWidth = headerHeight * svgAspectRatio;
                const staffLineStartFraction = 0.775 / 5.8450; // ~0.1326
                
                // Right edge of SVGs should be 3px before timeline 0
                const svgRightEdge = leadInPixels - 3;
                const svgLeftEdge = svgRightEdge - headerWidth;
                
                // Connector line X: at the staff line start X coordinate
                const connectorX = svgLeftEdge + (staffLineStartFraction * headerWidth);
                
                // Labels: right-justified, 8px left of connector line (3 + 5 extra)
                const labelRightEdge = connectorX - 8;
                
                // Font size scales with staff height (base 11px at ~100px staff height)
                const fontSize = Math.max(8, staffHeight * 0.11);
                
                console.log(`Staff headers: leadInPixels=${leadInPixels.toFixed(1)}, svgRightEdge=${svgRightEdge.toFixed(1)}, headerHeight=${headerHeight.toFixed(1)}, connectorX=${connectorX.toFixed(1)}`);
                
                // Calculate Y positions for connector line
                // SVG viewBox: y starts at -1.5930, top staff line at y=0.0250, bottom at y=4.0250
                // Top staff line offset from viewBox top: 0.0250 - (-1.5930) = 1.618
                // Bottom staff line offset: 4.0250 - (-1.5930) = 5.618
                // As fractions of viewBox height (7.2360):
                const topStaffLineFraction = 1.618 / 7.2360;    // ~0.2236
                const bottomStaffLineFraction = 5.618 / 7.2360; // ~0.7766
                
                const headerYOffset = (staffHeight - headerHeight) / 2;
                
                // V1 top staff line Y position
                const v1HeaderY = this.timelineHeight + headerYOffset;
                const v1TopStaffLine = v1HeaderY + (topStaffLineFraction * headerHeight);
                
                // Cello bottom staff line Y position
                const celloHeaderY = this.timelineHeight + (3 * staffHeight) + headerYOffset;
                const celloBottomStaffLine = celloHeaderY + (bottomStaffLineFraction * headerHeight);
                
                // Create vertical connector line (1px width)
                this.staffConnector = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                this.staffConnector.setAttribute('x1', connectorX);
                this.staffConnector.setAttribute('x2', connectorX);
                this.staffConnector.setAttribute('y1', v1TopStaffLine);
                this.staffConnector.setAttribute('y2', celloBottomStaffLine);
                this.staffConnector.setAttribute('stroke', '#000');
                this.staffConnector.setAttribute('stroke-width', '1');
                this.staffHeaderGroup.appendChild(this.staffConnector);
                
                // Create staff headers and labels for each track
                for (let i = 0; i < 4; i++) {
                    const yPosition = this.timelineHeight + (i * staffHeight);
                    
                    // Create label text (right-justified, 8px left of connector)
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', labelRightEdge);
                    label.setAttribute('y', yPosition + staffHeight / 2);
                    label.setAttribute('dominant-baseline', 'middle');
                    label.setAttribute('text-anchor', 'end');
                    label.setAttribute('font-family', 'Futura, sans-serif');
                    label.setAttribute('font-size', `${fontSize}px`);
                    label.setAttribute('fill', '#000');
                    label.textContent = this.staffLabelTexts[i];
                    this.staffHeaderGroup.appendChild(label);
                    this.staffLabels.push(label);
                    
                    // Create image element for the clef SVG (right edge at svgRightEdge)
                    const header = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    header.setAttribute('href', this.staffHeaderPaths[i]);
                    header.setAttribute('x', svgLeftEdge);
                    header.setAttribute('y', yPosition + headerYOffset);
                    header.setAttribute('height', headerHeight);
                    header.setAttribute('preserveAspectRatio', 'xMaxYMid meet');
                    this.staffHeaderGroup.appendChild(header);
                    this.staffHeaders.push(header);
                }
            },
            
            // Update staff headers on resize
            updateStaffHeaders() {
                if (!this.staffHeaderGroup) return;
                
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                
                // Recalculate positions based on lead-in
                const secondsPerPage = (60 / beatsPerMinute) * beatsPerPage;
                const leadInFraction = leadInSeconds / secondsPerPage;
                const leadInPixels = leadInFraction * scoreWidth;
                
                // SVG header dimensions (1/3 of staff height)
                const headerHeight = staffHeight / 3;
                const svgAspectRatio = 5.8450 / 7.2360;
                const headerWidth = headerHeight * svgAspectRatio;
                const staffLineStartFraction = 0.775 / 5.8450;
                
                // Right edge of SVGs should be 3px before timeline 0
                const svgRightEdge = leadInPixels - 3;
                const svgLeftEdge = svgRightEdge - headerWidth;
                
                // Connector line X: at the staff line start X coordinate
                const connectorX = svgLeftEdge + (staffLineStartFraction * headerWidth);
                
                // Labels: right-justified, 8px left of connector line
                const labelRightEdge = connectorX - 8;
                
                // Font size scales with staff height
                const fontSize = Math.max(8, staffHeight * 0.11);
                
                // Y positions for connector line (using SVG staff line fractions)
                const topStaffLineFraction = 1.618 / 7.2360;
                const bottomStaffLineFraction = 5.618 / 7.2360;
                const headerYOffset = (staffHeight - headerHeight) / 2;
                
                const v1HeaderY = this.timelineHeight + headerYOffset;
                const v1TopStaffLine = v1HeaderY + (topStaffLineFraction * headerHeight);
                
                const celloHeaderY = this.timelineHeight + (3 * staffHeight) + headerYOffset;
                const celloBottomStaffLine = celloHeaderY + (bottomStaffLineFraction * headerHeight);
                
                // Update connector line
                if (this.staffConnector) {
                    this.staffConnector.setAttribute('x1', connectorX);
                    this.staffConnector.setAttribute('x2', connectorX);
                    this.staffConnector.setAttribute('y1', v1TopStaffLine);
                    this.staffConnector.setAttribute('y2', celloBottomStaffLine);
                }
                
                // Update each header
                this.staffHeaders.forEach((header, i) => {
                    const yPosition = this.timelineHeight + (i * staffHeight);
                    header.setAttribute('x', svgLeftEdge);
                    header.setAttribute('y', yPosition + headerYOffset);
                    header.setAttribute('height', headerHeight);
                });
                
                // Update each label
                this.staffLabels.forEach((label, i) => {
                    const yPosition = this.timelineHeight + (i * staffHeight);
                    label.setAttribute('x', labelRightEdge);
                    label.setAttribute('font-size', `${fontSize}px`);
                    label.setAttribute('y', yPosition + staffHeight / 2);
                });
            },
            
            update() {
                // Get current score time (not clock time)
                const currentScoreTimeMs = ScoreTime.now();
                
                // Calculate total pages traveled using tempo history and score time
                // 1 page = 100% of one ScoreTop or ScoreBottom width
                const totalPagesTraveled = this.calculateTotalPages(currentScoreTimeMs);
                
                // Total cycle is 2 pages (top + bottom)
                // Position within cycle: 0-1 = top, 1-2 = bottom
                const positionInCycle = totalPagesTraveled % 2;
                
                // Convert to percentage (0-100%)
                let xPercent, inTop, inBottom;
                
                if (positionInCycle < 1) {
                    // In ScoreTop section
                    xPercent = positionInCycle * 100;
                    inTop = true;
                    inBottom = false;
                } else {
                    // In ScoreBottom section
                    xPercent = (positionInCycle - 1) * 100;
                    inTop = false;
                    inBottom = true;
                }
                
                // Get score width for pixel calculations
                const scoreWidth = this.scoreTopEl.clientWidth;
                const xPixel = (xPercent / 100) * scoreWidth;
                const currentSection = inTop ? 'top' : 'bottom';
                // Convert score time to display time (subtract lead-in)
                // ScoreTime starts at 0 when playback begins (during lead-in)
                // Display time 0 = first beat (after lead-in)
                const currentDisplayTimeSec = (currentScoreTimeMs / 1000) - leadInSeconds;
                
                // Update each cursor using percentage positioning
                this.cursors.forEach((cursor, staffIndex) => {
                    // Set x position as percentage
                    cursor.topEl.setAttribute('x', `${xPercent}%`);
                    cursor.bottomEl.setAttribute('x', `${xPercent}%`);
                    
                    // Show/hide based on which section is active
                    cursor.topEl.style.display = inTop ? 'block' : 'none';
                    cursor.bottomEl.style.display = inBottom ? 'block' : 'none';
                    
                    // Update curve follower for this track
                    this.updateCurveFollower(cursor, staffIndex, xPixel, xPercent, currentSection, currentDisplayTimeSec);
                });
            },
            
            // Update curve follower rectangle based on curve intersection
            // TIMECODE-BASED SYSTEM: O(1) lookup using time-indexed samples
            updateCurveFollower(cursor, staffIndex, xPixel, xPercent, section, currentTimeSec) {
                const follower = section === 'top' ? cursor.curveFollowerTop : cursor.curveFollowerBottom;
                const otherFollower = section === 'top' ? cursor.curveFollowerBottom : cursor.curveFollowerTop;
                const meterOutline = section === 'top' ? cursor.meterOutlineTop : cursor.meterOutlineBottom;
                const otherMeterOutline = section === 'top' ? cursor.meterOutlineBottom : cursor.meterOutlineTop;
                
                // Hide the follower and meter on the inactive section
                otherFollower.style.display = 'none';
                otherMeterOutline.style.display = 'none';
                
                // Check if there's a curve at this position for this track
                const gTrack = window.GTrackSystem ? GTrackSystem.getGTrack(staffIndex) : null;
                if (!gTrack) {
                    follower.style.display = 'none';
                    meterOutline.style.display = 'none';
                    cursor.currentCurveValue = null;
                    return;
                }
                
                // Find curve that contains current time and get O(1) sample lookup
                let foundCurve = null;
                let normalizedY = null;
                
                for (const item of gTrack.graphicItems) {
                    if (item.type !== 'curve' || !item.curveData) continue;
                    
                    const { startTime, endTime, sampleInterval, samples } = item.curveData;
                    
                    // Check if current time is within curve's time range
                    if (currentTimeSec >= startTime && currentTimeSec <= endTime) {
                        // O(1) lookup: calculate array index from time
                        const timeOffset = currentTimeSec - startTime;
                        const sampleIndex = Math.floor(timeOffset / sampleInterval);
                        
                        if (sampleIndex >= 0 && sampleIndex < samples.length) {
                            foundCurve = item;
                            normalizedY = samples[sampleIndex];
                            break;
                        }
                    }
                }
                
                if (!foundCurve || normalizedY === null) {
                    follower.style.display = 'none';
                    meterOutline.style.display = 'none';
                    cursor.currentCurveValue = null;
                    return;
                }
                
                // Show and position the meter outline (full height empty rectangle)
                meterOutline.style.display = 'block';
                meterOutline.setAttribute('x', `calc(${xPercent}% - 11px)`);
                
                // Show and position the curve follower (fill inside meter)
                follower.style.display = 'block';
                follower.setAttribute('x', `calc(${xPercent}% - 11px)`);
                
                // Get track dimensions for fill calculation
                const scoreHeight = this.scoreTopEl.clientHeight;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                const yPosition = this.timelineHeight + (staffIndex * staffHeight);
                
                // Calculate fill based on normalized Y value and fill mode
                // normalizedY: 0 = bottom, 1 = top
                const curveColor = foundCurve.color ? (ColorMap[foundCurve.color] || foundCurve.color) : this.colors[staffIndex];
                const fillMode = foundCurve.fillMode || 'line';
                
                let fillY, fillHeight;
                if (fillMode === 'top') {
                    // Fill from top down to curve value (inverse of bottom fill)
                    // When normalizedY = 1, fill is 0 (curve at top, no fill above)
                    // When normalizedY = 0, fill is full height (curve at bottom, fill entire top)
                    fillHeight = (1 - normalizedY) * staffHeight;
                    fillY = yPosition; // Start from top
                } else {
                    // Fill from bottom up to curve value (default behavior)
                    fillHeight = normalizedY * staffHeight;
                    fillY = yPosition + staffHeight - fillHeight;
                }
                
                // Update follower to show fill
                follower.setAttribute('y', fillY);
                follower.setAttribute('height', fillHeight);
                follower.setAttribute('fill', curveColor);
                
                // Update meter outline to match curve color
                meterOutline.setAttribute('stroke', curveColor);
                
                // Store current curve value for external use
                cursor.currentCurveValue = normalizedY;
            },
            
            // Get current position info for a specific staff (returns percentage)
            getPosition(staffIndex) {
                if (staffIndex >= 0 && staffIndex < this.cursors.length) {
                    const cursor = this.cursors[staffIndex];
                    const xAttr = cursor.topEl.getAttribute('x');
                    // Parse percentage value
                    const xPercent = parseFloat(xAttr.replace('%', ''));
                    return {
                        xPercent: xPercent,
                        section: cursor.topEl.style.display !== 'none' ? 'top' : 'bottom'
                    };
                }
                return null;
            }
        };
        
        // Initialize staff cursors after DOM is ready
        StaffCursors.init();
        window.StaffCursors = StaffCursors;
        
        // Initialize SVG Element Manager
        SVGElementManager.init();
        window.SVGElementManager = SVGElementManager;
        
        // Initialize Flowchart Connector
        FlowchartConnector.init();
        window.FlowchartConnector = FlowchartConnector;
        
        // Score Zoom System with Pan
        const ScoreZoom = {
            zoomLevel: 100,
            minZoom: 50,
            maxZoom: 500,
            zoomStep: 10,
            panX: 0,
            panY: 0,
            isPanning: false,
            panStartX: 0,
            panStartY: 0,
            panStartPanX: 0,
            panStartPanY: 0,
            
            init() {
                this.slider = document.getElementById('scoreZoomSlider');
                this.valueDisplay = document.getElementById('scoreZoomValue');
                this.scoreContainer = document.getElementById('ScoreContainer');
                this.resetBtn = document.getElementById('zoomResetBtn');
                
                // Slider event
                this.slider.addEventListener('input', () => {
                    this.setZoom(parseInt(this.slider.value));
                });
                
                // Double-click slider to reset to 100%
                this.slider.addEventListener('dblclick', () => {
                    this.resetZoom();
                });
                
                // Reset button
                if (this.resetBtn) {
                    this.resetBtn.addEventListener('click', () => this.resetZoom());
                }
                
                // Keyboard shortcut: press 0 to reset zoom (when not in input field)
                document.addEventListener('keydown', (e) => {
                    if (e.key === '0' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                        const activeEl = document.activeElement;
                        const isInput = activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable;
                        if (!isInput) {
                            e.preventDefault();
                            this.resetZoom();
                        }
                    }
                });
                
                // Ctrl + Alt + scroll wheel zoom (avoid browser zoom conflict)
                this.scoreContainer.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
                
                // Middle mouse button or Alt+left click to pan
                this.scoreContainer.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                // Double-click to reset pan
                this.scoreContainer.addEventListener('dblclick', (e) => {
                    if (e.altKey) {
                        this.resetPan();
                    }
                });
                
                console.log('ScoreZoom initialized (Ctrl+Alt+scroll to zoom, Alt+drag or middle-click drag to pan, Alt+double-click to reset pan, 0 key or double-click slider to reset zoom)');
            },
            
            handleWheel(e) {
                // Require both Ctrl and Alt to avoid browser zoom conflict
                if (!e.ctrlKey || !e.altKey) return;
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? -this.zoomStep : this.zoomStep;
                const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoomLevel + delta));
                this.setZoom(newZoom);
            },
            
            handleMouseDown(e) {
                // Alt + left click OR middle mouse button to pan
                if ((e.altKey && e.button === 0) || e.button === 1) {
                    e.preventDefault();
                    this.isPanning = true;
                    this.panStartX = e.clientX;
                    this.panStartY = e.clientY;
                    this.panStartPanX = this.panX;
                    this.panStartPanY = this.panY;
                    this.scoreContainer.style.cursor = 'grabbing';
                }
            },
            
            handleMouseMove(e) {
                if (!this.isPanning) return;
                
                const dx = e.clientX - this.panStartX;
                const dy = e.clientY - this.panStartY;
                
                this.panX = this.panStartPanX + dx;
                this.panY = this.panStartPanY + dy;
                
                this.applyTransform();
            },
            
            handleMouseUp(e) {
                if (this.isPanning) {
                    this.isPanning = false;
                    this.scoreContainer.style.cursor = '';
                }
            },
            
            resetPan() {
                this.panX = 0;
                this.panY = 0;
                this.applyTransform();
            },
            
            resetZoom() {
                this.setZoom(100);
            },
            
            setZoom(level) {
                this.zoomLevel = level;
                this.slider.value = level;
                this.valueDisplay.textContent = level + '%';
                this.applyTransform();
            },
            
            applyTransform() {
                const scale = this.zoomLevel / 100;
                this.scoreContainer.style.transformOrigin = 'center center';
                this.scoreContainer.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${scale})`;
            },
            
            getZoom() {
                return this.zoomLevel / 100;
            }
        };
        
        ScoreZoom.init();
        window.ScoreZoom = ScoreZoom;
        
        // Track System - Four tracks with SVG containers, MIDI files, and graphic data
        // Each track syncs to score time code but has independent MIDI and graphic content
        const TrackSystem = {
            tracks: [],            // Array of 4 track objects
            scoreTopEl: null,
            scoreBottomEl: null,
            timelineHeight: 24,    // Same as StaffCursors
            initialized: false,
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Create 4 tracks
                for (let i = 0; i < 4; i++) {
                    const track = this.createTrack(i);
                    this.tracks.push(track);
                }
                
                // Hook into animation for updates
                const originalOnDraw = AnimationEngine.onDraw;
                AnimationEngine.onDraw = (frameNumber, elapsedMs) => {
                    if (originalOnDraw) originalOnDraw(frameNumber, elapsedMs);
                    this.update();
                };
                
                // Update track dimensions on resize
                window.addEventListener('resize', () => {
                    this.updateTrackDimensions();
                });
                
                this.initialized = true;
                console.log('TrackSystem initialized with 4 tracks');
            },
            
            createTrack(trackIndex) {
                // Calculate track dimensions (same as cursor/staff dimensions)
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                const availableHeight = scoreHeight - this.timelineHeight;
                const trackHeight = availableHeight / 4;
                const yPosition = this.timelineHeight + (trackIndex * trackHeight);
                
                // Create SVG group containers for ScoreTop and ScoreBottom
                const topContainer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                const bottomContainer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                // Set container attributes
                topContainer.setAttribute('id', `track${trackIndex + 1}-top`);
                topContainer.setAttribute('class', 'track-container');
                bottomContainer.setAttribute('id', `track${trackIndex + 1}-bottom`);
                bottomContainer.setAttribute('class', 'track-container');
                
                // Create clipping rectangles to constrain content to track area
                const clipIdTop = `track${trackIndex + 1}-clip-top`;
                const clipIdBottom = `track${trackIndex + 1}-clip-bottom`;
                
                // Create clip paths
                const clipPathTop = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                clipPathTop.setAttribute('id', clipIdTop);
                const clipRectTop = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                clipRectTop.setAttribute('x', '0');
                clipRectTop.setAttribute('y', yPosition);
                clipRectTop.setAttribute('width', '100%');
                clipRectTop.setAttribute('height', trackHeight);
                clipPathTop.appendChild(clipRectTop);
                
                const clipPathBottom = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                clipPathBottom.setAttribute('id', clipIdBottom);
                const clipRectBottom = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                clipRectBottom.setAttribute('x', '0');
                clipRectBottom.setAttribute('y', yPosition);
                clipRectBottom.setAttribute('width', '100%');
                clipRectBottom.setAttribute('height', trackHeight);
                clipPathBottom.appendChild(clipRectBottom);
                
                // Add defs for clip paths if not exists
                let defsTop = this.scoreTopEl.querySelector('defs');
                if (!defsTop) {
                    defsTop = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    this.scoreTopEl.insertBefore(defsTop, this.scoreTopEl.firstChild);
                }
                defsTop.appendChild(clipPathTop);
                
                let defsBottom = this.scoreBottomEl.querySelector('defs');
                if (!defsBottom) {
                    defsBottom = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    this.scoreBottomEl.insertBefore(defsBottom, this.scoreBottomEl.firstChild);
                }
                defsBottom.appendChild(clipPathBottom);
                
                // Apply clip paths to containers
                topContainer.setAttribute('clip-path', `url(#${clipIdTop})`);
                bottomContainer.setAttribute('clip-path', `url(#${clipIdBottom})`);
                
                // Add containers to SVG elements (insert before cursors so cursors render on top)
                this.scoreTopEl.insertBefore(topContainer, this.scoreTopEl.firstChild.nextSibling);
                this.scoreBottomEl.insertBefore(bottomContainer, this.scoreBottomEl.firstChild.nextSibling);
                
                // Create track object with MIDI and graphic data structures
                return {
                    index: trackIndex,
                    name: `Track ${trackIndex + 1}`,
                    
                    // SVG containers
                    topContainer: topContainer,
                    bottomContainer: bottomContainer,
                    clipRectTop: clipRectTop,
                    clipRectBottom: clipRectBottom,
                    
                    // Dimensions
                    yPosition: yPosition,
                    height: trackHeight,
                    width: scoreWidth,
                    
                    // MIDI data - array of MIDI events
                    // Each event: { scoreTimeMs, type, note, velocity, duration, channel }
                    midiEvents: [],
                    
                    // Graphic items - array of graphic elements to render
                    // Each item: { scoreTimeMs, duration, type, x, y, width, height, color, data }
                    graphicItems: [],
                    
                    // Currently rendered graphic elements (for cleanup)
                    renderedElements: {
                        top: [],
                        bottom: []
                    },
                    
                    // Current page tracking for this track
                    currentTopPage: 0,
                    currentBottomPage: 1
                };
            },
            
            // Update track dimensions on resize
            updateTrackDimensions() {
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                const availableHeight = scoreHeight - this.timelineHeight;
                const trackHeight = availableHeight / 4;
                
                this.tracks.forEach((track, trackIndex) => {
                    const yPosition = this.timelineHeight + (trackIndex * trackHeight);
                    
                    track.yPosition = yPosition;
                    track.height = trackHeight;
                    track.width = scoreWidth;
                    
                    // Update clip rectangles
                    track.clipRectTop.setAttribute('y', yPosition);
                    track.clipRectTop.setAttribute('height', trackHeight);
                    track.clipRectBottom.setAttribute('y', yPosition);
                    track.clipRectBottom.setAttribute('height', trackHeight);
                });
                
                // Re-render all tracks
                this.renderAllTracks();
            },
            
            // Load MIDI events for a track
            loadMidiEvents(trackIndex, midiEvents) {
                if (trackIndex >= 0 && trackIndex < this.tracks.length) {
                    this.tracks[trackIndex].midiEvents = midiEvents;
                    console.log(`Track ${trackIndex + 1}: Loaded ${midiEvents.length} MIDI events`);
                }
            },
            
            // Load graphic items for a track
            loadGraphicItems(trackIndex, graphicItems) {
                if (trackIndex >= 0 && trackIndex < this.tracks.length) {
                    this.tracks[trackIndex].graphicItems = graphicItems;
                    console.log(`Track ${trackIndex + 1}: Loaded ${graphicItems.length} graphic items`);
                    this.renderTrack(trackIndex);
                }
            },
            
            // Get MIDI events at a specific score time for a track
            getMidiEventsAtTime(trackIndex, scoreTimeMs, windowMs = 0) {
                if (trackIndex < 0 || trackIndex >= this.tracks.length) return [];
                
                const track = this.tracks[trackIndex];
                return track.midiEvents.filter(event => {
                    if (windowMs === 0) {
                        return event.scoreTimeMs === scoreTimeMs;
                    }
                    return event.scoreTimeMs >= scoreTimeMs - windowMs && 
                           event.scoreTimeMs <= scoreTimeMs + windowMs;
                });
            },
            
            // Get graphic items visible in current page for a track
            getVisibleGraphicItems(trackIndex, section) {
                if (trackIndex < 0 || trackIndex >= this.tracks.length) return [];
                
                const track = this.tracks[trackIndex];
                const pageNumber = section === 'top' ? track.currentTopPage : track.currentBottomPage;
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const pageStartMs = pageNumber * secondsPerPage * 1000;
                const pageEndMs = (pageNumber + 1) * secondsPerPage * 1000;
                
                return track.graphicItems.filter(item => {
                    const itemEndMs = item.scoreTimeMs + (item.duration || 0);
                    return item.scoreTimeMs < pageEndMs && itemEndMs >= pageStartMs;
                });
            },
            
            // Render a single track
            renderTrack(trackIndex) {
                if (trackIndex < 0 || trackIndex >= this.tracks.length) return;
                
                const track = this.tracks[trackIndex];
                
                // Clear existing rendered elements
                track.renderedElements.top.forEach(el => el.remove());
                track.renderedElements.bottom.forEach(el => el.remove());
                track.renderedElements.top = [];
                track.renderedElements.bottom = [];
                
                // Render for both sections
                this.renderTrackSection(trackIndex, 'top');
                this.renderTrackSection(trackIndex, 'bottom');
            },
            
            // Render track content for a specific section
            renderTrackSection(trackIndex, section) {
                const track = this.tracks[trackIndex];
                const container = section === 'top' ? track.topContainer : track.bottomContainer;
                const visibleItems = this.getVisibleGraphicItems(trackIndex, section);
                const pageNumber = section === 'top' ? track.currentTopPage : track.currentBottomPage;
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const pageStartMs = pageNumber * secondsPerPage * 1000;
                
                visibleItems.forEach(item => {
                    // Calculate x position as percentage based on score time
                    const itemOffsetMs = item.scoreTimeMs - pageStartMs;
                    const xPercent = (itemOffsetMs / (secondsPerPage * 1000)) * 100;
                    
                    // Create graphic element based on type
                    let element;
                    switch (item.type) {
                        case 'rect':
                            element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            element.setAttribute('x', `${xPercent}%`);
                            element.setAttribute('y', track.yPosition + (item.y || 0));
                            element.setAttribute('width', item.width || 10);
                            element.setAttribute('height', item.height || track.height);
                            element.setAttribute('fill', item.color || '#666');
                            break;
                        case 'line':
                            element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            element.setAttribute('x1', `${xPercent}%`);
                            element.setAttribute('y1', track.yPosition + (item.y1 || 0));
                            element.setAttribute('x2', `${xPercent + (item.widthPercent || 0)}%`);
                            element.setAttribute('y2', track.yPosition + (item.y2 || track.height));
                            element.setAttribute('stroke', item.color || '#666');
                            element.setAttribute('stroke-width', item.strokeWidth || 1);
                            break;
                        case 'text':
                            element = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            element.setAttribute('x', `${xPercent}%`);
                            element.setAttribute('y', track.yPosition + (item.y || track.height / 2));
                            element.setAttribute('font-size', item.fontSize || 10);
                            element.setAttribute('fill', item.color || '#333');
                            element.textContent = item.text || '';
                            break;
                        case 'note':
                            // MIDI note visualization - horizontal bar
                            element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            const noteHeight = track.height / 128; // 128 MIDI notes
                            const noteY = track.yPosition + track.height - ((item.note || 60) * noteHeight);
                            const durationPercent = ((item.duration || 100) / (secondsPerPage * 1000)) * 100;
                            element.setAttribute('x', `${xPercent}%`);
                            element.setAttribute('y', noteY);
                            element.setAttribute('width', `${durationPercent}%`);
                            element.setAttribute('height', noteHeight * 2);
                            element.setAttribute('fill', item.color || StaffCursors.colors[trackIndex]);
                            element.setAttribute('opacity', (item.velocity || 100) / 127);
                            break;
                        default:
                            return; // Unknown type, skip
                    }
                    
                    if (element) {
                        container.appendChild(element);
                        track.renderedElements[section].push(element);
                    }
                });
            },
            
            // Render all tracks
            renderAllTracks() {
                this.tracks.forEach((track, index) => {
                    this.renderTrack(index);
                });
            },
            
            // Update method called each frame
            update() {
                const currentScoreTimeMs = ScoreTime.now();
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                // Check for page changes on each track
                this.tracks.forEach((track, trackIndex) => {
                    const currentPage = Math.floor(currentScoreTimeMs / (secondsPerPage * 1000));
                    const cursorSection = currentPage % 2 === 0 ? 'top' : 'bottom';
                    
                    // Update page numbers if cursor moved to new section
                    if (cursorSection === 'bottom' && track.currentTopPage === currentPage - 1) {
                        // Cursor moved to bottom, update top to next even page
                        track.currentTopPage = currentPage + 1;
                        this.renderTrackSection(trackIndex, 'top');
                    } else if (cursorSection === 'top' && track.currentBottomPage === currentPage - 1) {
                        // Cursor moved to top, update bottom to next odd page
                        track.currentBottomPage = currentPage + 1;
                        this.renderTrackSection(trackIndex, 'bottom');
                    }
                });
            },
            
            // Reset all tracks to beginning
            reset() {
                this.tracks.forEach(track => {
                    track.currentTopPage = 0;
                    track.currentBottomPage = 1;
                });
                this.renderAllTracks();
            },
            
            // Called when goto is triggered
            onGoto(targetSeconds) {
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const targetPage = Math.floor(targetSeconds / secondsPerPage);
                
                this.tracks.forEach(track => {
                    if (targetPage % 2 === 0) {
                        track.currentTopPage = targetPage;
                        track.currentBottomPage = targetPage > 0 ? targetPage - 1 : 1;
                    } else {
                        track.currentBottomPage = targetPage;
                        track.currentTopPage = targetPage - 1;
                    }
                });
                this.renderAllTracks();
            },
            
            // Get track by index
            getTrack(trackIndex) {
                if (trackIndex >= 0 && trackIndex < this.tracks.length) {
                    return this.tracks[trackIndex];
                }
                return null;
            }
        };
        
        // Initialize track system after DOM is ready
        TrackSystem.init();
        window.TrackSystem = TrackSystem;
        
        // Graphic Timeline System - Visual timeline at the top of ScoreTop and ScoreBottom
        // Dots at y=0 for each second, 3px lines for every 5th second, Lato 7pt labels for 5th seconds
        // Uses percentage-based positioning so all clients see identical graphics regardless of window size
        const GraphicTimeline = {
            scoreTopEl: null,
            scoreBottomEl: null,
            topGroup: null,
            bottomGroup: null,
            currentTopPage: 0,
            currentBottomPage: 1,
            lastCursorSection: 'top',
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Create groups for timeline graphics
                this.topGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.bottomGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.topGroup.setAttribute('class', 'graphic-timeline');
                this.bottomGroup.setAttribute('class', 'graphic-timeline');
                
                this.scoreTopEl.appendChild(this.topGroup);
                this.scoreBottomEl.appendChild(this.bottomGroup);
                
                // Create clickable areas for timeline (invisible rectangles)
                this.createClickableArea('top');
                this.createClickableArea('bottom');
                
                // Initial render
                this.renderTicks();
                
                // Hook into animation to check for page changes
                const originalOnDraw = AnimationEngine.onDraw;
                AnimationEngine.onDraw = (frameNumber, elapsedMs) => {
                    if (originalOnDraw) originalOnDraw(frameNumber, elapsedMs);
                    this.checkPageChange();
                };
                
                // Refresh on window resize
                window.addEventListener('resize', () => {
                    this.renderTicks();
                    this.updateClickableAreas();
                });
            },
            
            createClickableArea(section) {
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const clickArea = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                clickArea.setAttribute('x', '0');
                clickArea.setAttribute('y', '0');
                clickArea.setAttribute('width', '100%');
                clickArea.setAttribute('height', '20');
                clickArea.setAttribute('fill', 'transparent');
                clickArea.setAttribute('cursor', 'pointer');
                
                clickArea.addEventListener('click', (e) => this.onTimelineClick(e, section));
                
                scoreEl.appendChild(clickArea);
                
                if (section === 'top') {
                    this.topClickArea = clickArea;
                } else {
                    this.bottomClickArea = clickArea;
                }
            },
            
            updateClickableAreas() {
                // Click areas use 100% width so no update needed for width
            },
            
            onTimelineClick(e, section) {
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const rect = scoreEl.getBoundingClientRect();
                const xPercent = ((e.clientX - rect.left) / rect.width) * 100;
                
                // Get the page number for this section
                const pageNumber = section === 'top' ? this.currentTopPage : this.currentBottomPage;
                const secondsPerPage = this.getSecondsPerPage();
                
                // Calculate the seconds position
                const seconds = (pageNumber + xPercent / 100) * secondsPerPage - leadInSeconds;
                
                // Jump edit cursor to this position
                if (window.EditCursor) {
                    EditCursor.setPositionSeconds(seconds);
                }
            },
            
            // Calculate seconds per page based on tempo
            getSecondsPerPage() {
                return (beatsPerPage / beatsPerMinute) * 60;
            },
            
            // Get the starting second for a given page
            getPageStartSecond(pageNumber) {
                return pageNumber * this.getSecondsPerPage();
            },
            
            renderTicks() {
                this.renderTicksForSection('top');
                this.renderTicksForSection('bottom');
            },
            
            renderTicksForSection(section) {
                const group = section === 'top' ? this.topGroup : this.bottomGroup;
                const pageNumber = section === 'top' ? this.currentTopPage : this.currentBottomPage;
                
                // Clear existing graphics
                while (group.firstChild) {
                    group.removeChild(group.firstChild);
                }
                
                const secondsPerPage = this.getSecondsPerPage();
                const rawStartSecond = this.getPageStartSecond(pageNumber);
                const startSecond = rawStartSecond - leadInSeconds;
                const endSecond = startSecond + secondsPerPage;
                
                // Render graphics for each second
                for (let sec = Math.floor(startSecond); sec <= Math.ceil(endSecond); sec++) {
                    const adjustedSec = sec + leadInSeconds;
                    const xPercent = ((adjustedSec - rawStartSecond) / secondsPerPage) * 100;
                    
                    if (xPercent < 0 || xPercent > 100) continue;
                    
                    const isFifthSecond = sec % 5 === 0;
                    const isLeadIn = sec < 0;
                    const color = isLeadIn ? '#cc3333' : '#333';
                    
                    if (isFifthSecond) {
                        // 5th second: 3px vertical line, 1px width
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', `${xPercent}%`);
                        line.setAttribute('y1', '0');
                        line.setAttribute('x2', `${xPercent}%`);
                        line.setAttribute('y2', '3');
                        line.setAttribute('stroke', color);
                        line.setAttribute('stroke-width', '1');
                        group.appendChild(line);
                        
                        // Label for 5th second - Lato font, 7pt
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        label.setAttribute('x', `${xPercent}%`);
                        label.setAttribute('y', '10');
                        label.setAttribute('font-family', 'Lato, sans-serif');
                        label.setAttribute('font-size', '7');
                        label.setAttribute('fill', color);
                        
                        // Adjust text-anchor based on position
                        let textAnchor = 'middle';
                        if (xPercent < 3) {
                            textAnchor = 'start';
                        } else if (xPercent > 97) {
                            textAnchor = 'end';
                        }
                        label.setAttribute('text-anchor', textAnchor);
                        label.textContent = sec.toString();
                        group.appendChild(label);
                    } else {
                        // Non-5th second: small dot at y=0
                        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        dot.setAttribute('cx', `${xPercent}%`);
                        dot.setAttribute('cy', '1');
                        dot.setAttribute('r', '1');
                        dot.setAttribute('fill', color);
                        group.appendChild(dot);
                    }
                }
            },
            
            checkPageChange() {
                const position = StaffCursors.getPosition(0);
                if (!position) return;
                
                const cursorSection = position.section;
                
                // Only check for section changes during normal playback
                if (cursorSection !== this.lastCursorSection) {
                    if (cursorSection === 'bottom' && this.lastCursorSection === 'top') {
                        this.currentTopPage = this.currentTopPage + 2;
                        this.renderTicksForSection('top');
                    } else if (cursorSection === 'top' && this.lastCursorSection === 'bottom') {
                        this.currentBottomPage = this.currentBottomPage + 2;
                        this.renderTicksForSection('bottom');
                    }
                    this.lastCursorSection = cursorSection;
                    
                    // Update visibility of graphic objects
                    this.updateGraphicObjectsVisibility();
                }
            },
            
            // Update visibility of all graphic objects (SVGs, curves, connectors)
            updateGraphicObjectsVisibility() {
                if (window.SVGElementManager) SVGElementManager.updateVisibility();
                if (window.CurveMaker) CurveMaker.updateVisibility();
                if (window.FlowchartConnector) FlowchartConnector.updateVisibility();
                
                // Show staff headers only on page 0 (top) or page 1 (bottom)
                if (window.StaffCursors && StaffCursors.staffHeaderGroup) {
                    const showHeaders = this.currentTopPage === 0;
                    StaffCursors.staffHeaderGroup.style.display = showHeaders ? '' : 'none';
                }
            },
            
            reset() {
                this.currentTopPage = 0;
                this.currentBottomPage = 1;
                this.lastCursorSection = 'top';
                this.renderTicks();
                this.updateGraphicObjectsVisibility();
            },
            
            onGoto(targetSeconds) {
                const secondsPerPage = this.getSecondsPerPage();
                const targetPage = Math.floor(targetSeconds / secondsPerPage);
                
                if (targetPage % 2 === 0) {
                    this.currentTopPage = targetPage;
                    this.currentBottomPage = targetPage > 0 ? targetPage - 1 : 1;
                    this.lastCursorSection = 'top';
                } else {
                    this.currentBottomPage = targetPage;
                    this.currentTopPage = targetPage - 1;
                    this.lastCursorSection = 'bottom';
                }
                this.renderTicks();
                this.updateGraphicObjectsVisibility();
            }
        };
        
        // Initialize graphic timeline
        GraphicTimeline.init();
        window.GraphicTimeline = GraphicTimeline;
        
        // MIDI Controller System - Multi-track MIDI file management and cursor-synced playback
        const MidiController = {
            // Device elements
            inputSelect: null,
            outputSelect: null,
            refreshBtn: null,
            
            // File elements
            loadBtn: null,
            fileInput: null,
            downloadBtn: null,
            exportCsvBtn: null,
            insertBtn: null,
            insertTimeDisplay: null,
            fileNameDisplay: null,
            
            // Display elements
            timecodeDisplay: null,
            eventCountDisplay: null,
            showGraphicItemsToggle: null,
            showMidiDisplayToggle: null,
            ccDisplaySelect: null,
            
            // Selected CC for display (default CC7)
            selectedCC: 7,
            
            // CC name mapping
            ccNames: {
                0: 'Bank Select',
                1: 'Modulation',
                5: 'Portamento Time',
                7: 'Main Volume',
                10: 'Pan',
                11: 'Expression',
                120: 'All Sound Off',
                123: 'All Notes Off'
            },
            
            // Track enable checkboxes
            trackEnables: [null, null, null, null],
            
            // MIDI state
            midiAccess: null,
            selectedInput: null,
            selectedOutput: null,
            
            // Track selection (1-4)
            selectedTrack: 1,
            
            // MIDI data per track (4 tracks)
            // Each track: { midiEvents: [], channel: trackIndex+1 }
            tracks: [
                { midiEvents: [], channel: 1 },
                { midiEvents: [], channel: 2 },
                { midiEvents: [], channel: 3 },
                { midiEvents: [], channel: 4 }
            ],
            
            // Loaded MIDI file data (temporary before insert)
            loadedFileEvents: [],
            loadedFileName: '',
            
            // Playback state - synced to graphic cursors
            lastPlaybackTimeMs: [0, 0, 0, 0], // Per-track last processed time
            currentEventIndices: [0, 0, 0, 0], // Per-track playback position
            
            // MIDI Display SVG layers
            midiDisplayLayers: { top: [], bottom: [] }, // Per track SVG groups
            scoreTopEl: null,
            scoreBottomEl: null,
            timelineHeight: 8, // Match StaffCursors.timelineHeight
            
            init() {
                // Get SVG elements
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Get device elements
                this.inputSelect = document.getElementById('midiInputSelect');
                this.outputSelect = document.getElementById('midiOutputSelect');
                this.refreshBtn = document.getElementById('midiRefreshBtn');
                
                // Get file elements
                this.loadBtn = document.getElementById('midiLoadBtn');
                this.fileInput = document.getElementById('midiFileInput');
                this.downloadBtn = document.getElementById('midiDownloadBtn');
                this.exportCsvBtn = document.getElementById('midiExportCsvBtn');
                this.insertBtn = document.getElementById('midiInsertBtn');
                this.insertTimeDisplay = document.getElementById('midiInsertTime');
                this.fileNameDisplay = document.getElementById('midiFileName');
                
                // Get display elements
                this.timecodeDisplay = document.getElementById('midiTimecode');
                this.eventCountDisplay = document.getElementById('midiEventCount');
                this.showGraphicItemsToggle = document.getElementById('showGraphicItems');
                this.showMidiDisplayToggle = document.getElementById('showMidiDisplay');
                this.ccDisplaySelect = document.getElementById('ccDisplaySelect');
                
                // Get track enable checkboxes
                this.trackEnables = [
                    document.getElementById('midiEnableT1'),
                    document.getElementById('midiEnableT2'),
                    document.getElementById('midiEnableT3'),
                    document.getElementById('midiEnableT4')
                ];
                
                // Set up track selection radio buttons
                document.querySelectorAll('input[name="midiTrack"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.selectedTrack = parseInt(e.target.value);
                        this.updateEventCount();
                    });
                });
                
                // Set up event listeners
                if (this.refreshBtn) this.refreshBtn.addEventListener('click', () => this.refreshDevices());
                if (this.inputSelect) this.inputSelect.addEventListener('change', (e) => this.selectInput(e.target.value));
                if (this.outputSelect) this.outputSelect.addEventListener('change', (e) => this.selectOutput(e.target.value));
                
                if (this.loadBtn) this.loadBtn.addEventListener('click', () => this.fileInput.click());
                if (this.fileInput) this.fileInput.addEventListener('change', (e) => this.loadMidiFile(e));
                if (this.downloadBtn) this.downloadBtn.addEventListener('click', () => this.downloadMidiFile());
                if (this.exportCsvBtn) this.exportCsvBtn.addEventListener('click', () => this.exportCsv());
                if (this.insertBtn) this.insertBtn.addEventListener('click', () => this.insertAtEditCursor());
                
                // Set up display toggle listeners
                if (this.showGraphicItemsToggle) {
                    this.showGraphicItemsToggle.addEventListener('change', () => this.updateGraphicItemsVisibility());
                }
                if (this.showMidiDisplayToggle) {
                    this.showMidiDisplayToggle.addEventListener('change', () => this.updateMidiDisplayVisibility());
                }
                if (this.ccDisplaySelect) {
                    this.ccDisplaySelect.addEventListener('change', (e) => {
                        this.selectedCC = parseInt(e.target.value);
                        this.renderAllMidiDisplays();
                    });
                }
                
                // Create MIDI display layers for each track
                this.createMidiDisplayLayers();
                
                // Initialize Web MIDI API
                this.initMidi();
                
                // Hook into animation for timecode updates, insert time sync, and cursor-synced playback
                const originalOnDraw = AnimationEngine.onDraw;
                AnimationEngine.onDraw = (frameNumber, elapsedMs) => {
                    if (originalOnDraw) originalOnDraw(frameNumber, elapsedMs);
                    this.updateTimecode();
                    this.updateInsertTime();
                    this.processCursorSyncedPlayback();
                };
                
                // Add resize handler to re-render MIDI display
                window.addEventListener('resize', () => {
                    this.renderAllMidiDisplays();
                });
                
                console.log('MidiController initialized with cursor-synced playback');
            },
            
            // Create SVG layers for MIDI display per track
            createMidiDisplayLayers() {
                if (!this.scoreTopEl || !this.scoreBottomEl) return;
                for (let trackIndex = 0; trackIndex < 4; trackIndex++) {
                    // Create groups for top and bottom score sections
                    const topGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    const bottomGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    
                    topGroup.setAttribute('id', `midi-display-t${trackIndex + 1}-top`);
                    topGroup.setAttribute('class', 'midi-display-layer');
                    bottomGroup.setAttribute('id', `midi-display-t${trackIndex + 1}-bottom`);
                    bottomGroup.setAttribute('class', 'midi-display-layer');
                    
                    this.scoreTopEl.appendChild(topGroup);
                    this.scoreBottomEl.appendChild(bottomGroup);
                    
                    this.midiDisplayLayers.top.push(topGroup);
                    this.midiDisplayLayers.bottom.push(bottomGroup);
                }
            },
            
            // Update visibility of graphic items (curves, etc.)
            updateGraphicItemsVisibility() {
                const show = this.showGraphicItemsToggle?.checked ?? true;
                // Hide/show all curve elements but keep timeline, cursors, staff dividers visible
                document.querySelectorAll('.curve-path, .curve-fill, .curve-bounding-box').forEach(el => {
                    el.style.display = show ? '' : 'none';
                });
            },
            
            // Update visibility of MIDI display layers
            updateMidiDisplayVisibility() {
                const show = this.showMidiDisplayToggle?.checked ?? true;
                document.querySelectorAll('.midi-display-layer').forEach(el => {
                    el.style.display = show ? '' : 'none';
                });
            },
            
            // Process MIDI playback synced to graphic cursor positions
            processCursorSyncedPlayback() {
                if (!window.ScoreTime || !ScoreTime.isPlaying) return;
                
                const currentScoreTimeMs = ScoreTime.now();
                const currentDisplayTimeSec = (currentScoreTimeMs / 1000) - leadInSeconds;
                const currentDisplayTimeMs = currentDisplayTimeSec * 1000;
                
                // Process each enabled track
                for (let trackIndex = 0; trackIndex < 4; trackIndex++) {
                    // Check if track is enabled
                    if (!this.trackEnables[trackIndex] || !this.trackEnables[trackIndex].checked) continue;
                    
                    const trackEvents = this.tracks[trackIndex].midiEvents;
                    if (trackEvents.length === 0) continue;
                    
                    // Send any events between last time and current time
                    while (this.currentEventIndices[trackIndex] < trackEvents.length &&
                           trackEvents[this.currentEventIndices[trackIndex]].timeMs <= currentDisplayTimeMs) {
                        const event = trackEvents[this.currentEventIndices[trackIndex]];
                        
                        // Only send if we haven't already passed this event
                        if (event.timeMs > this.lastPlaybackTimeMs[trackIndex]) {
                            // Send to output if available
                            if (this.selectedOutput) {
                                this.selectedOutput.send(event.data);
                            }
                        }
                        
                        this.currentEventIndices[trackIndex]++;
                    }
                    
                    this.lastPlaybackTimeMs[trackIndex] = currentDisplayTimeMs;
                }
            },
            
            // Reset playback indices when score time resets
            resetPlaybackIndices() {
                this.currentEventIndices = [0, 0, 0, 0];
                this.lastPlaybackTimeMs = [0, 0, 0, 0];
            },
            
            // Reset playback to a specific time (used when jumping to a position)
            resetPlaybackToTime(targetTimeMs) {
                for (let trackIndex = 0; trackIndex < 4; trackIndex++) {
                    const trackEvents = this.tracks[trackIndex].midiEvents;
                    
                    // Find the first event at or after the target time
                    let eventIndex = 0;
                    while (eventIndex < trackEvents.length && trackEvents[eventIndex].timeMs < targetTimeMs) {
                        eventIndex++;
                    }
                    
                    this.currentEventIndices[trackIndex] = eventIndex;
                    this.lastPlaybackTimeMs[trackIndex] = targetTimeMs;
                }
            },
            
            // Web MIDI API initialization
            async initMidi() {
                try {
                    this.midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                    this.midiAccess.onstatechange = () => this.refreshDevices();
                    this.refreshDevices();
                    console.log('Web MIDI API initialized');
                } catch (err) {
                    console.error('Web MIDI API not available:', err);
                    this.inputSelect.innerHTML = '<option value="">MIDI not available</option>';
                    this.outputSelect.innerHTML = '<option value="">MIDI not available</option>';
                }
            },
            
            refreshDevices() {
                if (!this.midiAccess) return;
                
                // Clear and populate input select
                this.inputSelect.innerHTML = '<option value="">-- Select Input --</option>';
                for (const input of this.midiAccess.inputs.values()) {
                    const option = document.createElement('option');
                    option.value = input.id;
                    option.textContent = input.name;
                    this.inputSelect.appendChild(option);
                }
                
                // Clear and populate output select
                this.outputSelect.innerHTML = '<option value="">-- Select Output --</option>';
                for (const output of this.midiAccess.outputs.values()) {
                    const option = document.createElement('option');
                    option.value = output.id;
                    option.textContent = output.name;
                    this.outputSelect.appendChild(option);
                }
                
                console.log('MIDI devices refreshed');
            },
            
            selectInput(inputId) {
                if (this.selectedInput) {
                    this.selectedInput.onmidimessage = null;
                }
                
                if (inputId && this.midiAccess) {
                    this.selectedInput = this.midiAccess.inputs.get(inputId);
                    if (this.selectedInput) {
                        this.selectedInput.onmidimessage = (e) => this.onMidiMessage(e);
                        console.log('MIDI input selected:', this.selectedInput.name);
                    }
                } else {
                    this.selectedInput = null;
                }
            },
            
            selectOutput(outputId) {
                if (outputId && this.midiAccess) {
                    this.selectedOutput = this.midiAccess.outputs.get(outputId);
                    console.log('MIDI output selected:', this.selectedOutput?.name);
                } else {
                    this.selectedOutput = null;
                }
            },
            
            onMidiMessage(event) {
                // MIDI input handling - can be extended for live input features
                console.log('MIDI message received:', event.data);
            },
            
            // Update insert time display from edit cursor position
            updateInsertTime() {
                if (window.EditCursor && this.insertTimeDisplay) {
                    this.insertTimeDisplay.textContent = EditCursor.positionSeconds.toFixed(3);
                }
            },
            
            // Insert loaded MIDI file at edit cursor position into selected track
            insertAtEditCursor() {
                if (this.loadedFileEvents.length === 0) {
                    alert('No MIDI file loaded. Load a MIDI file first.');
                    return;
                }
                
                const trackIndex = this.selectedTrack - 1;
                const insertTimeMs = (window.EditCursor ? EditCursor.positionSeconds : 0) * 1000;
                const channel = trackIndex + 1; // Track 1 = Channel 1, etc.
                
                // Add events to selected track with time offset and channel remapping
                for (const event of this.loadedFileEvents) {
                    const newEvent = {
                        timeMs: event.timeMs + insertTimeMs,
                        type: event.type,
                        data: [...event.data]
                    };
                    
                    // Remap channel for channel voice messages (0x80-0xEF)
                    const statusByte = newEvent.data[0];
                    if (statusByte >= 0x80 && statusByte < 0xF0) {
                        newEvent.data[0] = (statusByte & 0xF0) | (channel - 1);
                    }
                    
                    this.tracks[trackIndex].midiEvents.push(newEvent);
                }
                
                // Sort events by time
                this.tracks[trackIndex].midiEvents.sort((a, b) => a.timeMs - b.timeMs);
                
                // Mark score as dirty (has unsaved changes)
                if (window.ScoreManager) ScoreManager.markDirty();
                
                this.updateEventCount();
                this.renderMidiDisplay(trackIndex); // Update MIDI display
            },
            
            getMidiEventType(statusByte) {
                const type = statusByte & 0xF0;
                switch (type) {
                    case 0x80: return 'noteOff';
                    case 0x90: return 'noteOn';
                    case 0xA0: return 'aftertouch';
                    case 0xB0: return 'controlChange';
                    case 0xC0: return 'programChange';
                    case 0xD0: return 'channelPressure';
                    case 0xE0: return 'pitchBend';
                    default: return 'unknown';
                }
            },
            
            // File operations
            loadMidiFile(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        this.parseMidiFile(e.target.result);
                        this.loadedFileName = file.name;
                        this.fileNameDisplay.textContent = file.name;
                        console.log(`Loaded MIDI file: ${file.name} (${this.loadedFileEvents.length} events)`);
                    } catch (err) {
                        console.error('Error parsing MIDI file:', err);
                        alert('Error parsing MIDI file');
                    }
                };
                reader.readAsArrayBuffer(file);
                event.target.value = ''; // Reset file input
            },
            
            parseMidiFile(arrayBuffer) {
                const data = new Uint8Array(arrayBuffer);
                this.loadedFileEvents = [];
                
                // Simple MIDI file parser
                let pos = 0;
                
                // Check header
                const header = String.fromCharCode(data[0], data[1], data[2], data[3]);
                if (header !== 'MThd') {
                    throw new Error('Invalid MIDI file header');
                }
                
                pos = 4;
                const headerLength = (data[pos] << 24) | (data[pos+1] << 16) | (data[pos+2] << 8) | data[pos+3];
                pos += 4;
                
                const format = (data[pos] << 8) | data[pos+1];
                const numTracks = (data[pos+2] << 8) | data[pos+3];
                const division = (data[pos+4] << 8) | data[pos+5];
                pos += headerLength;
                
                // Parse tracks
                let currentTimeMs = 0;
                const ticksPerBeat = division;
                const microsecondsPerBeat = 500000; // Default 120 BPM
                const msPerTick = (microsecondsPerBeat / 1000) / ticksPerBeat;
                
                for (let track = 0; track < numTracks; track++) {
                    const trackHeader = String.fromCharCode(data[pos], data[pos+1], data[pos+2], data[pos+3]);
                    if (trackHeader !== 'MTrk') continue;
                    
                    pos += 4;
                    const trackLength = (data[pos] << 24) | (data[pos+1] << 16) | (data[pos+2] << 8) | data[pos+3];
                    pos += 4;
                    
                    const trackEnd = pos + trackLength;
                    let trackTimeMs = 0;
                    let runningStatus = 0;
                    
                    while (pos < trackEnd) {
                        // Read delta time (variable length)
                        let deltaTime = 0;
                        let byte;
                        do {
                            byte = data[pos++];
                            deltaTime = (deltaTime << 7) | (byte & 0x7F);
                        } while (byte & 0x80);
                        
                        trackTimeMs += deltaTime * msPerTick;
                        
                        // Read event
                        let status = data[pos];
                        if (status < 0x80) {
                            // Running status
                            status = runningStatus;
                        } else {
                            pos++;
                            if (status < 0xF0) {
                                runningStatus = status;
                            }
                        }
                        
                        const eventType = status & 0xF0;
                        
                        if (status === 0xFF) {
                            // Meta event
                            const metaType = data[pos++];
                            let length = 0;
                            do {
                                byte = data[pos++];
                                length = (length << 7) | (byte & 0x7F);
                            } while (byte & 0x80);
                            pos += length;
                        } else if (status === 0xF0 || status === 0xF7) {
                            // SysEx
                            let length = 0;
                            do {
                                byte = data[pos++];
                                length = (length << 7) | (byte & 0x7F);
                            } while (byte & 0x80);
                            pos += length;
                        } else if (eventType >= 0x80 && eventType <= 0xE0) {
                            // Channel event
                            const data1 = data[pos++];
                            let data2 = 0;
                            if (eventType !== 0xC0 && eventType !== 0xD0) {
                                data2 = data[pos++];
                            }
                            
                            this.loadedFileEvents.push({
                                timeMs: trackTimeMs,
                                type: this.getMidiEventType(status),
                                data: eventType === 0xC0 || eventType === 0xD0 
                                    ? [status, data1] 
                                    : [status, data1, data2]
                            });
                        }
                    }
                }
                
                // Sort events by time
                this.loadedFileEvents.sort((a, b) => a.timeMs - b.timeMs);
            },
            
            downloadMidiFile() {
                const trackIndex = this.selectedTrack - 1;
                const trackEvents = this.tracks[trackIndex].midiEvents;
                
                if (trackEvents.length === 0) {
                    alert(`No MIDI data in Track ${this.selectedTrack} to download`);
                    return;
                }
                
                // Create simple MIDI file from track events
                const midiData = this.createMidiFile(trackEvents);
                const blob = new Blob([midiData], { type: 'audio/midi' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `track${this.selectedTrack}.mid`;
                a.click();
                URL.revokeObjectURL(url);
            },
            
            createMidiFile(events) {
                // Create a simple Format 0 MIDI file
                const ticksPerBeat = 480;
                const msPerTick = (500000 / 1000) / ticksPerBeat; // 120 BPM default
                
                // Build track data
                const trackData = [];
                let lastTimeMs = 0;
                
                for (const event of events) {
                    const deltaTicks = Math.round((event.timeMs - lastTimeMs) / msPerTick);
                    lastTimeMs = event.timeMs;
                    
                    // Write variable length delta time
                    const deltaBytes = this.writeVariableLength(deltaTicks);
                    trackData.push(...deltaBytes);
                    
                    // Write event data
                    trackData.push(...event.data);
                }
                
                // Add end of track
                trackData.push(0x00, 0xFF, 0x2F, 0x00);
                
                // Build file
                const file = [];
                
                // Header chunk
                file.push(0x4D, 0x54, 0x68, 0x64); // MThd
                file.push(0x00, 0x00, 0x00, 0x06); // Header length
                file.push(0x00, 0x00); // Format 0
                file.push(0x00, 0x01); // 1 track
                file.push((ticksPerBeat >> 8) & 0xFF, ticksPerBeat & 0xFF); // Division
                
                // Track chunk
                file.push(0x4D, 0x54, 0x72, 0x6B); // MTrk
                const trackLength = trackData.length;
                file.push((trackLength >> 24) & 0xFF, (trackLength >> 16) & 0xFF, 
                          (trackLength >> 8) & 0xFF, trackLength & 0xFF);
                file.push(...trackData);
                
                return new Uint8Array(file);
            },
            
            writeVariableLength(value) {
                const bytes = [];
                bytes.unshift(value & 0x7F);
                value >>= 7;
                while (value > 0) {
                    bytes.unshift((value & 0x7F) | 0x80);
                    value >>= 7;
                }
                return bytes;
            },
            
            exportCsv() {
                const trackIndex = this.selectedTrack - 1;
                const trackEvents = this.tracks[trackIndex].midiEvents;
                
                if (trackEvents.length === 0) {
                    alert(`No MIDI data in Track ${this.selectedTrack} to export`);
                    return;
                }
                
                let csv = 'Time (ms),Time (sec),Type,Channel,Status,Data1,Data2,Note,Velocity\n';
                for (const event of trackEvents) {
                    const data1 = event.data[1] !== undefined ? event.data[1] : '';
                    const data2 = event.data[2] !== undefined ? event.data[2] : '';
                    const channel = (event.data[0] & 0x0F) + 1;
                    const noteName = event.type === 'noteOn' || event.type === 'noteOff' ? this.midiNoteToName(data1) : '';
                    const velocity = event.type === 'noteOn' || event.type === 'noteOff' ? data2 : '';
                    csv += `${event.timeMs.toFixed(3)},${(event.timeMs/1000).toFixed(3)},${event.type},${channel},${event.data[0]},${data1},${data2},${noteName},${velocity}\n`;
                }
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `track${this.selectedTrack}_midi.csv`;
                a.click();
                URL.revokeObjectURL(url);
            },
            
            midiNoteToName(noteNumber) {
                const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const octave = Math.floor(noteNumber / 12) - 1;
                const note = notes[noteNumber % 12];
                return `${note}${octave}`;
            },
            
            // Update timecode display from cursor position (synced to ScoreTime)
            updateTimecode() {
                if (!this.timecodeDisplay) return;
                
                let timeMs = 0;
                if (window.ScoreTime) {
                    const currentScoreTimeMs = ScoreTime.now();
                    const currentDisplayTimeSec = (currentScoreTimeMs / 1000) - leadInSeconds;
                    timeMs = Math.max(0, currentDisplayTimeSec * 1000);
                }
                
                this.timecodeDisplay.textContent = this.formatTimecode(timeMs);
            },
            
            formatTimecode(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                const milliseconds = Math.floor(ms % 1000);
                
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            },
            
            updateEventCount() {
                if (this.eventCountDisplay) {
                    const trackIndex = this.selectedTrack - 1;
                    const trackEvents = this.tracks[trackIndex].midiEvents;
                    this.eventCountDisplay.textContent = `T${this.selectedTrack} Events: ${trackEvents.length}`;
                }
            },
            
            // Get current MIDI events for external use (selected track)
            getEvents() {
                const trackIndex = this.selectedTrack - 1;
                return this.tracks[trackIndex].midiEvents;
            },
            
            // Get all tracks' events
            getAllTracks() {
                return this.tracks;
            },
            
            // Get current playback time in ms (synced to cursor)
            getCurrentTimeMs() {
                if (window.ScoreTime && ScoreTime.isRunning) {
                    const currentScoreTimeMs = ScoreTime.now();
                    const currentDisplayTimeSec = (currentScoreTimeMs / 1000) - leadInSeconds;
                    return Math.max(0, currentDisplayTimeSec * 1000);
                }
                return 0;
            },
            
            // Render MIDI events as SVG graphics for a track
            // Layout per track (within track height):
            // - Top 40%: Note rectangles (pitch mapped to height)
            // - Next 15%: Velocity squares (black with white text)
            // - Next 15%: CC0 squares (blue with white text)
            // - Bottom 30%: CC7 line graph (0-127 height)
            renderMidiDisplay(trackIndex) {
                const trackEvents = this.tracks[trackIndex].midiEvents;
                const topGroup = this.midiDisplayLayers.top[trackIndex];
                const bottomGroup = this.midiDisplayLayers.bottom[trackIndex];
                
                // Clear existing display
                topGroup.innerHTML = '';
                bottomGroup.innerHTML = '';
                
                if (trackEvents.length === 0) return;
                
                // Get track dimensions
                const scoreHeight = this.scoreTopEl.clientHeight;
                const scoreWidth = this.scoreTopEl.clientWidth;
                
                // If dimensions are 0, the SVG hasn't been laid out yet - skip rendering
                if (scoreWidth === 0 || scoreHeight === 0) return;
                const availableHeight = scoreHeight - this.timelineHeight;
                const trackHeight = availableHeight / 4;
                const trackY = this.timelineHeight + (trackIndex * trackHeight);
                
                // Layout heights within track:
                // - Note line: 2px at very top
                // - Velocity: small row just below note line
                // - CC display: bottom half of track (vertical lines)
                const noteLineHeight = 2;
                const velocityRowHeight = 14; // enough for 12px square + padding
                const ccRowHeight = trackHeight * 0.50; // bottom half
                
                const noteRowY = trackY;
                const velocityRowY = trackY + noteLineHeight + 2;
                const ccRowY = trackY + trackHeight - ccRowHeight; // starts at bottom half
                
                // Get selected CC number and name for display
                const selectedCCNum = this.selectedCC;
                const ccName = this.ccNames[selectedCCNum] || `CC${selectedCCNum}`;
                
                // Calculate time-to-pixel conversion using GraphicTimeline's getSecondsPerPage()
                let secondsPerPage = 10; // default
                if (window.GraphicTimeline && typeof GraphicTimeline.getSecondsPerPage === 'function') {
                    secondsPerPage = GraphicTimeline.getSecondsPerPage();
                }
                const msPerPage = secondsPerPage * 1000;
                const pixelsPerMs = scoreWidth / msPerPage;
                
                // Lead-in offset: MIDI events are in display time (0 = first beat)
                // but pages are in actual time (0 = start of lead-in)
                // So we need to add leadInSeconds to convert display time to actual time
                const leadInMs = leadInSeconds * 1000;
                
                // Build note pairs (noteOn -> noteOff)
                const activeNotes = {}; // key: note number, value: noteOn event
                const notePairs = [];
                const velocityEvents = [];
                const ccEvents = []; // Events for the selected CC
                
                for (const event of trackEvents) {
                    const statusType = event.data[0] & 0xF0;
                    
                    if (statusType === 0x90 && event.data[2] > 0) {
                        // Note On
                        const noteNum = event.data[1];
                        activeNotes[noteNum] = event;
                        velocityEvents.push({ timeMs: event.timeMs, velocity: event.data[2], noteNum });
                    } else if (statusType === 0x80 || (statusType === 0x90 && event.data[2] === 0)) {
                        // Note Off
                        const noteNum = event.data[1];
                        if (activeNotes[noteNum]) {
                            notePairs.push({
                                noteNum,
                                startMs: activeNotes[noteNum].timeMs,
                                endMs: event.timeMs,
                                velocity: activeNotes[noteNum].data[2]
                            });
                            delete activeNotes[noteNum];
                        }
                    } else if (statusType === 0xB0) {
                        // Control Change - collect events for selected CC
                        const ccNum = event.data[1];
                        const ccValue = event.data[2];
                        if (ccNum === selectedCCNum) {
                            ccEvents.push({ timeMs: event.timeMs, value: ccValue });
                        }
                    }
                }
                
                // Determine how many pages we need to render
                // Find the max time in the events (in display time)
                // Convert to actual time by adding lead-in
                let maxTimeMs = 0;
                for (const event of trackEvents) {
                    if (event.timeMs > maxTimeMs) maxTimeMs = event.timeMs;
                }
                const maxActualTimeMs = maxTimeMs + leadInMs;
                const totalPages = Math.ceil(maxActualTimeMs / msPerPage) + 1;
                
                // Render events to appropriate pages (top = even pages, bottom = odd pages)
                // Page times are in actual time (including lead-in)
                for (let pageNum = 0; pageNum < totalPages; pageNum++) {
                    const isTopPage = pageNum % 2 === 0;
                    const group = isTopPage ? topGroup : bottomGroup;
                    const pageStartActualMs = pageNum * msPerPage;
                    const pageEndActualMs = pageStartActualMs + msPerPage;
                    
                    // Convert to display time for event comparison
                    const pageStartDisplayMs = pageStartActualMs - leadInMs;
                    const pageEndDisplayMs = pageEndActualMs - leadInMs;
                    
                    // Render note lines (2px high at top of track)
                    for (const note of notePairs) {
                        // Check if note overlaps with this page (using display time)
                        if (note.endMs < pageStartDisplayMs || note.startMs >= pageEndDisplayMs) continue;
                        
                        // Calculate X positions: convert display time to actual time, then to pixels
                        const startActualMs = note.startMs + leadInMs;
                        const endActualMs = note.endMs + leadInMs;
                        const startX = Math.max(0, (startActualMs - pageStartActualMs) * pixelsPerMs);
                        const endX = Math.min(scoreWidth, (endActualMs - pageStartActualMs) * pixelsPerMs);
                        const width = Math.max(2, endX - startX);
                        
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', startX);
                        rect.setAttribute('y', noteRowY);
                        rect.setAttribute('width', width);
                        rect.setAttribute('height', noteLineHeight);
                        rect.setAttribute('fill', 'black');
                        rect.setAttribute('class', 'midi-note-rect');
                        group.appendChild(rect);
                    }
                    
                    // Render velocity squares (red with white text)
                    for (const vel of velocityEvents) {
                        if (vel.timeMs < pageStartDisplayMs || vel.timeMs >= pageEndDisplayMs) continue;
                        
                        const actualMs = vel.timeMs + leadInMs;
                        const x = (actualMs - pageStartActualMs) * pixelsPerMs;
                        const squareSize = 12;
                        
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x);
                        rect.setAttribute('y', velocityRowY);
                        rect.setAttribute('width', squareSize);
                        rect.setAttribute('height', squareSize);
                        rect.setAttribute('fill', '#E53935'); // Red
                        rect.setAttribute('class', 'midi-velocity-rect');
                        group.appendChild(rect);
                        
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', x + squareSize / 2);
                        text.setAttribute('y', velocityRowY + squareSize / 2 + 3);
                        text.setAttribute('fill', 'white');
                        text.setAttribute('font-size', '8');
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('class', 'midi-velocity-text');
                        text.textContent = vel.velocity;
                        group.appendChild(text);
                    }
                    
                    // Add CC label in upper left corner of CC area (only on first page for this track)
                    if (pageNum === 0) {
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        label.setAttribute('x', '2');
                        label.setAttribute('y', ccRowY + 10);
                        label.setAttribute('fill', '#4CAF50');
                        label.setAttribute('font-family', 'Lato, sans-serif');
                        label.setAttribute('font-size', '9');
                        label.setAttribute('class', 'midi-cc-label');
                        label.textContent = `CC${selectedCCNum} - ${ccName}`;
                        group.appendChild(label);
                    }
                    
                    // Render selected CC as vertical lines from bottom up (value/127 * ccRowHeight)
                    for (const cc of ccEvents) {
                        if (cc.timeMs < pageStartDisplayMs || cc.timeMs >= pageEndDisplayMs) continue;
                        
                        const actualMs = cc.timeMs + leadInMs;
                        const x = (actualMs - pageStartActualMs) * pixelsPerMs;
                        const valueRatio = cc.value / 127;
                        const lineHeight = valueRatio * ccRowHeight;
                        const lineY = ccRowY + ccRowHeight - lineHeight; // start from bottom
                        
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', x);
                        line.setAttribute('y1', ccRowY + ccRowHeight); // bottom of CC area
                        line.setAttribute('x2', x);
                        line.setAttribute('y2', lineY); // top based on value
                        line.setAttribute('stroke', '#4CAF50'); // Green
                        line.setAttribute('stroke-width', '1');
                        line.setAttribute('class', 'midi-cc-line');
                        group.appendChild(line);
                    }
                }
            },
            
            // Render MIDI display for all tracks
            renderAllMidiDisplays() {
                for (let i = 0; i < 4; i++) {
                    this.renderMidiDisplay(i);
                }
            },
            
            // Debug function to check state
            debugState() {
                let msg = '=== MidiController Debug State ===\n';
                msg += 'loadedFileEvents: ' + this.loadedFileEvents.length + '\n';
                msg += 'selectedTrack: ' + this.selectedTrack + '\n';
                for (let i = 0; i < 4; i++) {
                    msg += 'Track ' + (i+1) + ' events: ' + this.tracks[i].midiEvents.length + '\n';
                }
                msg += 'midiDisplayLayers.top: ' + this.midiDisplayLayers.top.length + '\n';
                msg += 'midiDisplayLayers.bottom: ' + this.midiDisplayLayers.bottom.length + '\n';
                msg += 'scoreTopEl: ' + (this.scoreTopEl ? 'found' : 'null') + '\n';
                msg += 'scoreBottomEl: ' + (this.scoreBottomEl ? 'found' : 'null');
                alert(msg);
                return msg;
            }
        };
        
        // Initialize MIDI controller after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                MidiController.init();
                window.MidiController = MidiController;
            });
        } else {
            MidiController.init();
            window.MidiController = MidiController;
        }
        
        // Staff Y Positions - Named Y coordinates for each staff relative to page
        // These define the vertical layout of the 4 staff sections
        const StaffPositions = {
            timelineHeight: 8,  // Y position where staves begin (below timeline numbers)
            
            // Get staff Y positions dynamically based on current page height
            getPositions(scoreEl) {
                const scoreHeight = scoreEl.clientHeight;
                const availableHeight = scoreHeight - this.timelineHeight;
                const staffHeight = availableHeight / 4;
                
                return {
                    Staff1Y: this.timelineHeight,
                    Staff2Y: this.timelineHeight + staffHeight,
                    Staff3Y: this.timelineHeight + (2 * staffHeight),
                    Staff4Y: this.timelineHeight + (3 * staffHeight),
                    staffHeight: staffHeight,
                    availableHeight: availableHeight
                };
            }
        };
        window.StaffPositions = StaffPositions;
        
        // G Track System - Graphic tracks working in Staff Y dimensions
        // Each G Track corresponds to a staff and stores graphic elements
        const GTrackSystem = {
            gTracks: [],       // Array of 4 G Track objects
            scoreTopEl: null,
            scoreBottomEl: null,
            initialized: false,
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                const positions = StaffPositions.getPositions(this.scoreTopEl);
                
                // Create 4 G Tracks
                for (let i = 0; i < 4; i++) {
                    const gTrack = this.createGTrack(i, positions);
                    this.gTracks.push(gTrack);
                }
                
                this.initialized = true;
                console.log('GTrackSystem initialized with 4 G Tracks');
            },
            
            createGTrack(trackIndex, positions) {
                const yPositions = [positions.Staff1Y, positions.Staff2Y, positions.Staff3Y, positions.Staff4Y];
                
                return {
                    index: trackIndex,
                    name: `G Track ${trackIndex + 1}`,
                    yPosition: yPositions[trackIndex],
                    height: positions.staffHeight,
                    
                    // Graphic items array - stores all graphic elements for this track
                    // Each item: { scoreTimeMs, duration, type, props }
                    graphicItems: [],
                    
                    // Link to corresponding MIDI track in TrackSystem
                    midiTrackIndex: trackIndex
                };
            },
            
            // Get G Track by index
            getGTrack(index) {
                if (index >= 0 && index < this.gTracks.length) {
                    return this.gTracks[index];
                }
                return null;
            },
            
            // Add graphic item to a G Track
            addGraphicItem(trackIndex, item) {
                if (trackIndex >= 0 && trackIndex < this.gTracks.length) {
                    this.gTracks[trackIndex].graphicItems.push(item);
                }
            },
            
            // Update dimensions on resize
            updateDimensions() {
                const positions = StaffPositions.getPositions(this.scoreTopEl);
                const yPositions = [positions.Staff1Y, positions.Staff2Y, positions.Staff3Y, positions.Staff4Y];
                
                this.gTracks.forEach((gTrack, index) => {
                    gTrack.yPosition = yPositions[index];
                    gTrack.height = positions.staffHeight;
                });
            },
            
            // Clear all graphic items (called before reload)
            clearAllGraphicItems() {
                this.gTracks.forEach(gTrack => {
                    gTrack.graphicItems = [];
                });
            }
        };
        
        // Initialize G Track System
        GTrackSystem.init();
        window.GTrackSystem = GTrackSystem;
        
        // Edit Cursor - Neon yellow SVG line with draggable triangle handle
        // Spans full page height, can be dragged across timeline
        const EditCursor = {
            scoreTopEl: null,
            scoreBottomEl: null,
            lineTop: null,
            lineBottom: null,
            handleTop: null,
            handleBottom: null,
            currentSection: 'top',    // 'top' or 'bottom'
            positionSeconds: 0,       // Current position in seconds
            isDragging: false,
            inputEl: null,
            initialized: false,
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                this.inputEl = document.getElementById('editCursorSecondsInput');
                
                // Create edit cursor elements for ScoreTop
                this.createCursorElements('top');
                this.createCursorElements('bottom');
                
                // Set up input handling
                this.inputEl.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.jumpToInputValue();
                    }
                });
                
                this.inputEl.addEventListener('blur', () => {
                    this.jumpToInputValue();
                });
                
                // Update on resize
                window.addEventListener('resize', () => {
                    this.updateDimensions();
                });
                
                // Initial position
                this.setPositionSeconds(0);
                
                this.initialized = true;
                console.log('EditCursor initialized');
            },
            
            // Triangle handle size (8px equilateral)
            handleSize: 8,
            
            createCursorElements(section) {
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreHeight = scoreEl.clientHeight;
                const positions = StaffPositions.getPositions(scoreEl);
                
                // Create vertical line spanning full page height below timeline
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', '0');
                line.setAttribute('y1', positions.Staff1Y);
                line.setAttribute('x2', '0');
                line.setAttribute('y2', scoreHeight);
                line.setAttribute('class', 'edit-cursor-line');
                
                // Create upside-down equilateral triangle handle at top of line (8px)
                const handle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const h = this.handleSize;
                const triHeight = h * Math.sqrt(3) / 2; // Height of equilateral triangle
                handle.setAttribute('points', `0,0 ${h},0 ${h/2},${triHeight}`);
                handle.setAttribute('class', 'edit-cursor-handle');
                handle.setAttribute('transform', `translate(-${h/2}, ${positions.Staff1Y - triHeight})`);
                
                // Add drag handlers to both line and handle
                line.addEventListener('mousedown', (e) => this.startDrag(e, section));
                handle.addEventListener('mousedown', (e) => this.startDrag(e, section));
                
                // Add to SVG
                scoreEl.appendChild(line);
                scoreEl.appendChild(handle);
                
                if (section === 'top') {
                    this.lineTop = line;
                    this.handleTop = handle;
                } else {
                    this.lineBottom = line;
                    this.handleBottom = handle;
                    // Initially hide bottom cursor
                    line.style.display = 'none';
                    handle.style.display = 'none';
                }
            },
            
            startDrag(e, section) {
                e.preventDefault();
                this.isDragging = true;
                this.dragSection = section;
                
                // Track current page for wrapping
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const actualSeconds = this.positionSeconds + leadInSeconds;
                this.dragBasePage = Math.floor(actualSeconds / secondsPerPage);
                
                const onMouseMove = (e) => {
                    if (!this.isDragging) return;
                    
                    const scoreEl = this.dragSection === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                    const rect = scoreEl.getBoundingClientRect();
                    let xPercent = ((e.clientX - rect.left) / rect.width) * 100;
                    
                    // Page toggle: wrap to other page when dragging past edges
                    if (xPercent > 100) {
                        // Dragged past right edge - toggle to other page
                        this.dragSection = this.dragSection === 'top' ? 'bottom' : 'top';
                        this.dragBasePage += 1;
                        xPercent = 0;
                    } else if (xPercent < 0) {
                        // Dragged past left edge - toggle to other page (go back)
                        if (this.dragBasePage > 0) {
                            this.dragSection = this.dragSection === 'top' ? 'bottom' : 'top';
                            this.dragBasePage -= 1;
                            xPercent = 100;
                        } else {
                            // At page 0, clamp to 0 (minimum is -leadInSeconds)
                            xPercent = 0;
                        }
                    }
                    
                    xPercent = Math.max(0, Math.min(100, xPercent));
                    
                    // Calculate seconds based on position
                    const seconds = (this.dragBasePage + xPercent / 100) * secondsPerPage - leadInSeconds;
                    
                    // Clamp to minimum of -leadInSeconds
                    const clampedSeconds = Math.max(-leadInSeconds, seconds);
                    
                    this.setPositionSeconds(clampedSeconds);
                };
                
                const onMouseUp = () => {
                    this.isDragging = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            },
            
            setPositionSeconds(seconds) {
                // Clamp to minimum of -leadInSeconds
                this.positionSeconds = Math.max(-leadInSeconds, seconds);
                
                // Update input display
                this.inputEl.value = this.positionSeconds.toFixed(3);
                
                // Calculate which section and x position
                const actualSeconds = this.positionSeconds + leadInSeconds;
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                const totalPages = Math.max(0, actualSeconds / secondsPerPage);
                const pageNumber = Math.floor(totalPages);
                const positionInPage = (totalPages - pageNumber) * 100;
                
                const inTop = pageNumber % 2 === 0;
                
                // Update visibility and position
                if (inTop) {
                    this.lineTop.style.display = 'block';
                    this.handleTop.style.display = 'block';
                    this.lineBottom.style.display = 'none';
                    this.handleBottom.style.display = 'none';
                    this.currentSection = 'top';
                    this.updateCursorPosition(this.lineTop, this.handleTop, positionInPage);
                } else {
                    this.lineTop.style.display = 'none';
                    this.handleTop.style.display = 'none';
                    this.lineBottom.style.display = 'block';
                    this.handleBottom.style.display = 'block';
                    this.currentSection = 'bottom';
                    this.updateCursorPosition(this.lineBottom, this.handleBottom, positionInPage);
                }
            },
            
            updateCursorPosition(line, handle, xPercent) {
                const scoreEl = this.currentSection === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                const xPixels = (xPercent / 100) * scoreWidth;
                const positions = StaffPositions.getPositions(scoreEl);
                const h = this.handleSize;
                const triHeight = h * Math.sqrt(3) / 2;
                
                line.setAttribute('x1', xPixels);
                line.setAttribute('x2', xPixels);
                handle.setAttribute('transform', `translate(${xPixels - h/2}, ${positions.Staff1Y - triHeight})`);
            },
            
            updateDimensions() {
                const positions = StaffPositions.getPositions(this.scoreTopEl);
                const scoreHeight = this.scoreTopEl.clientHeight;
                
                [this.lineTop, this.lineBottom].forEach(line => {
                    if (line) {
                        line.setAttribute('y1', positions.Staff1Y);
                        line.setAttribute('y2', scoreHeight);
                    }
                });
                
                // Re-apply current position
                this.setPositionSeconds(this.positionSeconds);
            },
            
            jumpToInputValue() {
                const seconds = parseFloat(this.inputEl.value) || 0;
                this.setPositionSeconds(seconds);
                
                // Also jump playback cursors to this position
                const actualSeconds = seconds + leadInSeconds;
                ClockSync.socket.emit('scoreGoto', { seconds: actualSeconds });
            },
            
            // Get current position in seconds
            getPositionSeconds() {
                return this.positionSeconds;
            }
        };
        
        // Initialize Edit Cursor
        EditCursor.init();
        window.EditCursor = EditCursor;
        
        // Composition Panel Controls
        const CompositionPanel = {
            panelEl: null,
            toggleEl: null,
            isOpen: false,
            selectedGTrack: 'A',  // 'A' = all (full height), '1'-'4' = specific track
            
            init() {
                this.panelEl = document.getElementById('compositionPanel');
                this.toggleEl = document.getElementById('compositionPanelToggle');
                
                // Toggle panel open/close
                this.toggleEl.addEventListener('click', () => this.toggle());
                
                // G Track radio button listeners
                const radioButtons = document.querySelectorAll('input[name="gtrack"]');
                radioButtons.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.selectedGTrack = e.target.value;
                        console.log(`G Track selected: ${this.selectedGTrack === 'A' ? 'All (full height)' : 'G' + this.selectedGTrack}`);
                    });
                });
            },
            
            toggle() {
                this.isOpen = !this.isOpen;
                this.panelEl.classList.toggle('open', this.isOpen);
                this.toggleEl.textContent = this.isOpen ? '◀ Composition' : '◀ Composition';
            },
            
            // Get selected G Track: returns 'A' for all, or 1-4 for specific track
            getSelectedGTrack() {
                return this.selectedGTrack;
            },
            
            // Get Y position and height for current selection
            getSelectedTrackDimensions(scoreEl) {
                return this.getTrackDimensions(this.selectedGTrack, scoreEl);
            },
            
            // Get Y position and height for a specific gTrack
            getTrackDimensions(gTrack, scoreEl) {
                const positions = StaffPositions.getPositions(scoreEl);
                
                if (gTrack === 'A') {
                    // Full height from Staff1Y to bottom
                    return {
                        y: positions.Staff1Y,
                        height: positions.availableHeight
                    };
                } else {
                    // Specific track
                    const trackIndex = parseInt(gTrack) - 1;
                    const yPositions = [positions.Staff1Y, positions.Staff2Y, positions.Staff3Y, positions.Staff4Y];
                    return {
                        y: yPositions[trackIndex],
                        height: positions.staffHeight
                    };
                }
            }
        };
        
        // Initialize Composition Panel
        CompositionPanel.init();
        window.CompositionPanel = CompositionPanel;
        
        // Curve Database - stores all curves with their attributes
        const CurveDatabase = {
            curves: [],
            nextId: 1,
            
            add(curveData) {
                const curve = {
                    id: this.nextId++,
                    ...curveData,
                    createdAt: Date.now()
                };
                this.curves.push(curve);
                return curve;
            },
            
            get(id) {
                return this.curves.find(c => c.id === id);
            },
            
            update(id, updates) {
                const curve = this.get(id);
                if (curve) {
                    Object.assign(curve, updates);
                }
                return curve;
            },
            
            remove(id) {
                const index = this.curves.findIndex(c => c.id === id);
                if (index !== -1) {
                    this.curves.splice(index, 1);
                }
            },
            
            getAll() {
                return this.curves;
            },
            
            // Export data for saving
            exportData() {
                return {
                    curves: this.curves,
                    nextId: this.nextId
                };
            },
            
            // Import data from saved score
            importData(data) {
                if (data && data.curves) {
                    this.curves = data.curves;
                    this.nextId = data.nextId || (this.curves.length > 0 ? Math.max(...this.curves.map(c => c.id)) + 1 : 1);
                }
            }
        };
        window.CurveDatabase = CurveDatabase;
        
        // ============================================
        // SCORE MANAGER - Client-side persistence
        // ============================================
        const ScoreManager = {
            // UI elements
            nameInput: null,
            saveBtn: null,
            loadBtn: null,
            scoreListSelect: null,
            versionListSelect: null,
            loadVersionBtn: null,
            statusDisplay: null,
            
            // Current score state
            currentScoreName: 'untitled',
            isDirty: false, // Has unsaved changes
            autoSaveInterval: null,
            autoSaveIntervalMs: 60000, // Auto-save every 60 seconds
            
            // Registered data sources for saving/loading
            // Each source: { name, getData: () => data, setData: (data) => void }
            registeredSources: new Map(),
            
            init() {
                // Get UI elements
                this.nameInput = document.getElementById('scoreNameInput');
                this.saveBtn = document.getElementById('scoreSaveBtn');
                this.loadBtn = document.getElementById('scoreLoadBtn');
                this.broadcastLoadBtn = document.getElementById('scoreBroadcastLoadBtn');
                this.scoreListSelect = document.getElementById('scoreListSelect');
                this.versionListSelect = document.getElementById('versionListSelect');
                this.loadVersionBtn = document.getElementById('loadVersionBtn');
                this.statusDisplay = document.getElementById('scoreStatus');
                
                // Set up event listeners
                if (this.saveBtn) {
                    this.saveBtn.addEventListener('click', () => this.saveScore());
                }
                if (this.loadBtn) {
                    this.loadBtn.addEventListener('click', () => this.loadSelectedScore());
                }
                if (this.broadcastLoadBtn) {
                    this.broadcastLoadBtn.addEventListener('click', () => this.loadAndBroadcast());
                }
                if (this.scoreListSelect) {
                    this.scoreListSelect.addEventListener('change', (e) => {
                        if (e.target.value) {
                            this.nameInput.value = e.target.value;
                            this.loadVersionList(e.target.value);
                        }
                    });
                }
                if (this.loadVersionBtn) {
                    this.loadVersionBtn.addEventListener('click', () => this.loadSelectedVersion());
                }
                
                // Register built-in data sources
                this.registerBuiltInSources();
                
                // Load score list
                this.refreshScoreList();
                
                // Listen for score saved events from server
                if (ClockSync.socket) {
                    ClockSync.socket.on('scoreSaved', (data) => {
                        this.updateStatus(`Saved: ${data.name}`);
                        this.isDirty = false;
                    });
                    
                    // Listen for score loaded broadcast from server (sync all clients)
                    ClockSync.socket.on('scoreLoaded', (data) => {
                        console.log(`ScoreManager: Received broadcast to load score '${data.name}'`);
                        this.distributeData(data.data);
                        this.currentScoreName = data.name;
                        this.nameInput.value = data.name;
                        this.isDirty = false;
                        this.updateStatus(`Synced: ${data.name}`);
                        this.loadVersionList(data.name);
                    });
                }
                
                // Start auto-save
                this.startAutoSave();
                
                console.log('ScoreManager initialized');
            },
            
            // Register a data source for saving/loading
            registerSource(name, getData, setData) {
                this.registeredSources.set(name, { name, getData, setData });
                console.log(`ScoreManager: Registered data source '${name}'`);
            },
            
            // Register built-in data sources
            registerBuiltInSources() {
                // Tempo history
                this.registerSource('tempoHistory', 
                    () => serverTempoHistory,
                    (data) => { serverTempoHistory = data || [{ scoreTimeMs: 0, bpm: 60, beatsPerPage: 8 }]; }
                );
                
                // MIDI tracks from MidiController
                this.registerSource('midiTracks',
                    () => {
                        if (!window.MidiController) return [];
                        return MidiController.tracks.map(t => ({
                            channel: t.channel,
                            midiEvents: t.midiEvents.map(e => ({
                                ...e,
                                timestamp: e.timeMs // Ensure timestamp is saved
                            }))
                        }));
                    },
                    (data) => {
                        if (!window.MidiController || !data) return;
                        data.forEach((trackData, i) => {
                            if (i < MidiController.tracks.length) {
                                MidiController.tracks[i].midiEvents = trackData.midiEvents || [];
                            }
                        });
                        MidiController.renderAllMidiDisplays();
                    }
                );
                
                // Graphic tracks from TrackSystem
                this.registerSource('graphicTracks',
                    () => {
                        if (!window.TrackSystem) return [];
                        return TrackSystem.tracks.map(t => ({
                            graphicItems: t.graphicItems.map(item => ({
                                ...item,
                                timestamp: item.scoreTimeMs // Ensure timestamp
                            }))
                        }));
                    },
                    (data) => {
                        if (!window.TrackSystem || !data) return;
                        data.forEach((trackData, i) => {
                            if (i < TrackSystem.tracks.length) {
                                TrackSystem.tracks[i].graphicItems = trackData.graphicItems || [];
                            }
                        });
                        TrackSystem.renderAllTracks();
                    }
                );
                
                // CurveDatabase
                this.registerSource('databases.curves',
                    () => CurveDatabase.exportData(),
                    (data) => {
                        CurveDatabase.importData(data);
                        // Re-render curves if CurveMaker exists
                        if (window.CurveMaker) {
                            CurveMaker.reloadFromDatabase();
                        }
                    }
                );
                
                // SVGElementManager - inserted SVG elements
                this.registerSource('svgElements',
                    () => window.SVGElementManager ? SVGElementManager.exportData() : [],
                    (data) => {
                        if (window.SVGElementManager) {
                            SVGElementManager.importData(data);
                        }
                    }
                );
                
                // FlowchartConnector - connector lines between objects
                this.registerSource('connectors',
                    () => window.FlowchartConnector ? FlowchartConnector.exportData() : [],
                    (data) => {
                        if (window.FlowchartConnector) {
                            FlowchartConnector.importData(data);
                        }
                    }
                );
                
                // NotationManager (registered after NotationManager is initialized)
                // This will be called from NotationManager.init() to register itself
            },
            
            // Register NotationManager (called after NotationManager is initialized)
            registerNotationSource() {
                if (window.NotationManager) {
                    this.registerSource('databases.notation',
                        () => NotationManager.exportData(),
                        (data) => NotationManager.importData(data)
                    );
                }
            },
            
            // Collect all data from registered sources
            collectAllData() {
                const data = {
                    version: '1.0',
                    metadata: {
                        title: this.nameInput?.value || 'Untitled Score',
                        created: new Date().toISOString(),
                        modified: new Date().toISOString(),
                        author: ''
                    },
                    tempoHistory: [],
                    midiTracks: [],
                    graphicTracks: [],
                    databases: {},
                    svgGraphics: []
                };
                
                // Collect from all registered sources
                for (const [name, source] of this.registeredSources) {
                    try {
                        const sourceData = source.getData();
                        
                        // Handle nested paths like 'databases.curves'
                        if (name.includes('.')) {
                            const parts = name.split('.');
                            let target = data;
                            for (let i = 0; i < parts.length - 1; i++) {
                                if (!target[parts[i]]) target[parts[i]] = {};
                                target = target[parts[i]];
                            }
                            target[parts[parts.length - 1]] = sourceData;
                        } else {
                            data[name] = sourceData;
                        }
                    } catch (err) {
                        console.error(`ScoreManager: Error collecting data from '${name}':`, err);
                    }
                }
                
                return data;
            },
            
            // Distribute loaded data to all registered sources
            distributeData(data) {
                for (const [name, source] of this.registeredSources) {
                    try {
                        let sourceData;
                        
                        // Handle nested paths like 'databases.curves'
                        if (name.includes('.')) {
                            const parts = name.split('.');
                            sourceData = data;
                            for (const part of parts) {
                                sourceData = sourceData?.[part];
                            }
                        } else {
                            sourceData = data[name];
                        }
                        
                        if (sourceData !== undefined) {
                            source.setData(sourceData);
                        }
                    } catch (err) {
                        console.error(`ScoreManager: Error distributing data to '${name}':`, err);
                    }
                }
            },
            
            // Save score to server
            async saveScore() {
                const name = this.nameInput?.value?.trim() || 'untitled';
                const data = this.collectAllData();
                
                this.updateStatus('Saving...');
                
                try {
                    const response = await fetch('/api/score/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, data })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.currentScoreName = name;
                        this.isDirty = false;
                        this.updateStatus(`Saved: ${name}`);
                        this.refreshScoreList();
                        console.log(`Score saved: ${name}`);
                    } else {
                        this.updateStatus(`Error: ${result.error}`);
                        console.error('Save failed:', result.error);
                    }
                } catch (err) {
                    this.updateStatus('Save failed');
                    console.error('Save error:', err);
                }
            },
            
            // Load selected score from dropdown
            async loadSelectedScore() {
                const name = this.scoreListSelect?.value || this.nameInput?.value?.trim();
                if (!name) {
                    this.updateStatus('Select a score');
                    return;
                }
                
                await this.loadScore(name);
            },
            
            // Load and broadcast to all connected clients
            async loadAndBroadcast() {
                const name = this.scoreListSelect?.value || this.nameInput?.value?.trim();
                if (!name) {
                    this.updateStatus('Select a score');
                    return;
                }
                
                this.updateStatus('Loading & syncing...');
                
                try {
                    const response = await fetch(`/api/score/load-broadcast/${encodeURIComponent(name)}`, {
                        method: 'POST'
                    });
                    const result = await response.json();
                    
                    if (result.success) {
                        // Data will be distributed via the scoreLoaded socket event
                        console.log(`Score broadcast initiated: ${name}`);
                    } else {
                        this.updateStatus(`Error: ${result.error}`);
                        console.error('Broadcast load failed:', result.error);
                    }
                } catch (err) {
                    this.updateStatus('Broadcast failed');
                    console.error('Broadcast load error:', err);
                }
            },
            
            // Load score from server
            async loadScore(name) {
                this.updateStatus('Loading...');
                
                try {
                    const response = await fetch(`/api/score/load/${encodeURIComponent(name)}`);
                    const result = await response.json();
                    
                    if (result.success) {
                        this.distributeData(result.data);
                        this.currentScoreName = name;
                        this.nameInput.value = name;
                        this.isDirty = false;
                        this.updateStatus(`Loaded: ${name}`);
                        this.loadVersionList(name);
                        console.log(`Score loaded: ${name}`);
                    } else {
                        this.updateStatus(`Error: ${result.error}`);
                        console.error('Load failed:', result.error);
                    }
                } catch (err) {
                    this.updateStatus('Load failed');
                    console.error('Load error:', err);
                }
            },
            
            // Refresh the score list dropdown
            async refreshScoreList() {
                try {
                    const response = await fetch('/api/scores');
                    const scores = await response.json();
                    
                    if (this.scoreListSelect) {
                        this.scoreListSelect.innerHTML = '<option value="">-- Select Score --</option>';
                        scores.forEach(score => {
                            const option = document.createElement('option');
                            option.value = score.name;
                            option.textContent = `${score.title} (${new Date(score.modified).toLocaleDateString()})`;
                            this.scoreListSelect.appendChild(option);
                        });
                    }
                } catch (err) {
                    console.error('Error refreshing score list:', err);
                }
            },
            
            // Load version list for a score
            async loadVersionList(scoreName) {
                try {
                    const response = await fetch(`/api/score/versions/${encodeURIComponent(scoreName)}`);
                    const versions = await response.json();
                    
                    if (this.versionListSelect) {
                        this.versionListSelect.innerHTML = '<option value="">-- Versions --</option>';
                        versions.forEach(version => {
                            const option = document.createElement('option');
                            option.value = version.filename;
                            const date = new Date(version.created);
                            option.textContent = date.toLocaleString();
                            this.versionListSelect.appendChild(option);
                        });
                    }
                } catch (err) {
                    console.error('Error loading version list:', err);
                }
            },
            
            // Load selected version
            async loadSelectedVersion() {
                const filename = this.versionListSelect?.value;
                if (!filename) {
                    this.updateStatus('Select a version');
                    return;
                }
                
                this.updateStatus('Loading version...');
                
                try {
                    const response = await fetch(`/api/score/version/${encodeURIComponent(filename)}`);
                    const result = await response.json();
                    
                    if (result.success) {
                        this.distributeData(result.data);
                        this.isDirty = true; // Mark as dirty since it's a version restore
                        this.updateStatus(`Restored: ${filename}`);
                        console.log(`Version loaded: ${filename}`);
                    } else {
                        this.updateStatus(`Error: ${result.error}`);
                    }
                } catch (err) {
                    this.updateStatus('Load failed');
                    console.error('Load version error:', err);
                }
            },
            
            // Update status display
            updateStatus(message) {
                if (this.statusDisplay) {
                    this.statusDisplay.textContent = message;
                }
            },
            
            // Mark score as dirty (has unsaved changes)
            markDirty() {
                if (!this.isDirty) {
                    this.isDirty = true;
                    this.updateStatus('Unsaved changes');
                }
            },
            
            // Start auto-save interval
            startAutoSave() {
                if (this.autoSaveInterval) {
                    clearInterval(this.autoSaveInterval);
                }
                
                this.autoSaveInterval = setInterval(() => {
                    if (this.isDirty && this.currentScoreName !== 'untitled') {
                        console.log('Auto-saving...');
                        this.saveScore();
                    }
                }, this.autoSaveIntervalMs);
            },
            
            // Stop auto-save
            stopAutoSave() {
                if (this.autoSaveInterval) {
                    clearInterval(this.autoSaveInterval);
                    this.autoSaveInterval = null;
                }
            }
        };
        
        // ============================================
        // NOTATION MANAGER - LilyPond SVG integration
        // ============================================
        const NotationManager = {
            // UI elements
            nameInput: null,
            widthInput: null,
            codeInput: null,
            renderBtn: null,
            placeBtn: null,
            listSelect: null,
            scaleSlider: null,
            scaleValue: null,
            statusDisplay: null,
            
            // Notation items database
            items: [],
            nextId: 1,
            
            // Currently selected notation for placement
            selectedNotation: null,
            currentScale: 1.0,
            
            // SVG container groups
            topNotationGroup: null,
            bottomNotationGroup: null,
            
            // Placed notation elements
            placedNotations: [],
            
            init() {
                // Get UI elements
                this.nameInput = document.getElementById('notationNameInput');
                this.widthInput = document.getElementById('notationWidthInput');
                this.codeInput = document.getElementById('lilypondCodeInput');
                this.renderBtn = document.getElementById('notationRenderBtn');
                this.placeBtn = document.getElementById('notationPlaceBtn');
                this.listSelect = document.getElementById('notationListSelect');
                this.scaleSlider = document.getElementById('notationScaleSlider');
                this.scaleValue = document.getElementById('notationScaleValue');
                this.statusDisplay = document.getElementById('notationStatus');
                
                // Create SVG groups for notation
                const scoreTop = document.getElementById('ScoreTop');
                const scoreBottom = document.getElementById('ScoreBottom');
                
                if (scoreTop) {
                    this.topNotationGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    this.topNotationGroup.setAttribute('class', 'notation-group');
                    scoreTop.appendChild(this.topNotationGroup);
                }
                if (scoreBottom) {
                    this.bottomNotationGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    this.bottomNotationGroup.setAttribute('class', 'notation-group');
                    scoreBottom.appendChild(this.bottomNotationGroup);
                }
                
                // Set up event listeners
                if (this.renderBtn) {
                    this.renderBtn.addEventListener('click', () => this.renderNotation());
                }
                if (this.placeBtn) {
                    this.placeBtn.addEventListener('click', () => this.placeNotation());
                }
                if (this.listSelect) {
                    this.listSelect.addEventListener('change', (e) => {
                        if (e.target.value) {
                            this.selectNotation(e.target.value);
                        }
                    });
                }
                if (this.scaleSlider) {
                    this.scaleSlider.addEventListener('input', (e) => {
                        this.currentScale = parseFloat(e.target.value);
                        if (this.scaleValue) {
                            this.scaleValue.textContent = this.currentScale.toFixed(1);
                        }
                        this.updateSelectedScale();
                    });
                }
                
                // Load existing notation list
                this.refreshNotationList();
                
                console.log('NotationManager initialized');
            },
            
            updateStatus(message) {
                if (this.statusDisplay) {
                    this.statusDisplay.textContent = message;
                }
            },
            
            async renderNotation() {
                const code = this.codeInput?.value?.trim();
                const name = this.nameInput?.value?.trim() || 'snippet';
                const lineWidth = parseInt(this.widthInput?.value) || 100;
                
                if (!code) {
                    this.updateStatus('Enter LilyPond code first');
                    return;
                }
                
                this.updateStatus('Rendering...');
                
                try {
                    const response = await fetch('/api/lilypond/render', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ code, name, lineWidth })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        // Add to local items
                        const item = {
                            id: this.nextId++,
                            name: name,
                            filename: result.filename,
                            path: result.path,
                            svg: result.svg,
                            lilypondCode: code,
                            lilypondFile: result.lilypondFile,
                            createdAt: Date.now()
                        };
                        this.items.push(item);
                        this.selectedNotation = item;
                        
                        this.refreshNotationList();
                        this.updateStatus(`Rendered: ${result.filename}`);
                        
                        // Mark score as dirty
                        if (window.ScoreManager) ScoreManager.markDirty();
                        
                        console.log('Notation rendered:', result.filename);
                    } else {
                        this.updateStatus(`Error: ${result.error}`);
                        console.error('Render failed:', result.details || result.error);
                    }
                } catch (err) {
                    this.updateStatus('Render failed');
                    console.error('Render error:', err);
                }
            },
            
            async refreshNotationList() {
                try {
                    const response = await fetch('/api/lilypond/list');
                    const files = await response.json();
                    
                    if (this.listSelect) {
                        this.listSelect.innerHTML = '<option value="">-- Rendered Notation --</option>';
                        files.forEach(file => {
                            const option = document.createElement('option');
                            option.value = file.path;
                            option.textContent = file.filename;
                            this.listSelect.appendChild(option);
                        });
                    }
                } catch (err) {
                    console.error('Error refreshing notation list:', err);
                }
            },
            
            selectNotation(path) {
                // Find in local items or create reference
                let item = this.items.find(i => i.path === path);
                if (!item) {
                    // Create a reference for server-side file
                    item = {
                        id: this.nextId++,
                        path: path,
                        filename: path.split('/').pop(),
                        name: path.split('/').pop().replace('.svg', '')
                    };
                }
                this.selectedNotation = item;
                this.updateStatus(`Selected: ${item.filename || item.name}`);
            },
            
            placeNotation() {
                if (!this.selectedNotation) {
                    this.updateStatus('Select notation first');
                    return;
                }
                
                // Get edit cursor position
                const editCursorSeconds = window.EditCursor ? EditCursor.positionSeconds : 0;
                
                // Get selected G track
                const gTrackRadio = document.querySelector('input[name="gtrack"]:checked');
                const gTrack = gTrackRadio ? gTrackRadio.value : 'A';
                
                // Determine which section based on current page
                const section = 'top'; // Default to top, could be made dynamic
                
                // Create placed notation object
                const placed = {
                    id: `notation_${Date.now()}`,
                    notationId: this.selectedNotation.id,
                    path: this.selectedNotation.path,
                    svg: this.selectedNotation.svg,
                    scoreTimeMs: editCursorSeconds * 1000,
                    gTrack: gTrack,
                    section: section,
                    scale: this.currentScale,
                    x: 0, // Will be calculated
                    y: 0, // Will be calculated based on track
                    createdAt: Date.now()
                };
                
                this.placedNotations.push(placed);
                this.renderPlacedNotation(placed);
                
                // Mark score as dirty
                if (window.ScoreManager) ScoreManager.markDirty();
                
                this.updateStatus(`Placed at ${editCursorSeconds.toFixed(2)}s`);
            },
            
            renderPlacedNotation(placed) {
                const container = placed.section === 'bottom' ? this.bottomNotationGroup : this.topNotationGroup;
                if (!container) return;
                
                // Calculate X position based on score time
                const scoreWidth = container.ownerSVGElement?.clientWidth || 1000;
                const secondsPerPage = window.GraphicTimeline ? GraphicTimeline.getSecondsPerPage() : 8;
                const leadInSeconds = window.ScoreTime ? ScoreTime.leadInSeconds : 3;
                
                const totalSeconds = (placed.scoreTimeMs / 1000) + leadInSeconds;
                const xPercent = (totalSeconds / secondsPerPage) * 100;
                
                // Calculate Y position based on G track
                let yPosition = 50; // Default middle
                if (placed.gTrack !== 'A') {
                    const trackIndex = parseInt(placed.gTrack) - 1;
                    const trackHeight = 25; // Approximate percentage per track
                    yPosition = 10 + (trackIndex * trackHeight);
                }
                
                // Create SVG group for this notation
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'placed-notation');
                group.setAttribute('data-id', placed.id);
                group.setAttribute('transform', `translate(${xPercent}%, ${yPosition}%) scale(${placed.scale})`);
                
                // If we have inline SVG, parse and embed it
                if (placed.svg) {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(placed.svg, 'image/svg+xml');
                    const svgElement = svgDoc.documentElement;
                    
                    // Copy SVG content into our group
                    Array.from(svgElement.childNodes).forEach(child => {
                        group.appendChild(child.cloneNode(true));
                    });
                } else if (placed.path) {
                    // Use image element for external SVG
                    const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    image.setAttribute('href', placed.path);
                    image.setAttribute('x', '0');
                    image.setAttribute('y', '0');
                    group.appendChild(image);
                }
                
                // Store element reference
                placed.element = group;
                container.appendChild(group);
                
                // Make draggable
                this.makeNotationDraggable(placed);
            },
            
            makeNotationDraggable(placed) {
                if (!placed.element) return;
                
                let isDragging = false;
                let startX, startY;
                let startTransformX, startTransformY;
                
                placed.element.style.cursor = 'move';
                
                placed.element.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    // Parse current transform
                    const transform = placed.element.getAttribute('transform') || '';
                    const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    startTransformX = match ? parseFloat(match[1]) : 0;
                    startTransformY = match ? parseFloat(match[2]) : 0;
                    
                    e.preventDefault();
                    e.stopPropagation();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    
                    const newX = startTransformX + dx;
                    const newY = startTransformY + dy;
                    
                    placed.element.setAttribute('transform', 
                        `translate(${newX}, ${newY}) scale(${placed.scale})`);
                    
                    placed.x = newX;
                    placed.y = newY;
                });
                
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        if (window.ScoreManager) ScoreManager.markDirty();
                    }
                });
            },
            
            updateSelectedScale() {
                // Update scale of selected placed notation if any
                const selected = this.placedNotations.find(p => p.element && p.element.classList.contains('selected'));
                if (selected) {
                    selected.scale = this.currentScale;
                    const transform = selected.element.getAttribute('transform') || '';
                    const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    const x = match ? match[1] : '0';
                    const y = match ? match[2] : '0';
                    selected.element.setAttribute('transform', `translate(${x}, ${y}) scale(${this.currentScale})`);
                }
            },
            
            // Export data for saving
            exportData() {
                return {
                    items: this.items.map(item => ({
                        id: item.id,
                        name: item.name,
                        filename: item.filename,
                        path: item.path,
                        lilypondCode: item.lilypondCode,
                        createdAt: item.createdAt
                    })),
                    placedNotations: this.placedNotations.map(p => ({
                        id: p.id,
                        notationId: p.notationId,
                        path: p.path,
                        scoreTimeMs: p.scoreTimeMs,
                        gTrack: p.gTrack,
                        section: p.section,
                        scale: p.scale,
                        x: p.x,
                        y: p.y,
                        createdAt: p.createdAt
                    })),
                    nextId: this.nextId
                };
            },
            
            // Import data from saved score
            importData(data) {
                if (!data) return;
                
                // Clear existing
                this.items = [];
                this.placedNotations.forEach(p => {
                    if (p.element) p.element.remove();
                });
                this.placedNotations = [];
                
                // Import items
                if (data.items) {
                    this.items = data.items;
                }
                if (data.nextId) {
                    this.nextId = data.nextId;
                }
                
                // Import and render placed notations
                if (data.placedNotations) {
                    data.placedNotations.forEach(p => {
                        this.placedNotations.push(p);
                        this.renderPlacedNotation(p);
                    });
                }
                
                this.refreshNotationList();
                console.log(`NotationManager: Imported ${this.items.length} items, ${this.placedNotations.length} placed`);
            },
            
            // Place string quartet staff labels in the lead-in area (before time 0)
            placeStaffLabels(svgPath = '/notation/string_quartet_template.svg') {
                const scoreTop = document.getElementById('ScoreTop');
                const scoreBottom = document.getElementById('ScoreBottom');
                if (!scoreTop || !scoreBottom) return;
                
                // Get dimensions
                const scoreHeight = scoreTop.clientHeight;
                const scoreWidth = scoreTop.clientWidth;
                const timelineHeight = 8; // Match GraphicTimeline
                const trackHeight = (scoreHeight - timelineHeight) / 4;
                
                // Calculate position: place at the start of lead-in, before time 0
                // Lead-in is typically 3 seconds, so we position at the very left edge
                const leadInSeconds = window.ScoreTime ? ScoreTime.leadInSeconds : 3;
                const secondsPerPage = window.GraphicTimeline ? GraphicTimeline.getSecondsPerPage() : 8;
                
                // Position just before time 0 - calculate X so the right edge is at time 0
                // Time 0 is at (leadInSeconds / secondsPerPage) * 100 percent
                const time0Percent = (leadInSeconds / secondsPerPage) * 100;
                const xPosition = 5; // Start 5px from left edge
                
                // Create image element for the SVG
                const staffLabels = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                staffLabels.setAttribute('href', svgPath);
                staffLabels.setAttribute('x', xPosition);
                staffLabels.setAttribute('y', timelineHeight);
                staffLabels.setAttribute('class', 'staff-labels');
                
                // Scale to fit the track area height (4 tracks)
                const availableHeight = scoreHeight - timelineHeight;
                staffLabels.setAttribute('height', availableHeight);
                staffLabels.setAttribute('preserveAspectRatio', 'xMinYMin meet');
                
                // Add to ScoreTop only (page 1) - not on subsequent pages
                if (this.topNotationGroup) {
                    // Remove any existing staff labels
                    const existing = this.topNotationGroup.querySelector('.staff-labels');
                    if (existing) existing.remove();
                    
                    this.topNotationGroup.appendChild(staffLabels);
                    console.log('Staff labels placed in lead-in area (page 1 only)');
                }
                
                // Remove from ScoreBottom if it exists (we only want it on page 1)
                if (this.bottomNotationGroup) {
                    const existingBottom = this.bottomNotationGroup.querySelector('.staff-labels');
                    if (existingBottom) existingBottom.remove();
                }
            }
        };
        
        // Color map for swatches
        const ColorMap = {
            brightOrange: 'rgba(240,75,0,255)',
            brightBlue: 'rgba(56,126,211,255)',
            mustard: 'rgba(244,182,0,255)',
            brightRed: 'rgba(229,42,25,255)',
            green: 'rgba(0,147,92,255)',
            limeGreen: 'rgb(153,255,0)',
            brightGreen: '#31d196',
            navyBlue: 'rgba(28,72,121,255)',
            plum: 'rgba(82,44,85,255)',
            lavander: 'rgba(162,126,198,255)',
            yellow: 'rgba(254,213,0,255)',
            neonMagenta: 'rgb(255, 21, 160)'
        };
        
        // Curve Maker - creates and manages curves on the timeline
        // Features: auto-naming (CRV###), selection with bounding box, DAW-style curve drag
        const CurveMaker = {
            scoreTopEl: null,
            scoreBottomEl: null,
            topCurveGroup: null,
            bottomCurveGroup: null,
            
            // Rendered curves with elements
            curves: [],
            
            // UI elements
            nameDisplay: null,
            startInput: null,
            endInput: null,
            y1Input: null,
            y2Input: null,
            drawBtn: null,
            
            // Curve naming
            curveCounter: 0,
            
            // Selected curve
            selectedCurve: null,
            
            // Dragging state
            isDragging: false,
            dragTarget: null,  // 'start', 'end', 'curve'
            dragStartX: 0,
            dragStartY: 0,
            
            init() {
                this.scoreTopEl = document.getElementById('ScoreTop');
                this.scoreBottomEl = document.getElementById('ScoreBottom');
                
                // Get UI elements
                this.nameDisplay = document.getElementById('curveNameDisplay');
                this.startInput = document.getElementById('curveStartInput');
                this.endInput = document.getElementById('curveEndInput');
                this.y1Input = document.getElementById('curveY1Input');
                this.y2Input = document.getElementById('curveY2Input');
                this.drawBtn = document.getElementById('curveDrawBtn');
                
                // Create curve container groups
                this.topCurveGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.bottomCurveGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.topCurveGroup.setAttribute('class', 'curve-container');
                this.bottomCurveGroup.setAttribute('class', 'curve-container');
                this.scoreTopEl.appendChild(this.topCurveGroup);
                this.scoreBottomEl.appendChild(this.bottomCurveGroup);
                
                // Draw button handler
                this.drawBtn.addEventListener('click', () => this.createCurve());
                
                // Color swatch handlers - dynamic for selected curve
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.addEventListener('click', (e) => {
                        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                        e.target.classList.add('selected');
                        const newColor = e.target.dataset.color;
                        if (this.selectedCurve) {
                            this.selectedCurve.color = newColor;
                            this.updateCurveRendering(this.selectedCurve);
                            this.syncCurveToDatabase(this.selectedCurve);
                            // Update visibility to refresh continuation segments
                            this.updateVisibility();
                        }
                    });
                });
                
                // Fill mode handlers - dynamic for selected curve
                document.querySelectorAll('input[name="curveFill"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        const newFillMode = e.target.value;
                        if (this.selectedCurve) {
                            this.selectedCurve.fillMode = newFillMode;
                            this.updateCurveRendering(this.selectedCurve);
                            this.syncCurveToDatabase(this.selectedCurve);
                            // Update visibility to refresh continuation segments
                            this.updateVisibility();
                        }
                    });
                });
                
                // Input field handlers - dynamic for selected curve
                this.startInput.addEventListener('change', () => this.updateSelectedFromInputs());
                this.endInput.addEventListener('change', () => this.updateSelectedFromInputs());
                this.y1Input.addEventListener('change', () => this.updateSelectedFromInputs());
                this.y2Input.addEventListener('change', () => this.updateSelectedFromInputs());
                
                // Click on score to deselect
                this.scoreTopEl.addEventListener('click', (e) => this.handleScoreClick(e, 'top'));
                this.scoreBottomEl.addEventListener('click', (e) => this.handleScoreClick(e, 'bottom'));
                
                // Delete/Backspace to delete selected curve
                document.addEventListener('keydown', (e) => {
                    if ((e.key === 'Delete' || e.key === 'Backspace') && this.selectedCurve) {
                        // Don't delete if focus is in an input field
                        if (document.activeElement.tagName === 'INPUT') return;
                        e.preventDefault();
                        this.deleteSelectedCurve();
                    }
                });
                
                console.log('CurveMaker initialized');
            },
            
            generateCurveName() {
                this.curveCounter++;
                return `CRV${String(this.curveCounter).padStart(3, '0')}`;
            },
            
            generateCurveDataArray(curve) {
                // TIMECODE-BASED SYSTEM: Generate samples at fixed time intervals
                // Sample rate: 100 samples/second (10ms intervals) for smooth curves
                // Each entry contains normalized Y value
                // For G1-G4: normalized 0-1 from bottom to top of track
                // For GA: normalized 0-1 from bottom of page to top of cursor area
                
                const SAMPLE_INTERVAL = 0.01; // 10ms = 100 samples/second
                const startTime = curve.startSeconds;
                const endTime = curve.endSeconds;
                const duration = endTime - startTime;
                
                if (duration <= 0) return { startTime, endTime, sampleInterval: SAMPLE_INTERVAL, samples: [] };
                
                const sampleCount = Math.ceil(duration / SAMPLE_INTERVAL) + 1;
                const samples = [];
                const slope = curve.slope || 0;
                
                // Use normalized Y values (0-10 scale) for consistent curve data
                // These are the authoritative values, not the pixel values which can change
                const y1Norm = curve.y1 / 10;  // 0 to 1
                const y2Norm = curve.y2 / 10;  // 0 to 1
                
                // Calculate control point Y in normalized space (same logic as rendering)
                const ctrlYNorm = slope >= 0 
                    ? y1Norm + (y2Norm - y1Norm) * (1 - Math.abs(slope)) * 0.5
                    : y2Norm - (y2Norm - y1Norm) * (1 - Math.abs(slope)) * 0.5;
                
                // Calculate control point X position in normalized space (0 to 1)
                // ctrlX is at 0.5 + slope * 0.45 of the curve width
                const ctrlXNorm = 0.5 + slope * 0.45;
                
                // Generate samples at fixed time intervals
                for (let i = 0; i < sampleCount; i++) {
                    const time = startTime + (i * SAMPLE_INTERVAL);
                    
                    // Calculate normalized position (0 to 1) based on time
                    const timeT = Math.min(1, (time - startTime) / duration);
                    
                    // For a quadratic bezier in normalized X space (0 to 1):
                    // X(t) = (1-t)²*0 + 2(1-t)t*ctrlXNorm + t²*1
                    // We need to find t such that X(t) = timeT
                    // Solve: 2(1-t)t*ctrlXNorm + t² = timeT
                    // Rearranging: t²(1 - 2*ctrlXNorm) + t*2*ctrlXNorm - timeT = 0
                    const a = 1 - 2 * ctrlXNorm;
                    const b = 2 * ctrlXNorm;
                    const c = -timeT;
                    
                    let t;
                    if (Math.abs(a) < 0.0001) {
                        // Linear case (ctrlXNorm is at 0.5)
                        t = timeT;
                    } else {
                        // Quadratic formula: t = (-b + sqrt(b² - 4ac)) / 2a
                        const discriminant = b * b - 4 * a * c;
                        if (discriminant < 0) {
                            t = timeT; // Fallback
                        } else {
                            const sqrtD = Math.sqrt(discriminant);
                            const t1 = (-b + sqrtD) / (2 * a);
                            const t2 = (-b - sqrtD) / (2 * a);
                            // Choose t in range [0, 1]
                            t = (t1 >= 0 && t1 <= 1) ? t1 : t2;
                            t = Math.max(0, Math.min(1, t));
                        }
                    }
                    
                    // Now calculate Y using the correct t value in normalized space
                    // Quadratic bezier: B(t) = (1-t)²P0 + 2(1-t)tP1 + t²P2
                    const oneMinusT = 1 - t;
                    const normalizedY = oneMinusT * oneMinusT * y1Norm 
                                      + 2 * oneMinusT * t * ctrlYNorm 
                                      + t * t * y2Norm;
                    
                    // Clamp to valid range
                    samples.push(Math.max(0, Math.min(1, normalizedY)));
                }
                
                return {
                    startTime,
                    endTime,
                    sampleInterval: SAMPLE_INTERVAL,
                    samples  // Array of normalizedY values, indexed by time
                };
            },
            
            createCurve() {
                const startSeconds = parseFloat(this.startInput.value) || 0;
                const endSeconds = parseFloat(this.endInput.value) || 1;
                const y1 = parseFloat(this.y1Input.value) || 0;
                const y2 = parseFloat(this.y2Input.value) || 10;
                const gTrack = CompositionPanel.getSelectedGTrack();
                
                // Get current fill mode and color from UI
                const fillMode = document.querySelector('input[name="curveFill"]:checked').value;
                const colorSwatch = document.querySelector('.color-swatch.selected');
                const color = colorSwatch ? colorSwatch.dataset.color : 'brightOrange';
                
                // Get track dimensions - use the section where the curve starts
                // Note: Both top and bottom sections have the same coordinate system
                const trackDims = CompositionPanel.getSelectedTrackDimensions(this.scoreTopEl);
                // Store gTrack for later use in multi-page rendering
                const gTrackForDims = CompositionPanel.getSelectedGTrack();
                
                // Calculate pixel positions
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                // Determine which page(s) the curve spans
                const startActual = startSeconds + leadInSeconds;
                const endActual = endSeconds + leadInSeconds;
                const startPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                
                // Draw on the start page
                const section = startPage % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const curveGroup = section === 'top' ? this.topCurveGroup : this.bottomCurveGroup;
                const scoreWidth = scoreEl.clientWidth;
                
                // Calculate X positions as percentages within the page
                const startXPercent = ((startActual / secondsPerPage) - startPage) * 100;
                const endXPercent = ((endActual / secondsPerPage) - startPage) * 100;
                
                // Calculate Y positions (0 = bottom of track, 10 = top of track)
                const trackBottom = trackDims.y + trackDims.height;
                const y1Pixel = trackBottom - (y1 / 10) * trackDims.height;
                const y2Pixel = trackBottom - (y2 / 10) * trackDims.height;
                
                // Calculate pixel positions
                const x1Pixel = (startXPercent / 100) * scoreWidth;
                const x2Pixel = (endXPercent / 100) * scoreWidth;
                
                // DAW-style curve: single control point for curvature (tension)
                // tension: 0 = straight line, positive = curve up, negative = curve down
                const tension = 0;
                
                // Generate unique name
                const name = this.generateCurveName();
                
                // Create curve data
                const curveDataObj = {
                    name,
                    startSeconds,
                    endSeconds,
                    y1,
                    y2,
                    gTrack,
                    color,
                    fillMode,
                    section,
                    page: startPage,
                    x1: x1Pixel,
                    y1Pixel,
                    x2: x2Pixel,
                    y2Pixel,
                    // Store original values for multi-page clipping
                    origY1Pixel: y1Pixel,
                    origY2Pixel: y2Pixel,
                    tension,  // DAW-style: vertical drag changes depth
                    slope: 0,  // DAW-style: horizontal drag shifts apex position
                    trackDims
                };
                
                // Generate curveData array (normalized Y values for each horizontal pixel)
                const curveDataArray = this.generateCurveDataArray(curveDataObj);
                curveDataObj.curveData = curveDataArray;
                
                // Add to database
                const curve = CurveDatabase.add(curveDataObj);
                
                // Mark score as dirty (has unsaved changes)
                if (window.ScoreManager) ScoreManager.markDirty();
                
                // Add to G Track graphic data
                if (gTrack !== 'A') {
                    const trackIndex = parseInt(gTrack) - 1;
                    if (window.GTrackSystem) {
                        GTrackSystem.addGraphicItem(trackIndex, {
                            type: 'curve',
                            curveId: curve.id,
                            curveName: curve.name,
                            color: color,
                            fillMode: fillMode,
                            scoreTimeMs: startSeconds * 1000,
                            duration: (endSeconds - startSeconds) * 1000,
                            curveData: curveDataArray
                        });
                    }
                }
                
                // Render the curve
                this.renderCurve(curve, curveGroup, scoreEl);
                
                // Add to curves array for connector system
                this.curves.push(curve);
                
                // Update visibility to handle multi-page curves
                this.updateVisibility();
                
                // Auto-select the new curve
                this.selectCurve(curve);
                
                console.log(`Curve created: ${curve.name} (ID: ${curve.id})`);
            },
            
            renderCurve(curve, curveGroup, scoreEl) {
                const color = ColorMap[curve.color] || curve.color;
                
                // Create SVG group for this curve
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('data-curve-id', curve.id);
                group.setAttribute('class', 'curve-element');
                
                // DAW-style curve shaping:
                // slope controls where the "knee" is (-1 = left edge, +1 = right edge)
                // Drag right = flat at start, steep rise at end
                // Drag left = steep rise at start, flat at end
                // Curve stays within Y bounds of endpoints (no protrusion)
                const slope = curve.slope || 0;
                const curveWidth = curve.x2 - curve.x1;
                
                // Control point X: slope moves it from left edge to right edge
                // slope -1 = control at x1, slope +1 = control at x2, slope 0 = middle
                const ctrlX = curve.x1 + (curveWidth * (0.5 + slope * 0.45));
                
                // Control point Y: stays at the Y value of the opposite endpoint
                // This creates the "flat then steep" or "steep then flat" effect
                // When slope > 0 (dragging right): ctrl Y near y1 (start), curve flat then rises
                // When slope < 0 (dragging left): ctrl Y near y2 (end), curve rises then flat
                const ctrlY = slope >= 0 
                    ? curve.y1Pixel + (curve.y2Pixel - curve.y1Pixel) * (1 - Math.abs(slope)) * 0.5
                    : curve.y2Pixel - (curve.y2Pixel - curve.y1Pixel) * (1 - Math.abs(slope)) * 0.5;
                
                // Create the quadratic bezier path
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const d = `M ${curve.x1} ${curve.y1Pixel} Q ${ctrlX} ${ctrlY}, ${curve.x2} ${curve.y2Pixel}`;
                
                if (curve.fillMode === 'line' || !curve.trackDims) {
                    // Line mode or missing trackDims - just draw the curve
                    path.setAttribute('d', d);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', '2');
                } else {
                    const fillY = curve.fillMode === 'bottom' ? curve.trackDims.y + curve.trackDims.height : curve.trackDims.y;
                    const filledD = `M ${curve.x1} ${fillY} L ${curve.x1} ${curve.y1Pixel} Q ${ctrlX} ${ctrlY}, ${curve.x2} ${curve.y2Pixel} L ${curve.x2} ${fillY} Z`;
                    path.setAttribute('d', filledD);
                    path.setAttribute('fill', color);
                    path.setAttribute('fill-opacity', '0.3');
                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', '2');
                }
                
                path.style.cursor = 'pointer';
                group.appendChild(path);
                
                // Create invisible wider hit area for easier clicking on the curve
                const hitPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                hitPath.setAttribute('d', d);
                hitPath.setAttribute('fill', 'none');
                hitPath.setAttribute('stroke', 'transparent');
                hitPath.setAttribute('stroke-width', '20');
                hitPath.style.cursor = 'pointer';
                hitPath.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'curve'));
                path.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'curve'));
                group.appendChild(hitPath);
                
                // Create draggable endpoint circles
                const pointRadius = 6;
                
                // Start point
                const startPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                startPoint.setAttribute('cx', curve.x1);
                startPoint.setAttribute('cy', curve.y1Pixel);
                startPoint.setAttribute('r', pointRadius);
                startPoint.setAttribute('fill', color);
                startPoint.setAttribute('stroke', '#fff');
                startPoint.setAttribute('stroke-width', '2');
                startPoint.style.cursor = 'ns-resize';
                startPoint.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'start'));
                group.appendChild(startPoint);
                
                // End point
                const endPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                endPoint.setAttribute('cx', curve.x2);
                endPoint.setAttribute('cy', curve.y2Pixel);
                endPoint.setAttribute('r', pointRadius);
                endPoint.setAttribute('fill', color);
                endPoint.setAttribute('stroke', '#fff');
                endPoint.setAttribute('stroke-width', '2');
                endPoint.style.cursor = 'ns-resize';
                endPoint.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'end'));
                group.appendChild(endPoint);
                
                // Bounding box (hidden by default, colored to match curve)
                const bbox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bbox.setAttribute('class', 'curve-bounding-box');
                bbox.setAttribute('stroke', color);
                bbox.setAttribute('fill', color);
                bbox.style.display = 'none';
                bbox.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'bbox'));
                group.insertBefore(bbox, path);
                
                // Store element references
                curve.elements = {
                    group,
                    path,
                    hitPath,
                    startPoint,
                    endPoint,
                    boundingBox: bbox
                };
                
                curveGroup.appendChild(group);
                this.updateBoundingBox(curve);
            },
            
            handleCurveMouseDown(e, curve, target) {
                e.preventDefault();
                e.stopPropagation();
                
                // Select this curve
                this.selectCurve(curve);
                
                // If clicking on bounding box (not on curve/endpoints), just select, don't drag
                if (target === 'bbox') return;
                
                // Start dragging
                this.isDragging = true;
                this.dragTarget = target;
                this.dragStartX = e.clientX;
                this.dragStartY = e.clientY;
                
                // All controls are on the first segment, so use its section
                const scoreEl = curve.section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const rect = scoreEl.getBoundingClientRect();
                const trackDims = curve.trackDims;
                
                // Store initial curve state for curve drag
                const initialTension = curve.tension;
                const initialSlope = curve.slope || 0;  // slope: shifts the apex left/right
                const initialY1 = curve.y1Pixel;
                const initialY2 = curve.y2Pixel;
                
                const onMouseMove = (e) => {
                    if (!this.isDragging) return;
                    
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const deltaX = e.clientX - this.dragStartX;
                    const deltaY = e.clientY - this.dragStartY;
                    
                    // Clamp Y to track bounds
                    const clampedY = Math.max(trackDims.y, Math.min(trackDims.y + trackDims.height, y));
                    
                    switch (this.dragTarget) {
                        case 'start':
                            // Vertical only - X stays fixed
                            // Update both current and original Y values for multi-page support
                            curve.y1Pixel = clampedY;
                            curve.origY1Pixel = clampedY;
                            // Also update normalized y1 value
                            curve.y1 = ((trackDims.y + trackDims.height - clampedY) / trackDims.height) * 10;
                            break;
                        case 'end':
                            // Vertical only - X stays fixed
                            // Update both current and original Y values for multi-page support
                            curve.y2Pixel = clampedY;
                            curve.origY2Pixel = clampedY;
                            // Also update normalized y2 value
                            curve.y2 = ((trackDims.y + trackDims.height - clampedY) / trackDims.height) * 10;
                            break;
                        case 'curve':
                        case 'preview':
                            // DAW-style curve shaping - horizontal drag only
                            // Maps mouse X position within first segment bounds to slope (-1 to +1)
                            // For multi-page curves, use first segment (curve.x1 to page edge)
                            // Drag right = flat start, steep end (slope +1)
                            // Drag left = steep start, flat end (slope -1)
                            
                            // Use first segment bounds for slope calculation
                            const segmentLeft = curve.x1;
                            const segmentRight = scoreEl.clientWidth; // Page edge for multi-page, or curve.x2 for single
                            const isMultiPageCurve = curve.x2 > scoreEl.clientWidth;
                            const segmentWidth = (isMultiPageCurve ? segmentRight : curve.x2) - segmentLeft;
                            
                            if (segmentWidth > 0) {
                                // Map mouse X to slope: left edge = -1, right edge = +1
                                const relativeX = (x - segmentLeft) / segmentWidth;
                                curve.slope = Math.max(-1, Math.min(1, (relativeX - 0.5) * 2));
                            }
                            break;
                    }
                    
                    // Update input fields
                    this.updateInputsFromCurve(curve);
                    
                    // Re-render curve (primary segment)
                    this.updateCurveRendering(curve);
                    this.updateBoundingBox(curve);
                    
                    // Update all segments for multi-page curves
                    this.updateVisibility();
                    
                    // Update preview curve for multi-page curves
                    this.updatePreviewCurve(curve);
                    
                    // Sync to database
                    this.syncCurveToDatabase(curve);
                };
                
                const onMouseUp = () => {
                    this.isDragging = false;
                    this.dragTarget = null;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            },
            
            handleScoreClick(e, section) {
                // Check if click was on a curve element
                if (e.target.closest('.curve-element')) return;
                
                // Deselect current curve
                this.deselectCurve();
            },
            
            selectCurve(curve) {
                // Deselect previous
                if (this.selectedCurve && this.selectedCurve !== curve) {
                    this.deselectCurve();
                }
                
                this.selectedCurve = curve;
                
                // Show bounding box and endpoint circles on first segment only
                // For multi-page curves, all controls are on the first segment
                if (curve.elements) {
                    if (curve.elements.boundingBox) curve.elements.boundingBox.style.display = 'block';
                    if (curve.elements.startPoint) curve.elements.startPoint.style.display = 'block';
                    if (curve.elements.endPoint) curve.elements.endPoint.style.display = 'block';
                    
                    // Show preview curve for multi-page curves
                    this.updatePreviewCurve(curve);
                }
                
                // Update UI to reflect selected curve
                this.nameDisplay.value = curve.name;
                this.updateInputsFromCurve(curve);
                
                // Update color swatch selection
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                const matchingSwatch = document.querySelector(`.color-swatch[data-color="${curve.color}"]`);
                if (matchingSwatch) matchingSwatch.classList.add('selected');
                
                // Update fill mode selection
                document.querySelector(`input[name="curveFill"][value="${curve.fillMode}"]`).checked = true;
            },
            
            deselectCurve() {
                if (this.selectedCurve && this.selectedCurve.elements) {
                    // Hide all controls on first segment
                    if (this.selectedCurve.elements.boundingBox) this.selectedCurve.elements.boundingBox.style.display = 'none';
                    if (this.selectedCurve.elements.startPoint) this.selectedCurve.elements.startPoint.style.display = 'none';
                    if (this.selectedCurve.elements.endPoint) this.selectedCurve.elements.endPoint.style.display = 'none';
                    // Hide preview curve and hit path
                    if (this.selectedCurve.elements.previewPath) this.selectedCurve.elements.previewPath.style.display = 'none';
                    if (this.selectedCurve.elements.previewHitPath) this.selectedCurve.elements.previewHitPath.style.display = 'none';
                }
                this.selectedCurve = null;
                this.nameDisplay.value = '';
            },
            
            // Create/update preview curve showing entire curve shape within the first segment
            // For multi-page curves, this is the INTERACTIVE controller for the entire curve
            updatePreviewCurve(curve) {
                if (!curve.elements || !curve.elements.boundingBox) return;
                if (!curve.trackDims) return;
                
                const secondsPerPage = window.GraphicTimeline ? GraphicTimeline.getSecondsPerPage() : 8;
                const leadInSec = leadInSeconds;
                
                // Check if this is a multi-page curve
                const startActual = curve.startSeconds + leadInSec;
                const endActual = curve.endSeconds + leadInSec;
                const curveStartPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                const curveEndPage = Math.floor(Math.max(0, endActual) / secondsPerPage);
                
                const isMultiPage = curveEndPage > curveStartPage;
                
                // Create preview elements if they don't exist
                if (!curve.elements.previewPath) {
                    const previewPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    previewPath.setAttribute('class', 'curve-preview');
                    previewPath.setAttribute('fill', 'none');
                    previewPath.setAttribute('stroke-width', '2');
                    previewPath.setAttribute('stroke-dasharray', '4,3');
                    previewPath.setAttribute('opacity', '0.9');
                    previewPath.style.cursor = 'ew-resize';
                    // Make preview path interactive for slope adjustment
                    previewPath.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'preview'));
                    curve.elements.group.appendChild(previewPath);
                    curve.elements.previewPath = previewPath;
                    
                    // Create hit area for preview curve
                    const previewHitPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    previewHitPath.setAttribute('fill', 'none');
                    previewHitPath.setAttribute('stroke', 'transparent');
                    previewHitPath.setAttribute('stroke-width', '20');
                    previewHitPath.style.cursor = 'ew-resize';
                    previewHitPath.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'preview'));
                    curve.elements.group.appendChild(previewHitPath);
                    curve.elements.previewHitPath = previewHitPath;
                }
                
                const previewPath = curve.elements.previewPath;
                const previewHitPath = curve.elements.previewHitPath;
                const color = ColorMap[curve.color] || curve.color;
                previewPath.setAttribute('stroke', color);
                
                if (!isMultiPage) {
                    // Single page curve - hide preview (solid curve is the controller)
                    previewPath.style.display = 'none';
                    if (previewHitPath) previewHitPath.style.display = 'none';
                    return;
                }
                
                // Multi-page curve - show preview as the controller
                previewPath.style.display = 'block';
                if (previewHitPath) previewHitPath.style.display = 'block';
                
                // Get first segment bounds (from curve.x1 to page edge)
                const scoreEl = curve.section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                const segmentX1 = curve.x1;
                const segmentX2 = scoreWidth;
                
                // Preview spans the full first segment width
                const previewX1 = segmentX1;
                const previewX2 = segmentX2;
                
                // Preview Y uses the FULL track height for control points
                // This allows full Y range adjustment even though it's a scaled representation
                const trackTop = curve.trackDims.y;
                const trackBottom = curve.trackDims.y + curve.trackDims.height;
                const trackHeight = curve.trackDims.height;
                
                // Map normalized Y values (0-10) to track coordinates
                const previewY1 = trackBottom - (curve.y1 / 10) * trackHeight;
                const previewY2 = trackBottom - (curve.y2 / 10) * trackHeight;
                
                // Calculate control point for preview using the curve's slope
                const slope = curve.slope || 0;
                const previewWidth = previewX2 - previewX1;
                const ctrlXOffset = previewWidth * 0.5 * (1 + slope);
                const ctrlX = previewX1 + ctrlXOffset;
                
                // Control point Y based on slope direction
                const ctrlY = slope >= 0 
                    ? previewY1 + (previewY2 - previewY1) * (1 - Math.abs(slope)) * 0.5
                    : previewY2 - (previewY2 - previewY1) * (1 - Math.abs(slope)) * 0.5;
                
                const pathD = `M ${previewX1} ${previewY1} Q ${ctrlX} ${ctrlY} ${previewX2} ${previewY2}`;
                previewPath.setAttribute('d', pathD);
                if (previewHitPath) previewHitPath.setAttribute('d', pathD);
                
                // Update control point positions to match preview endpoints
                if (curve.elements.startPoint) {
                    curve.elements.startPoint.setAttribute('cx', previewX1);
                    curve.elements.startPoint.setAttribute('cy', previewY1);
                }
                if (curve.elements.endPoint) {
                    curve.elements.endPoint.setAttribute('cx', previewX2);
                    curve.elements.endPoint.setAttribute('cy', previewY2);
                }
            },
            
            // Show/hide curves based on current page (supports multi-page curves)
            updateVisibility() {
                if (!window.GraphicTimeline) return;
                
                const topPage = GraphicTimeline.currentTopPage;
                const bottomPage = GraphicTimeline.currentBottomPage;
                const secondsPerPage = GraphicTimeline.getSecondsPerPage();
                // Use the global leadInSeconds variable directly
                const leadInSec = leadInSeconds;
                
                // Iterate directly over CurveMaker.curves
                for (let i = 0; i < CurveMaker.curves.length; i++) {
                    const curve = CurveMaker.curves[i];
                    if (!curve.elements || !curve.elements.group) continue;
                    
                    // Calculate which pages this curve spans
                    const startActual = curve.startSeconds + leadInSec;
                    const endActual = curve.endSeconds + leadInSec;
                    const curveStartPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                    const curveEndPage = Math.floor(Math.max(0, endActual) / secondsPerPage);
                    
                    // Check if curve overlaps with EITHER visible page (top or bottom)
                    const overlapsTop = curveStartPage <= topPage && curveEndPage >= topPage;
                    const overlapsBottom = curveStartPage <= bottomPage && curveEndPage >= bottomPage;
                    const visible = overlapsTop || overlapsBottom;
                    
                    // For multi-page curves, we need to show segments on BOTH visible pages
                    const isMultiPage = curveEndPage > curveStartPage;
                    
                    if (!isMultiPage) {
                        // Single-page curve: simple show/hide
                        curve.elements.group.style.display = visible ? '' : 'none';
                        // Hide continuation segment if it exists
                        if (curve.elements.continuationGroup) {
                            curve.elements.continuationGroup.style.display = 'none';
                        }
                    } else {
                        // Multi-page curve: show segments on each visible page
                        // Original segment on original page (clipped to page end)
                        if (overlapsTop && topPage === curveStartPage) {
                            curve.elements.group.style.display = '';
                            this.clipCurveToPageEnd(curve, curveStartPage, secondsPerPage, leadInSec);
                        } else if (overlapsBottom && bottomPage === curveStartPage) {
                            curve.elements.group.style.display = '';
                            this.clipCurveToPageEnd(curve, curveStartPage, secondsPerPage, leadInSec);
                        } else {
                            curve.elements.group.style.display = 'none';
                        }
                        
                        // Continuation segments on subsequent pages
                        // For curves spanning 3+ pages, we may need segments on BOTH visible pages
                        const showContinuationOnTop = overlapsTop && topPage > curveStartPage && topPage <= curveEndPage;
                        const showContinuationOnBottom = overlapsBottom && bottomPage > curveStartPage && bottomPage <= curveEndPage;
                        
                        // Show continuation on top page
                        if (showContinuationOnTop) {
                            this.showContinuationSegment(curve, topPage, secondsPerPage, leadInSec, 'top');
                        } else if (curve.elements.continuationGroupTop) {
                            curve.elements.continuationGroupTop.style.display = 'none';
                        }
                        
                        // Show continuation on bottom page
                        if (showContinuationOnBottom) {
                            this.showContinuationSegment(curve, bottomPage, secondsPerPage, leadInSec, 'bottom');
                        } else if (curve.elements.continuationGroupBottom) {
                            curve.elements.continuationGroupBottom.style.display = 'none';
                        }
                        
                        // Hide old single continuation group if it exists
                        if (curve.elements.continuationGroup) {
                            curve.elements.continuationGroup.style.display = 'none';
                        }
                    }
                }
            },
            
            // Clip the original curve segment to end at the page boundary
            // Uses curveData samples for pixel-accurate rendering
            clipCurveToPageEnd(curve, page, secondsPerPage, leadInSec) {
                if (!curve.elements || !curve.elements.path) return;
                
                const startActual = curve.startSeconds + leadInSec;
                const endActual = curve.endSeconds + leadInSec;
                const pageEndTime = (page + 1) * secondsPerPage;
                
                // If curve ends before page end, use original rendering
                if (endActual <= pageEndTime) {
                    this.restoreOriginalRendering(curve);
                    return;
                }
                
                const section = page % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                
                // Use curveData samples for pixel-accurate curve rendering
                const pathD = this.generatePathFromCurveData(curve, curve.startSeconds, 
                    pageEndTime - leadInSec, scoreEl, curve.x1, scoreWidth);
                
                if (pathD) {
                    curve.elements.path.setAttribute('d', pathD);
                    if (curve.elements.hitPath) curve.elements.hitPath.setAttribute('d', pathD);
                }
                
                // Ensure in correct container
                const targetContainer = section === 'top' ? this.topCurveGroup : this.bottomCurveGroup;
                if (curve.elements.group.parentNode !== targetContainer) {
                    targetContainer.appendChild(curve.elements.group);
                }
            },
            
            // Generate SVG path from curveData samples for pixel-accurate rendering
            // This uses the same data as the curve follower for perfect alignment
            generatePathFromCurveData(curve, startSec, endSec, scoreEl, x1Pixel, x2Pixel) {
                if (!curve.curveData || !curve.curveData.samples || curve.curveData.samples.length === 0) {
                    return null;
                }
                
                const { startTime, endTime, sampleInterval, samples } = curve.curveData;
                const trackDims = curve.trackDims;
                if (!trackDims) return null;
                
                const trackTop = trackDims.y;
                const trackBottom = trackDims.y + trackDims.height;
                const trackHeight = trackDims.height;
                
                // Clamp to curve bounds
                const clampedStart = Math.max(startSec, startTime);
                const clampedEnd = Math.min(endSec, endTime);
                
                if (clampedStart >= clampedEnd) return null;
                
                // Calculate pixel range
                const curveDuration = endTime - startTime;
                const segmentWidth = x2Pixel - x1Pixel;
                
                // Sample every few pixels for smooth curve (every 2-3 pixels)
                const pixelStep = 2;
                const points = [];
                
                for (let x = x1Pixel; x <= x2Pixel; x += pixelStep) {
                    // Map pixel X to time
                    const xProgress = (x - x1Pixel) / segmentWidth;
                    const timeSec = clampedStart + xProgress * (clampedEnd - clampedStart);
                    
                    // Get sample index
                    const sampleIndex = Math.floor((timeSec - startTime) / sampleInterval);
                    if (sampleIndex < 0 || sampleIndex >= samples.length) continue;
                    
                    // Get normalized Y (0-1, where 1 is top)
                    const normalizedY = samples[sampleIndex];
                    
                    // Convert to pixel Y (invert because SVG Y increases downward)
                    const yPixel = trackBottom - normalizedY * trackHeight;
                    
                    points.push({ x, y: yPixel });
                }
                
                // Add final point at x2Pixel
                if (points.length > 0 && points[points.length - 1].x < x2Pixel) {
                    const timeSec = clampedEnd;
                    const sampleIndex = Math.min(samples.length - 1, Math.floor((timeSec - startTime) / sampleInterval));
                    const normalizedY = samples[sampleIndex];
                    const yPixel = trackBottom - normalizedY * trackHeight;
                    points.push({ x: x2Pixel, y: yPixel });
                }
                
                if (points.length < 2) return null;
                
                // Build path - use line segments for accuracy
                let pathD = `M ${points[0].x} ${points[0].y}`;
                for (let i = 1; i < points.length; i++) {
                    pathD += ` L ${points[i].x} ${points[i].y}`;
                }
                
                // Handle fill mode
                if (curve.fillMode !== 'line' && trackDims) {
                    const fillY = curve.fillMode === 'bottom' ? trackBottom : trackTop;
                    pathD = `M ${points[0].x} ${fillY} L ${points[0].x} ${points[0].y}`;
                    for (let i = 1; i < points.length; i++) {
                        pathD += ` L ${points[i].x} ${points[i].y}`;
                    }
                    pathD += ` L ${points[points.length - 1].x} ${fillY} Z`;
                }
                
                return pathD;
            },
            
            // Show continuation segment on a subsequent page
            // Uses curveData samples for pixel-accurate rendering
            // sectionHint: 'top' or 'bottom' to specify which section to render on
            showContinuationSegment(curve, page, secondsPerPage, leadInSec, sectionHint) {
                const startActual = curve.startSeconds + leadInSec;
                const endActual = curve.endSeconds + leadInSec;
                const pageStartTime = page * secondsPerPage;
                const pageEndTime = (page + 1) * secondsPerPage;
                
                // Clip times to this page (in score time, not actual time)
                const clippedStartActual = Math.max(startActual, pageStartTime);
                const clippedEndActual = Math.min(endActual, pageEndTime);
                const clippedStartSec = clippedStartActual - leadInSec;
                const clippedEndSec = clippedEndActual - leadInSec;
                
                // Use sectionHint if provided, otherwise calculate from page
                const section = sectionHint || (page % 2 === 0 ? 'top' : 'bottom');
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const targetContainer = section === 'top' ? this.topCurveGroup : this.bottomCurveGroup;
                const scoreWidth = scoreEl.clientWidth;
                
                // X positions within this page
                const startXPercent = ((clippedStartActual / secondsPerPage) - page) * 100;
                const endXPercent = ((clippedEndActual / secondsPerPage) - page) * 100;
                const x1Pixel = (startXPercent / 100) * scoreWidth;
                const x2Pixel = (endXPercent / 100) * scoreWidth;
                
                // Get track dimensions for this section
                let trackDimsForSection = curve.trackDims;
                if (curve.gTrack && window.CompositionPanel) {
                    trackDimsForSection = CompositionPanel.getTrackDimensions(curve.gTrack, scoreEl) || curve.trackDims;
                }
                
                // Use curveData samples for pixel-accurate curve rendering
                // Create a temporary curve object with the section's trackDims
                const tempCurve = { ...curve, trackDims: trackDimsForSection };
                const pathD = this.generatePathFromCurveData(tempCurve, clippedStartSec, clippedEndSec, scoreEl, x1Pixel, x2Pixel);
                
                // Use separate continuation groups for top and bottom sections
                // This allows showing continuation segments on both visible pages simultaneously
                const groupKey = section === 'top' ? 'continuationGroupTop' : 'continuationGroupBottom';
                const pathKey = section === 'top' ? 'continuationPathTop' : 'continuationPathBottom';
                
                // Create or update continuation segment (display only - no interactivity)
                // All controls are on the first segment
                if (!curve.elements[groupKey]) {
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.classList.add('curve-continuation');
                    group.setAttribute('data-curve-id', curve.id);
                    
                    // Main path (display only)
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', ColorMap[curve.color] || curve.color);
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('stroke-linecap', 'round');
                    path.style.pointerEvents = 'none'; // No interaction
                    group.appendChild(path);
                    
                    curve.elements[groupKey] = group;
                    curve.elements[pathKey] = path;
                }
                
                const color = ColorMap[curve.color] || curve.color;
                if (pathD) {
                    curve.elements[pathKey].setAttribute('d', pathD);
                }
                curve.elements[pathKey].setAttribute('stroke', color);
                
                // Apply fill mode to continuation segment
                if (curve.fillMode && curve.fillMode !== 'line') {
                    curve.elements[pathKey].setAttribute('fill', color);
                    curve.elements[pathKey].setAttribute('fill-opacity', '0.3');
                } else {
                    curve.elements[pathKey].setAttribute('fill', 'none');
                }
                
                curve.elements[groupKey].style.display = '';
                
                // Add to correct container
                if (curve.elements[groupKey].parentNode !== targetContainer) {
                    targetContainer.appendChild(curve.elements[groupKey]);
                }
                
                // Store segment info for later use
                curve.continuationSegment = {
                    page,
                    x1: x1Pixel,
                    x2: x2Pixel
                };
            },
            
            // Restore original rendering when returning to curve's original page
            restoreOriginalRendering(curve) {
                if (!curve.elements || !curve.elements.path) return;
                
                // Move curve back to original container
                const originalContainer = curve.section === 'bottom' ? this.bottomCurveGroup : this.topCurveGroup;
                if (curve.elements.group.parentNode !== originalContainer) {
                    originalContainer.appendChild(curve.elements.group);
                }
                
                // Restore original path using stored coordinates
                const color = ColorMap[curve.color] || curve.color;
                const slope = curve.slope || 0;
                const curveWidth = curve.x2 - curve.x1;
                const ctrlX = curve.x1 + (curveWidth * (0.5 + slope * 0.45));
                const ctrlY = slope >= 0 
                    ? curve.y1Pixel + (curve.y2Pixel - curve.y1Pixel) * (1 - Math.abs(slope)) * 0.5
                    : curve.y2Pixel - (curve.y2Pixel - curve.y1Pixel) * (1 - Math.abs(slope)) * 0.5;
                
                const pathD = `M ${curve.x1} ${curve.y1Pixel} Q ${ctrlX} ${ctrlY}, ${curve.x2} ${curve.y2Pixel}`;
                console.log(`[restoreOriginalRendering] ${curve.name}: pathD=${pathD}`);
                
                curve.elements.path.setAttribute('d', pathD);
                if (curve.elements.hitPath) {
                    curve.elements.hitPath.setAttribute('d', pathD);
                }
                
                // Update bounding box and endpoints
                this.updateBoundingBox(curve);
                if (curve.elements.startPoint) {
                    curve.elements.startPoint.setAttribute('cx', curve.x1);
                    curve.elements.startPoint.setAttribute('cy', curve.y1Pixel);
                }
                if (curve.elements.endPoint) {
                    curve.elements.endPoint.setAttribute('cx', curve.x2);
                    curve.elements.endPoint.setAttribute('cy', curve.y2Pixel);
                }
            },
            
            // Clip curve path to current visible page bounds
            updateCurveClipping(curve, targetPage, secondsPerPage, leadInSeconds) {
                if (!curve.elements || !curve.elements.path) return;
                
                const startActual = curve.startSeconds + leadInSeconds;
                const endActual = curve.endSeconds + leadInSeconds;
                
                // Calculate page time bounds
                const pageStartTime = targetPage * secondsPerPage;
                const pageEndTime = (targetPage + 1) * secondsPerPage;
                
                // Clip curve times to page bounds
                const clippedStart = Math.max(startActual, pageStartTime);
                const clippedEnd = Math.min(endActual, pageEndTime);
                
                // Calculate X positions as percentages within the page
                const startXPercent = ((clippedStart / secondsPerPage) - targetPage) * 100;
                const endXPercent = ((clippedEnd / secondsPerPage) - targetPage) * 100;
                
                // Get score dimensions
                const section = targetPage % 2 === 0 ? 'top' : 'bottom';
                const scoreEl = section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                
                console.log(`[updateCurveClipping] ${curve.name}: targetPage=${targetPage}, section=${section}`);
                console.log(`  startActual=${startActual.toFixed(2)}, endActual=${endActual.toFixed(2)}`);
                console.log(`  pageStartTime=${pageStartTime}, pageEndTime=${pageEndTime}`);
                console.log(`  clippedStart=${clippedStart.toFixed(2)}, clippedEnd=${clippedEnd.toFixed(2)}`);
                console.log(`  startXPercent=${startXPercent.toFixed(1)}%, endXPercent=${endXPercent.toFixed(1)}%`);
                const scoreWidth = scoreEl.clientWidth;
                
                // Calculate pixel positions
                const x1Pixel = (startXPercent / 100) * scoreWidth;
                const x2Pixel = (endXPercent / 100) * scoreWidth;
                
                // Calculate Y positions based on curve progress at clipped points
                const curveProgress1 = (clippedStart - startActual) / (endActual - startActual);
                const curveProgress2 = (clippedEnd - startActual) / (endActual - startActual);
                
                // For multi-page curves, recalculate Y positions based on track dimensions
                // Get fresh track dimensions for the TARGET section (may differ from original)
                let trackDims = curve.trackDims;
                if (window.CompositionPanel && curve.gTrack) {
                    // Get track dimensions for the target section's SVG
                    trackDims = CompositionPanel.getTrackDimensions(curve.gTrack, scoreEl);
                }
                
                let y1Clipped, y2Clipped;
                if (!trackDims) {
                    // Fallback to original pixel values
                    const origY1 = curve.origY1Pixel || curve.y1Pixel;
                    const origY2 = curve.origY2Pixel || curve.y2Pixel;
                    y1Clipped = origY1 + (origY2 - origY1) * curveProgress1;
                    y2Clipped = origY1 + (origY2 - origY1) * curveProgress2;
                } else {
                    // Recalculate Y from normalized values for the target section
                    const trackBottom = trackDims.y + trackDims.height;
                    const origY1Pixel = trackBottom - (curve.y1 / 10) * trackDims.height;
                    const origY2Pixel = trackBottom - (curve.y2 / 10) * trackDims.height;
                    y1Clipped = origY1Pixel + (origY2Pixel - origY1Pixel) * curveProgress1;
                    y2Clipped = origY1Pixel + (origY2Pixel - origY1Pixel) * curveProgress2;
                }
                
                // Update the path with clipped coordinates
                const color = ColorMap[curve.color] || curve.color;
                const slope = curve.slope || 0;
                const curveWidth = x2Pixel - x1Pixel;
                const ctrlXOffset = curveWidth * 0.5 * (1 + slope);
                const ctrlX = x1Pixel + ctrlXOffset;
                
                // Control point Y: interpolate based on tension
                const tension = curve.tension || 0;
                const midY = (y1Clipped + y2Clipped) / 2;
                const ctrlY = midY - tension * 50;
                
                const pathD = `M ${x1Pixel} ${y1Clipped} Q ${ctrlX} ${ctrlY} ${x2Pixel} ${y2Clipped}`;
                console.log(`  pathD: ${pathD}`);
                
                curve.elements.path.setAttribute('d', pathD);
                if (curve.elements.hitPath) {
                    curve.elements.hitPath.setAttribute('d', pathD);
                }
                
                // Move curve to correct container if needed
                const targetContainer = section === 'top' ? this.topCurveGroup : this.bottomCurveGroup;
                if (curve.elements.group.parentNode !== targetContainer) {
                    targetContainer.appendChild(curve.elements.group);
                }
                
                // Update bounding box
                this.updateBoundingBox(curve);
                
                // Update endpoint positions
                if (curve.elements.startPoint) {
                    curve.elements.startPoint.setAttribute('cx', x1Pixel);
                    curve.elements.startPoint.setAttribute('cy', y1Clipped);
                }
                if (curve.elements.endPoint) {
                    curve.elements.endPoint.setAttribute('cx', x2Pixel);
                    curve.elements.endPoint.setAttribute('cy', y2Clipped);
                }
                
                // Store clipped values for connector system
                curve.x1 = x1Pixel;
                curve.x2 = x2Pixel;
                curve.y1Pixel = y1Clipped;
                curve.y2Pixel = y2Clipped;
            },
            
            deleteSelectedCurve() {
                if (!this.selectedCurve) return;
                
                const curve = this.selectedCurve;
                const curveName = curve.name;
                
                // Remove SVG elements from DOM (primary segment)
                if (curve.elements && curve.elements.group) {
                    curve.elements.group.remove();
                }
                
                // Remove continuation segments if they exist (multi-page curves)
                if (curve.elements && curve.elements.continuationGroup) {
                    curve.elements.continuationGroup.remove();
                }
                if (curve.elements && curve.elements.continuationGroupTop) {
                    curve.elements.continuationGroupTop.remove();
                }
                if (curve.elements && curve.elements.continuationGroupBottom) {
                    curve.elements.continuationGroupBottom.remove();
                }
                
                // Remove from G Track graphic items
                if (curve.gTrack !== 'A' && window.GTrackSystem) {
                    const trackIndex = parseInt(curve.gTrack) - 1;
                    const gTrack = GTrackSystem.getGTrack(trackIndex);
                    if (gTrack) {
                        const itemIndex = gTrack.graphicItems.findIndex(i => i.curveId === curve.id);
                        if (itemIndex !== -1) {
                            gTrack.graphicItems.splice(itemIndex, 1);
                        }
                    }
                }
                
                // Remove from CurveDatabase
                CurveDatabase.remove(curve.id);
                
                // Remove from CurveMaker.curves array
                const curveIndex = this.curves.findIndex(c => c.id === curve.id);
                if (curveIndex !== -1) {
                    this.curves.splice(curveIndex, 1);
                }
                
                // Mark score as dirty (has unsaved changes)
                if (window.ScoreManager) ScoreManager.markDirty();
                
                // Clear selection
                this.selectedCurve = null;
                this.nameDisplay.value = '';
                
                console.log(`Curve deleted: ${curveName}`);
            },
            
            updateBoundingBox(curve) {
                if (!curve.elements || !curve.elements.boundingBox) return;
                if (!curve.trackDims) return; // Guard against missing trackDims
                
                const bbox = curve.elements.boundingBox;
                const padding = 8;
                
                // Check if this is a multi-page curve
                const secondsPerPage = window.GraphicTimeline ? GraphicTimeline.getSecondsPerPage() : 8;
                const leadInSec = leadInSeconds;
                const startActual = curve.startSeconds + leadInSec;
                const endActual = curve.endSeconds + leadInSec;
                const curveStartPage = Math.floor(Math.max(0, startActual) / secondsPerPage);
                const curveEndPage = Math.floor(Math.max(0, endActual) / secondsPerPage);
                const isMultiPage = curveEndPage > curveStartPage;
                
                // For multi-page curves, clip bounding box to first segment (page edge)
                const scoreEl = curve.section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                const x2ForBbox = isMultiPage ? scoreWidth : curve.x2;
                
                const minX = Math.min(curve.x1, x2ForBbox) - padding;
                const maxX = Math.max(curve.x1, x2ForBbox) + padding;
                
                if (isMultiPage) {
                    // Multi-page curve: bounding box spans FULL track height
                    // This allows full Y range control via the preview curve
                    bbox.setAttribute('x', minX);
                    bbox.setAttribute('y', curve.trackDims.y);
                    bbox.setAttribute('width', Math.max(1, maxX - minX));
                    bbox.setAttribute('height', curve.trackDims.height);
                } else {
                    // Single-page curve: bounding box fits the actual curve
                    const tensionOffset = Math.abs(curve.tension || 0) * curve.trackDims.height * 0.5;
                    const minY = Math.min(curve.y1Pixel, curve.y2Pixel) - padding - tensionOffset;
                    const maxY = Math.max(curve.y1Pixel, curve.y2Pixel) + padding + tensionOffset;
                    
                    bbox.setAttribute('x', minX);
                    bbox.setAttribute('y', Math.max(curve.trackDims.y, minY));
                    bbox.setAttribute('width', Math.max(1, maxX - minX));
                    bbox.setAttribute('height', Math.max(1, Math.min(curve.trackDims.height, maxY - minY)));
                }
            },
            
            updateInputsFromCurve(curve) {
                const scoreEl = curve.section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                // Convert X pixels back to seconds
                const startXPercent = (curve.x1 / scoreWidth) * 100;
                const endXPercent = (curve.x2 / scoreWidth) * 100;
                const startSeconds = (curve.page + startXPercent / 100) * secondsPerPage - leadInSeconds;
                const endSeconds = (curve.page + endXPercent / 100) * secondsPerPage - leadInSeconds;
                
                // Convert Y pixels back to relative (0-10)
                const trackBottom = curve.trackDims.y + curve.trackDims.height;
                const y1 = ((trackBottom - curve.y1Pixel) / curve.trackDims.height) * 10;
                const y2 = ((trackBottom - curve.y2Pixel) / curve.trackDims.height) * 10;
                
                // Update inputs
                this.startInput.value = startSeconds.toFixed(3);
                this.endInput.value = endSeconds.toFixed(3);
                this.y1Input.value = Math.max(0, Math.min(10, y1)).toFixed(1);
                this.y2Input.value = Math.max(0, Math.min(10, y2)).toFixed(1);
                
                // Update curve data
                curve.startSeconds = startSeconds;
                curve.endSeconds = endSeconds;
                curve.y1 = y1;
                curve.y2 = y2;
            },
            
            updateSelectedFromInputs() {
                if (!this.selectedCurve) return;
                
                const curve = this.selectedCurve;
                const scoreEl = curve.section === 'top' ? this.scoreTopEl : this.scoreBottomEl;
                const scoreWidth = scoreEl.clientWidth;
                const secondsPerPage = (beatsPerPage / beatsPerMinute) * 60;
                
                // Read values from inputs
                const startSeconds = parseFloat(this.startInput.value) || 0;
                const endSeconds = parseFloat(this.endInput.value) || 1;
                const y1 = parseFloat(this.y1Input.value) || 0;
                const y2 = parseFloat(this.y2Input.value) || 10;
                
                // Convert to pixels
                const startActual = startSeconds + leadInSeconds;
                const endActual = endSeconds + leadInSeconds;
                const startXPercent = ((startActual / secondsPerPage) - curve.page) * 100;
                const endXPercent = ((endActual / secondsPerPage) - curve.page) * 100;
                
                curve.x1 = (startXPercent / 100) * scoreWidth;
                curve.x2 = (endXPercent / 100) * scoreWidth;
                
                const trackBottom = curve.trackDims.y + curve.trackDims.height;
                curve.y1Pixel = trackBottom - (y1 / 10) * curve.trackDims.height;
                curve.y2Pixel = trackBottom - (y2 / 10) * curve.trackDims.height;
                
                curve.startSeconds = startSeconds;
                curve.endSeconds = endSeconds;
                curve.y1 = y1;
                curve.y2 = y2;
                
                // Update rendering
                this.updateCurveRendering(curve);
                this.updateBoundingBox(curve);
                this.syncCurveToDatabase(curve);
                // Update visibility to refresh continuation segments
                this.updateVisibility();
            },
            
            syncCurveToDatabase(curve) {
                // Regenerate curveData array when curve is modified
                const curveDataArray = this.generateCurveDataArray(curve);
                curve.curveData = curveDataArray;
                
                // Mark score as dirty (has unsaved changes)
                if (window.ScoreManager) ScoreManager.markDirty();
                
                // Update curve in database
                CurveDatabase.update(curve.id, {
                    startSeconds: curve.startSeconds,
                    endSeconds: curve.endSeconds,
                    y1: curve.y1,
                    y2: curve.y2,
                    color: curve.color,
                    fillMode: curve.fillMode,
                    tension: curve.tension,
                    slope: curve.slope,
                    x1: curve.x1,
                    y1Pixel: curve.y1Pixel,
                    x2: curve.x2,
                    y2Pixel: curve.y2Pixel,
                    curveData: curveDataArray
                });
                
                // Update in G Track if applicable
                if (curve.gTrack !== 'A' && window.GTrackSystem) {
                    const trackIndex = parseInt(curve.gTrack) - 1;
                    const gTrack = GTrackSystem.getGTrack(trackIndex);
                    if (gTrack) {
                        const item = gTrack.graphicItems.find(i => i.curveId === curve.id);
                        if (item) {
                            item.scoreTimeMs = curve.startSeconds * 1000;
                            item.duration = (curve.endSeconds - curve.startSeconds) * 1000;
                            item.curveData = curveDataArray;
                            item.color = curve.color;
                            item.fillMode = curve.fillMode;
                        }
                    }
                }
            },
            
            updateCurveRendering(curve) {
                if (!curve.elements) return;
                
                const { path, hitPath, startPoint, endPoint, boundingBox } = curve.elements;
                const color = ColorMap[curve.color] || curve.color;
                
                // DAW-style curve shaping:
                // slope controls where the "knee" is (-1 = left edge, +1 = right edge)
                // Drag right = flat at start, steep rise at end
                // Drag left = steep rise at start, flat at end
                // Curve stays within Y bounds of endpoints (no protrusion)
                const slope = curve.slope || 0;
                const curveWidth = Math.abs(curve.x2 - curve.x1);
                
                // Control point X: slope moves it from left edge to right edge
                // slope -1 = control at x1, slope +1 = control at x2, slope 0 = middle
                const ctrlX = curve.x1 + (curveWidth * (0.5 + slope * 0.45));
                
                // Control point Y: stays at the Y value of the opposite endpoint
                // This creates the "flat then steep" or "steep then flat" effect
                // When slope > 0 (dragging right): ctrl Y near y1 (start), curve flat then rises
                // When slope < 0 (dragging left): ctrl Y near y2 (end), curve rises then flat
                const ctrlY = slope >= 0 
                    ? curve.y1Pixel + (curve.y2Pixel - curve.y1Pixel) * (1 - Math.abs(slope)) * 0.5
                    : curve.y2Pixel - (curve.y2Pixel - curve.y1Pixel) * (1 - Math.abs(slope)) * 0.5;
                
                // Update path
                const d = `M ${curve.x1} ${curve.y1Pixel} Q ${ctrlX} ${ctrlY}, ${curve.x2} ${curve.y2Pixel}`;
                
                if (curve.fillMode === 'line' || !curve.trackDims) {
                    // Line mode or missing trackDims - just draw the curve
                    path.setAttribute('d', d);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', color);
                } else {
                    const fillY = curve.fillMode === 'bottom' ? curve.trackDims.y + curve.trackDims.height : curve.trackDims.y;
                    const filledD = `M ${curve.x1} ${fillY} L ${curve.x1} ${curve.y1Pixel} Q ${ctrlX} ${ctrlY}, ${curve.x2} ${curve.y2Pixel} L ${curve.x2} ${fillY} Z`;
                    path.setAttribute('d', filledD);
                    path.setAttribute('fill', color);
                    path.setAttribute('fill-opacity', '0.3');
                    path.setAttribute('stroke', color);
                }
                
                // Update hit path for easier clicking
                if (hitPath) {
                    hitPath.setAttribute('d', d);
                }
                
                // Update endpoint colors
                startPoint.setAttribute('fill', color);
                endPoint.setAttribute('fill', color);
                
                // Update bounding box color
                boundingBox.setAttribute('stroke', color);
                boundingBox.setAttribute('fill', color);
                
                // Update points positions
                startPoint.setAttribute('cx', curve.x1);
                startPoint.setAttribute('cy', curve.y1Pixel);
                endPoint.setAttribute('cx', curve.x2);
                endPoint.setAttribute('cy', curve.y2Pixel);
            },
            
            // Reload curves from CurveDatabase (called after loading a score)
            reloadFromDatabase() {
                // Clear existing curve elements
                if (this.topCurveGroup) this.topCurveGroup.innerHTML = '';
                if (this.bottomCurveGroup) this.bottomCurveGroup.innerHTML = '';
                this.curves = [];
                this.selectedCurve = null;
                
                // Clear GTrackSystem graphic items to avoid duplicates
                if (window.GTrackSystem) {
                    GTrackSystem.clearAllGraphicItems();
                }
                
                // Recreate curves from database
                const dbCurves = CurveDatabase.getAll();
                for (const dbCurve of dbCurves) {
                    // Recreate the curve visual elements
                    const curve = { ...dbCurve };
                    
                    // Determine which container to use
                    const container = curve.section === 'bottom' ? this.bottomCurveGroup : this.topCurveGroup;
                    
                    // Create SVG elements for the curve
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.setAttribute('class', 'curve-group');
                    
                    // Create path
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('class', 'curve-path');
                    path.setAttribute('stroke', curve.color || '#4CAF50');
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('fill', 'none');
                    
                    // Create hit path for easier clicking
                    const hitPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    hitPath.setAttribute('class', 'curve-hit-path');
                    hitPath.setAttribute('stroke', 'transparent');
                    hitPath.setAttribute('stroke-width', '10');
                    hitPath.setAttribute('fill', 'none');
                    hitPath.style.cursor = 'pointer';
                    
                    // Create bounding box (hidden by default)
                    const boundingBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    boundingBox.setAttribute('class', 'curve-bounding-box');
                    boundingBox.setAttribute('stroke', curve.color || '#4CAF50');
                    boundingBox.setAttribute('stroke-width', '1');
                    boundingBox.setAttribute('stroke-dasharray', '4,2');
                    boundingBox.setAttribute('fill', curve.color || '#4CAF50');
                    boundingBox.setAttribute('fill-opacity', '0.1');
                    boundingBox.style.display = 'none';
                    
                    // Create endpoint circles
                    const startPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    startPoint.setAttribute('class', 'curve-endpoint curve-start');
                    startPoint.setAttribute('r', '4');
                    startPoint.setAttribute('fill', curve.color || '#4CAF50');
                    startPoint.style.display = 'none';
                    
                    const endPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    endPoint.setAttribute('class', 'curve-endpoint curve-end');
                    endPoint.setAttribute('r', '4');
                    endPoint.setAttribute('fill', curve.color || '#4CAF50');
                    endPoint.style.display = 'none';
                    
                    // Assemble group
                    group.appendChild(hitPath);
                    group.appendChild(path);
                    group.appendChild(boundingBox);
                    group.appendChild(startPoint);
                    group.appendChild(endPoint);
                    container.appendChild(group);
                    
                    // Store element references
                    curve.elements = { group, path, hitPath, boundingBox, startPoint, endPoint };
                    
                    // Add to curves array
                    this.curves.push(curve);
                    
                    // Update rendering
                    this.updateCurveRendering(curve);
                    this.updateBoundingBox(curve);
                    
                    // Add click handler for selection
                    hitPath.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectCurve(curve);
                    });
                    
                    // Add drag handlers for endpoints (makes curves editable)
                    startPoint.style.cursor = 'ns-resize';
                    startPoint.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'start'));
                    
                    endPoint.style.cursor = 'ns-resize';
                    endPoint.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'end'));
                    
                    // Add drag handler for bounding box (move entire curve)
                    boundingBox.style.cursor = 'move';
                    boundingBox.addEventListener('mousedown', (e) => this.handleCurveMouseDown(e, curve, 'move'));
                    
                    // Re-add to GTrackSystem for curve follower functionality
                    if (curve.gTrack && curve.gTrack !== 'A' && window.GTrackSystem) {
                        const trackIndex = parseInt(curve.gTrack) - 1;
                        if (trackIndex >= 0 && trackIndex < 4) {
                            // Regenerate curveData if not present
                            let curveDataArray = curve.curveData;
                            if (!curveDataArray) {
                                curveDataArray = this.generateCurveDataArray(curve);
                                curve.curveData = curveDataArray;
                            }
                            
                            GTrackSystem.addGraphicItem(trackIndex, {
                                type: 'curve',
                                curveId: curve.id,
                                curveName: curve.name,
                                color: curve.color,
                                fillMode: curve.fillMode,
                                scoreTimeMs: curve.startSeconds * 1000,
                                duration: (curve.endSeconds - curve.startSeconds) * 1000,
                                curveData: curveDataArray
                            });
                        }
                    }
                }
                
                console.log(`CurveMaker: Reloaded ${this.curves.length} curves from database`);
                
                // Update visibility to show all visible segments immediately
                this.updateVisibility();
            }
        };
        
        // Initialize Curve Maker
        CurveMaker.init();
        window.CurveMaker = CurveMaker;
        
        // Initialize Score Manager (after all other systems)
        ScoreManager.init();
        window.ScoreManager = ScoreManager;
        
        // Initialize Notation Manager and register with ScoreManager
        NotationManager.init();
        window.NotationManager = NotationManager;
        ScoreManager.registerNotationSource();
    </script>
</body>
</html>
